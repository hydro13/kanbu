
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceLogo
 * 
 */
export type WorkspaceLogo = $Result.DefaultSelection<Prisma.$WorkspaceLogoPayload>
/**
 * Model WorkspaceUser
 * 
 */
export type WorkspaceUser = $Result.DefaultSelection<Prisma.$WorkspaceUserPayload>
/**
 * Model WorkspaceInvitation
 * 
 */
export type WorkspaceInvitation = $Result.DefaultSelection<Prisma.$WorkspaceInvitationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model RememberToken
 * 
 */
export type RememberToken = $Result.DefaultSelection<Prisma.$RememberTokenPayload>
/**
 * Model Invite
 * 
 */
export type Invite = $Result.DefaultSelection<Prisma.$InvitePayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model Column
 * 
 */
export type Column = $Result.DefaultSelection<Prisma.$ColumnPayload>
/**
 * Model Swimlane
 * 
 */
export type Swimlane = $Result.DefaultSelection<Prisma.$SwimlanePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskAssignee
 * 
 */
export type TaskAssignee = $Result.DefaultSelection<Prisma.$TaskAssigneePayload>
/**
 * Model Subtask
 * 
 */
export type Subtask = $Result.DefaultSelection<Prisma.$SubtaskPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TaskTag
 * 
 */
export type TaskTag = $Result.DefaultSelection<Prisma.$TaskTagPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model TaskLink
 * 
 */
export type TaskLink = $Result.DefaultSelection<Prisma.$TaskLinkPayload>
/**
 * Model CustomField
 * 
 */
export type CustomField = $Result.DefaultSelection<Prisma.$CustomFieldPayload>
/**
 * Model TaskCustomValue
 * 
 */
export type TaskCustomValue = $Result.DefaultSelection<Prisma.$TaskCustomValuePayload>
/**
 * Model Sprint
 * 
 */
export type Sprint = $Result.DefaultSelection<Prisma.$SprintPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model StickyNote
 * 
 */
export type StickyNote = $Result.DefaultSelection<Prisma.$StickyNotePayload>
/**
 * Model StickyNoteLink
 * 
 */
export type StickyNoteLink = $Result.DefaultSelection<Prisma.$StickyNoteLinkPayload>
/**
 * Model ProjectGroup
 * 
 */
export type ProjectGroup = $Result.DefaultSelection<Prisma.$ProjectGroupPayload>
/**
 * Model ProjectGroupMember
 * 
 */
export type ProjectGroupMember = $Result.DefaultSelection<Prisma.$ProjectGroupMemberPayload>
/**
 * Model TaskSession
 * 
 */
export type TaskSession = $Result.DefaultSelection<Prisma.$TaskSessionPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetLine
 * 
 */
export type BudgetLine = $Result.DefaultSelection<Prisma.$BudgetLinePayload>
/**
 * Model WikiPage
 * 
 */
export type WikiPage = $Result.DefaultSelection<Prisma.$WikiPagePayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model LastLogin
 * 
 */
export type LastLogin = $Result.DefaultSelection<Prisma.$LastLoginPayload>
/**
 * Model UserMetadata
 * 
 */
export type UserMetadata = $Result.DefaultSelection<Prisma.$UserMetadataPayload>
/**
 * Model UserNotificationSetting
 * 
 */
export type UserNotificationSetting = $Result.DefaultSelection<Prisma.$UserNotificationSettingPayload>
/**
 * Model UserAvatar
 * 
 */
export type UserAvatar = $Result.DefaultSelection<Prisma.$UserAvatarPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model GroupPermission
 * 
 */
export type GroupPermission = $Result.DefaultSelection<Prisma.$GroupPermissionPayload>
/**
 * Model RoleAssignment
 * 
 */
export type RoleAssignment = $Result.DefaultSelection<Prisma.$RoleAssignmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WorkspaceRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type WorkspaceRole = (typeof WorkspaceRole)[keyof typeof WorkspaceRole]


export const AppRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER'
};

export type AppRole = (typeof AppRole)[keyof typeof AppRole]


export const ProjectRole: {
  OWNER: 'OWNER',
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type ProjectRole = (typeof ProjectRole)[keyof typeof ProjectRole]


export const SubtaskStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE'
};

export type SubtaskStatus = (typeof SubtaskStatus)[keyof typeof SubtaskStatus]


export const TaskLinkType: {
  RELATES_TO: 'RELATES_TO',
  BLOCKS: 'BLOCKS',
  IS_BLOCKED_BY: 'IS_BLOCKED_BY',
  DUPLICATES: 'DUPLICATES',
  IS_DUPLICATED_BY: 'IS_DUPLICATED_BY',
  IS_CHILD_OF: 'IS_CHILD_OF',
  IS_PARENT_OF: 'IS_PARENT_OF',
  FOLLOWS: 'FOLLOWS',
  IS_FOLLOWED_BY: 'IS_FOLLOWED_BY',
  FIXES: 'FIXES',
  IS_FIXED_BY: 'IS_FIXED_BY'
};

export type TaskLinkType = (typeof TaskLinkType)[keyof typeof TaskLinkType]


export const CustomFieldType: {
  TEXT: 'TEXT',
  NUMBER: 'NUMBER',
  DATE: 'DATE',
  CHECKBOX: 'CHECKBOX',
  DROPDOWN: 'DROPDOWN',
  URL: 'URL',
  EMAIL: 'EMAIL'
};

export type CustomFieldType = (typeof CustomFieldType)[keyof typeof CustomFieldType]


export const SprintStatus: {
  PLANNING: 'PLANNING',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED'
};

export type SprintStatus = (typeof SprintStatus)[keyof typeof SprintStatus]


export const StickyNoteColor: {
  YELLOW: 'YELLOW',
  PINK: 'PINK',
  BLUE: 'BLUE',
  GREEN: 'GREEN',
  PURPLE: 'PURPLE',
  ORANGE: 'ORANGE'
};

export type StickyNoteColor = (typeof StickyNoteColor)[keyof typeof StickyNoteColor]


export const StickyVisibility: {
  PRIVATE: 'PRIVATE',
  PUBLIC: 'PUBLIC'
};

export type StickyVisibility = (typeof StickyVisibility)[keyof typeof StickyVisibility]


export const StickyLinkType: {
  PROJECT: 'PROJECT',
  TASK: 'TASK',
  SPRINT: 'SPRINT',
  WIKI_PAGE: 'WIKI_PAGE',
  PROJECT_GROUP: 'PROJECT_GROUP'
};

export type StickyLinkType = (typeof StickyLinkType)[keyof typeof StickyLinkType]


export const ProjectGroupStatus: {
  DRAFT: 'DRAFT',
  PLANNED: 'PLANNED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CLOSED: 'CLOSED'
};

export type ProjectGroupStatus = (typeof ProjectGroupStatus)[keyof typeof ProjectGroupStatus]


export const TaskSessionType: {
  WORKED_ON: 'WORKED_ON',
  CREATED: 'CREATED',
  REVIEWED: 'REVIEWED',
  MENTIONED: 'MENTIONED'
};

export type TaskSessionType = (typeof TaskSessionType)[keyof typeof TaskSessionType]


export const BudgetLineType: {
  EXPENSE: 'EXPENSE',
  INCOME: 'INCOME'
};

export type BudgetLineType = (typeof BudgetLineType)[keyof typeof BudgetLineType]


export const GroupType: {
  SYSTEM: 'SYSTEM',
  WORKSPACE: 'WORKSPACE',
  WORKSPACE_ADMIN: 'WORKSPACE_ADMIN',
  PROJECT: 'PROJECT',
  PROJECT_ADMIN: 'PROJECT_ADMIN',
  CUSTOM: 'CUSTOM'
};

export type GroupType = (typeof GroupType)[keyof typeof GroupType]


export const GroupScope: {
  DOMAIN_LOCAL: 'DOMAIN_LOCAL',
  GLOBAL: 'GLOBAL',
  UNIVERSAL: 'UNIVERSAL'
};

export type GroupScope = (typeof GroupScope)[keyof typeof GroupScope]


export const MemberType: {
  DIRECT: 'DIRECT',
  NESTED: 'NESTED',
  DYNAMIC: 'DYNAMIC'
};

export type MemberType = (typeof MemberType)[keyof typeof MemberType]


export const AccessType: {
  ALLOW: 'ALLOW',
  DENY: 'DENY'
};

export type AccessType = (typeof AccessType)[keyof typeof AccessType]


export const GroupSource: {
  LOCAL: 'LOCAL',
  LDAP: 'LDAP',
  AZURE_AD: 'AZURE_AD',
  SCIM: 'SCIM'
};

export type GroupSource = (typeof GroupSource)[keyof typeof GroupSource]


export const AssignmentRole: {
  VIEWER: 'VIEWER',
  MEMBER: 'MEMBER',
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN',
  OWNER: 'OWNER'
};

export type AssignmentRole = (typeof AssignmentRole)[keyof typeof AssignmentRole]

}

export type WorkspaceRole = $Enums.WorkspaceRole

export const WorkspaceRole: typeof $Enums.WorkspaceRole

export type AppRole = $Enums.AppRole

export const AppRole: typeof $Enums.AppRole

export type ProjectRole = $Enums.ProjectRole

export const ProjectRole: typeof $Enums.ProjectRole

export type SubtaskStatus = $Enums.SubtaskStatus

export const SubtaskStatus: typeof $Enums.SubtaskStatus

export type TaskLinkType = $Enums.TaskLinkType

export const TaskLinkType: typeof $Enums.TaskLinkType

export type CustomFieldType = $Enums.CustomFieldType

export const CustomFieldType: typeof $Enums.CustomFieldType

export type SprintStatus = $Enums.SprintStatus

export const SprintStatus: typeof $Enums.SprintStatus

export type StickyNoteColor = $Enums.StickyNoteColor

export const StickyNoteColor: typeof $Enums.StickyNoteColor

export type StickyVisibility = $Enums.StickyVisibility

export const StickyVisibility: typeof $Enums.StickyVisibility

export type StickyLinkType = $Enums.StickyLinkType

export const StickyLinkType: typeof $Enums.StickyLinkType

export type ProjectGroupStatus = $Enums.ProjectGroupStatus

export const ProjectGroupStatus: typeof $Enums.ProjectGroupStatus

export type TaskSessionType = $Enums.TaskSessionType

export const TaskSessionType: typeof $Enums.TaskSessionType

export type BudgetLineType = $Enums.BudgetLineType

export const BudgetLineType: typeof $Enums.BudgetLineType

export type GroupType = $Enums.GroupType

export const GroupType: typeof $Enums.GroupType

export type GroupScope = $Enums.GroupScope

export const GroupScope: typeof $Enums.GroupScope

export type MemberType = $Enums.MemberType

export const MemberType: typeof $Enums.MemberType

export type AccessType = $Enums.AccessType

export const AccessType: typeof $Enums.AccessType

export type GroupSource = $Enums.GroupSource

export const GroupSource: typeof $Enums.GroupSource

export type AssignmentRole = $Enums.AssignmentRole

export const AssignmentRole: typeof $Enums.AssignmentRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Workspaces
 * const workspaces = await prisma.workspace.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Workspaces
   * const workspaces = await prisma.workspace.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceLogo`: Exposes CRUD operations for the **WorkspaceLogo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceLogos
    * const workspaceLogos = await prisma.workspaceLogo.findMany()
    * ```
    */
  get workspaceLogo(): Prisma.WorkspaceLogoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceUser`: Exposes CRUD operations for the **WorkspaceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUsers
    * const workspaceUsers = await prisma.workspaceUser.findMany()
    * ```
    */
  get workspaceUser(): Prisma.WorkspaceUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceInvitation`: Exposes CRUD operations for the **WorkspaceInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceInvitations
    * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
    * ```
    */
  get workspaceInvitation(): Prisma.WorkspaceInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rememberToken`: Exposes CRUD operations for the **RememberToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RememberTokens
    * const rememberTokens = await prisma.rememberToken.findMany()
    * ```
    */
  get rememberToken(): Prisma.RememberTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **Invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.InviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.column`: Exposes CRUD operations for the **Column** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Columns
    * const columns = await prisma.column.findMany()
    * ```
    */
  get column(): Prisma.ColumnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.swimlane`: Exposes CRUD operations for the **Swimlane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Swimlanes
    * const swimlanes = await prisma.swimlane.findMany()
    * ```
    */
  get swimlane(): Prisma.SwimlaneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignee`: Exposes CRUD operations for the **TaskAssignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignees
    * const taskAssignees = await prisma.taskAssignee.findMany()
    * ```
    */
  get taskAssignee(): Prisma.TaskAssigneeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subtask`: Exposes CRUD operations for the **Subtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtasks
    * const subtasks = await prisma.subtask.findMany()
    * ```
    */
  get subtask(): Prisma.SubtaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskTag`: Exposes CRUD operations for the **TaskTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTags
    * const taskTags = await prisma.taskTag.findMany()
    * ```
    */
  get taskTag(): Prisma.TaskTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskLink`: Exposes CRUD operations for the **TaskLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskLinks
    * const taskLinks = await prisma.taskLink.findMany()
    * ```
    */
  get taskLink(): Prisma.TaskLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customField`: Exposes CRUD operations for the **CustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFields
    * const customFields = await prisma.customField.findMany()
    * ```
    */
  get customField(): Prisma.CustomFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskCustomValue`: Exposes CRUD operations for the **TaskCustomValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCustomValues
    * const taskCustomValues = await prisma.taskCustomValue.findMany()
    * ```
    */
  get taskCustomValue(): Prisma.TaskCustomValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sprint`: Exposes CRUD operations for the **Sprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sprints
    * const sprints = await prisma.sprint.findMany()
    * ```
    */
  get sprint(): Prisma.SprintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stickyNote`: Exposes CRUD operations for the **StickyNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StickyNotes
    * const stickyNotes = await prisma.stickyNote.findMany()
    * ```
    */
  get stickyNote(): Prisma.StickyNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stickyNoteLink`: Exposes CRUD operations for the **StickyNoteLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StickyNoteLinks
    * const stickyNoteLinks = await prisma.stickyNoteLink.findMany()
    * ```
    */
  get stickyNoteLink(): Prisma.StickyNoteLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectGroup`: Exposes CRUD operations for the **ProjectGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectGroups
    * const projectGroups = await prisma.projectGroup.findMany()
    * ```
    */
  get projectGroup(): Prisma.ProjectGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectGroupMember`: Exposes CRUD operations for the **ProjectGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectGroupMembers
    * const projectGroupMembers = await prisma.projectGroupMember.findMany()
    * ```
    */
  get projectGroupMember(): Prisma.ProjectGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskSession`: Exposes CRUD operations for the **TaskSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskSessions
    * const taskSessions = await prisma.taskSession.findMany()
    * ```
    */
  get taskSession(): Prisma.TaskSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetLine`: Exposes CRUD operations for the **BudgetLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetLines
    * const budgetLines = await prisma.budgetLine.findMany()
    * ```
    */
  get budgetLine(): Prisma.BudgetLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wikiPage`: Exposes CRUD operations for the **WikiPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WikiPages
    * const wikiPages = await prisma.wikiPage.findMany()
    * ```
    */
  get wikiPage(): Prisma.WikiPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lastLogin`: Exposes CRUD operations for the **LastLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LastLogins
    * const lastLogins = await prisma.lastLogin.findMany()
    * ```
    */
  get lastLogin(): Prisma.LastLoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMetadata`: Exposes CRUD operations for the **UserMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMetadata
    * const userMetadata = await prisma.userMetadata.findMany()
    * ```
    */
  get userMetadata(): Prisma.UserMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNotificationSetting`: Exposes CRUD operations for the **UserNotificationSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotificationSettings
    * const userNotificationSettings = await prisma.userNotificationSetting.findMany()
    * ```
    */
  get userNotificationSetting(): Prisma.UserNotificationSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAvatar`: Exposes CRUD operations for the **UserAvatar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAvatars
    * const userAvatars = await prisma.userAvatar.findMany()
    * ```
    */
  get userAvatar(): Prisma.UserAvatarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupPermission`: Exposes CRUD operations for the **GroupPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupPermissions
    * const groupPermissions = await prisma.groupPermission.findMany()
    * ```
    */
  get groupPermission(): Prisma.GroupPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleAssignment`: Exposes CRUD operations for the **RoleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleAssignments
    * const roleAssignments = await prisma.roleAssignment.findMany()
    * ```
    */
  get roleAssignment(): Prisma.RoleAssignmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Workspace: 'Workspace',
    WorkspaceLogo: 'WorkspaceLogo',
    WorkspaceUser: 'WorkspaceUser',
    WorkspaceInvitation: 'WorkspaceInvitation',
    User: 'User',
    Session: 'Session',
    RememberToken: 'RememberToken',
    Invite: 'Invite',
    SystemSetting: 'SystemSetting',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    Column: 'Column',
    Swimlane: 'Swimlane',
    Task: 'Task',
    TaskAssignee: 'TaskAssignee',
    Subtask: 'Subtask',
    Comment: 'Comment',
    Tag: 'Tag',
    TaskTag: 'TaskTag',
    Category: 'Category',
    Attachment: 'Attachment',
    TaskLink: 'TaskLink',
    CustomField: 'CustomField',
    TaskCustomValue: 'TaskCustomValue',
    Sprint: 'Sprint',
    Module: 'Module',
    Milestone: 'Milestone',
    StickyNote: 'StickyNote',
    StickyNoteLink: 'StickyNoteLink',
    ProjectGroup: 'ProjectGroup',
    ProjectGroupMember: 'ProjectGroupMember',
    TaskSession: 'TaskSession',
    Budget: 'Budget',
    BudgetLine: 'BudgetLine',
    WikiPage: 'WikiPage',
    ApiKey: 'ApiKey',
    Webhook: 'Webhook',
    WebhookDelivery: 'WebhookDelivery',
    Notification: 'Notification',
    Activity: 'Activity',
    PasswordReset: 'PasswordReset',
    LastLogin: 'LastLogin',
    UserMetadata: 'UserMetadata',
    UserNotificationSetting: 'UserNotificationSetting',
    UserAvatar: 'UserAvatar',
    Group: 'Group',
    GroupMember: 'GroupMember',
    Permission: 'Permission',
    GroupPermission: 'GroupPermission',
    RoleAssignment: 'RoleAssignment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "workspace" | "workspaceLogo" | "workspaceUser" | "workspaceInvitation" | "user" | "session" | "rememberToken" | "invite" | "systemSetting" | "project" | "projectMember" | "column" | "swimlane" | "task" | "taskAssignee" | "subtask" | "comment" | "tag" | "taskTag" | "category" | "attachment" | "taskLink" | "customField" | "taskCustomValue" | "sprint" | "module" | "milestone" | "stickyNote" | "stickyNoteLink" | "projectGroup" | "projectGroupMember" | "taskSession" | "budget" | "budgetLine" | "wikiPage" | "apiKey" | "webhook" | "webhookDelivery" | "notification" | "activity" | "passwordReset" | "lastLogin" | "userMetadata" | "userNotificationSetting" | "userAvatar" | "group" | "groupMember" | "permission" | "groupPermission" | "roleAssignment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceLogo: {
        payload: Prisma.$WorkspaceLogoPayload<ExtArgs>
        fields: Prisma.WorkspaceLogoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceLogoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceLogoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceLogoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceLogoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>
          }
          findMany: {
            args: Prisma.WorkspaceLogoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>[]
          }
          create: {
            args: Prisma.WorkspaceLogoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>
          }
          createMany: {
            args: Prisma.WorkspaceLogoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceLogoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceLogoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>
          }
          update: {
            args: Prisma.WorkspaceLogoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceLogoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceLogoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceLogoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceLogoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceLogoPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceLogoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceLogo>
          }
          groupBy: {
            args: Prisma.WorkspaceLogoGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceLogoGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceLogoCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceLogoCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUser: {
        payload: Prisma.$WorkspaceUserPayload<ExtArgs>
        fields: Prisma.WorkspaceUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          update: {
            args: Prisma.WorkspaceUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUser>
          }
          groupBy: {
            args: Prisma.WorkspaceUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceInvitation: {
        payload: Prisma.$WorkspaceInvitationPayload<ExtArgs>
        fields: Prisma.WorkspaceInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          findMany: {
            args: Prisma.WorkspaceInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          create: {
            args: Prisma.WorkspaceInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          createMany: {
            args: Prisma.WorkspaceInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          update: {
            args: Prisma.WorkspaceInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceInvitation>
          }
          groupBy: {
            args: Prisma.WorkspaceInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceInvitationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      RememberToken: {
        payload: Prisma.$RememberTokenPayload<ExtArgs>
        fields: Prisma.RememberTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RememberTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RememberTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>
          }
          findFirst: {
            args: Prisma.RememberTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RememberTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>
          }
          findMany: {
            args: Prisma.RememberTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>[]
          }
          create: {
            args: Prisma.RememberTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>
          }
          createMany: {
            args: Prisma.RememberTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RememberTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>[]
          }
          delete: {
            args: Prisma.RememberTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>
          }
          update: {
            args: Prisma.RememberTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>
          }
          deleteMany: {
            args: Prisma.RememberTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RememberTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RememberTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>[]
          }
          upsert: {
            args: Prisma.RememberTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RememberTokenPayload>
          }
          aggregate: {
            args: Prisma.RememberTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRememberToken>
          }
          groupBy: {
            args: Prisma.RememberTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RememberTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RememberTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RememberTokenCountAggregateOutputType> | number
          }
        }
      }
      Invite: {
        payload: Prisma.$InvitePayload<ExtArgs>
        fields: Prisma.InviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findFirst: {
            args: Prisma.InviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findMany: {
            args: Prisma.InviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          create: {
            args: Prisma.InviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          createMany: {
            args: Prisma.InviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          delete: {
            args: Prisma.InviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          update: {
            args: Prisma.InviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          deleteMany: {
            args: Prisma.InviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          upsert: {
            args: Prisma.InviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.InviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      Column: {
        payload: Prisma.$ColumnPayload<ExtArgs>
        fields: Prisma.ColumnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColumnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColumnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          findFirst: {
            args: Prisma.ColumnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColumnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          findMany: {
            args: Prisma.ColumnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          create: {
            args: Prisma.ColumnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          createMany: {
            args: Prisma.ColumnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColumnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          delete: {
            args: Prisma.ColumnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          update: {
            args: Prisma.ColumnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          deleteMany: {
            args: Prisma.ColumnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColumnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColumnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>[]
          }
          upsert: {
            args: Prisma.ColumnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColumnPayload>
          }
          aggregate: {
            args: Prisma.ColumnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColumn>
          }
          groupBy: {
            args: Prisma.ColumnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColumnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColumnCountArgs<ExtArgs>
            result: $Utils.Optional<ColumnCountAggregateOutputType> | number
          }
        }
      }
      Swimlane: {
        payload: Prisma.$SwimlanePayload<ExtArgs>
        fields: Prisma.SwimlaneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SwimlaneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SwimlaneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>
          }
          findFirst: {
            args: Prisma.SwimlaneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SwimlaneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>
          }
          findMany: {
            args: Prisma.SwimlaneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>[]
          }
          create: {
            args: Prisma.SwimlaneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>
          }
          createMany: {
            args: Prisma.SwimlaneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SwimlaneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>[]
          }
          delete: {
            args: Prisma.SwimlaneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>
          }
          update: {
            args: Prisma.SwimlaneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>
          }
          deleteMany: {
            args: Prisma.SwimlaneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SwimlaneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SwimlaneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>[]
          }
          upsert: {
            args: Prisma.SwimlaneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SwimlanePayload>
          }
          aggregate: {
            args: Prisma.SwimlaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSwimlane>
          }
          groupBy: {
            args: Prisma.SwimlaneGroupByArgs<ExtArgs>
            result: $Utils.Optional<SwimlaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.SwimlaneCountArgs<ExtArgs>
            result: $Utils.Optional<SwimlaneCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignee: {
        payload: Prisma.$TaskAssigneePayload<ExtArgs>
        fields: Prisma.TaskAssigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findFirst: {
            args: Prisma.TaskAssigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findMany: {
            args: Prisma.TaskAssigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          create: {
            args: Prisma.TaskAssigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          createMany: {
            args: Prisma.TaskAssigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          delete: {
            args: Prisma.TaskAssigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          update: {
            args: Prisma.TaskAssigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          deleteMany: {
            args: Prisma.TaskAssigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          upsert: {
            args: Prisma.TaskAssigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          aggregate: {
            args: Prisma.TaskAssigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignee>
          }
          groupBy: {
            args: Prisma.TaskAssigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssigneeCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeCountAggregateOutputType> | number
          }
        }
      }
      Subtask: {
        payload: Prisma.$SubtaskPayload<ExtArgs>
        fields: Prisma.SubtaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findFirst: {
            args: Prisma.SubtaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findMany: {
            args: Prisma.SubtaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          create: {
            args: Prisma.SubtaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          createMany: {
            args: Prisma.SubtaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          delete: {
            args: Prisma.SubtaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          update: {
            args: Prisma.SubtaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          deleteMany: {
            args: Prisma.SubtaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubtaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          upsert: {
            args: Prisma.SubtaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          aggregate: {
            args: Prisma.SubtaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtask>
          }
          groupBy: {
            args: Prisma.SubtaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtaskCountArgs<ExtArgs>
            result: $Utils.Optional<SubtaskCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TaskTag: {
        payload: Prisma.$TaskTagPayload<ExtArgs>
        fields: Prisma.TaskTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          findFirst: {
            args: Prisma.TaskTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          findMany: {
            args: Prisma.TaskTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
          }
          create: {
            args: Prisma.TaskTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          createMany: {
            args: Prisma.TaskTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
          }
          delete: {
            args: Prisma.TaskTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          update: {
            args: Prisma.TaskTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          deleteMany: {
            args: Prisma.TaskTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
          }
          upsert: {
            args: Prisma.TaskTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTagPayload>
          }
          aggregate: {
            args: Prisma.TaskTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskTag>
          }
          groupBy: {
            args: Prisma.TaskTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTagCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTagCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      TaskLink: {
        payload: Prisma.$TaskLinkPayload<ExtArgs>
        fields: Prisma.TaskLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>
          }
          findFirst: {
            args: Prisma.TaskLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>
          }
          findMany: {
            args: Prisma.TaskLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>[]
          }
          create: {
            args: Prisma.TaskLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>
          }
          createMany: {
            args: Prisma.TaskLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>[]
          }
          delete: {
            args: Prisma.TaskLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>
          }
          update: {
            args: Prisma.TaskLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>
          }
          deleteMany: {
            args: Prisma.TaskLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>[]
          }
          upsert: {
            args: Prisma.TaskLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLinkPayload>
          }
          aggregate: {
            args: Prisma.TaskLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskLink>
          }
          groupBy: {
            args: Prisma.TaskLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskLinkCountArgs<ExtArgs>
            result: $Utils.Optional<TaskLinkCountAggregateOutputType> | number
          }
        }
      }
      CustomField: {
        payload: Prisma.$CustomFieldPayload<ExtArgs>
        fields: Prisma.CustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findFirst: {
            args: Prisma.CustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findMany: {
            args: Prisma.CustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          create: {
            args: Prisma.CustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          createMany: {
            args: Prisma.CustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          delete: {
            args: Prisma.CustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          update: {
            args: Prisma.CustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          upsert: {
            args: Prisma.CustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          aggregate: {
            args: Prisma.CustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomField>
          }
          groupBy: {
            args: Prisma.CustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldCountAggregateOutputType> | number
          }
        }
      }
      TaskCustomValue: {
        payload: Prisma.$TaskCustomValuePayload<ExtArgs>
        fields: Prisma.TaskCustomValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCustomValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCustomValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          findFirst: {
            args: Prisma.TaskCustomValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCustomValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          findMany: {
            args: Prisma.TaskCustomValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>[]
          }
          create: {
            args: Prisma.TaskCustomValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          createMany: {
            args: Prisma.TaskCustomValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCustomValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>[]
          }
          delete: {
            args: Prisma.TaskCustomValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          update: {
            args: Prisma.TaskCustomValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          deleteMany: {
            args: Prisma.TaskCustomValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCustomValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskCustomValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>[]
          }
          upsert: {
            args: Prisma.TaskCustomValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          aggregate: {
            args: Prisma.TaskCustomValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskCustomValue>
          }
          groupBy: {
            args: Prisma.TaskCustomValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCustomValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCustomValueCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCustomValueCountAggregateOutputType> | number
          }
        }
      }
      Sprint: {
        payload: Prisma.$SprintPayload<ExtArgs>
        fields: Prisma.SprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SprintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SprintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findFirst: {
            args: Prisma.SprintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SprintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findMany: {
            args: Prisma.SprintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          create: {
            args: Prisma.SprintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          createMany: {
            args: Prisma.SprintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SprintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          delete: {
            args: Prisma.SprintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          update: {
            args: Prisma.SprintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          deleteMany: {
            args: Prisma.SprintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SprintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SprintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          upsert: {
            args: Prisma.SprintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          aggregate: {
            args: Prisma.SprintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSprint>
          }
          groupBy: {
            args: Prisma.SprintGroupByArgs<ExtArgs>
            result: $Utils.Optional<SprintGroupByOutputType>[]
          }
          count: {
            args: Prisma.SprintCountArgs<ExtArgs>
            result: $Utils.Optional<SprintCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      StickyNote: {
        payload: Prisma.$StickyNotePayload<ExtArgs>
        fields: Prisma.StickyNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StickyNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StickyNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>
          }
          findFirst: {
            args: Prisma.StickyNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StickyNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>
          }
          findMany: {
            args: Prisma.StickyNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>[]
          }
          create: {
            args: Prisma.StickyNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>
          }
          createMany: {
            args: Prisma.StickyNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StickyNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>[]
          }
          delete: {
            args: Prisma.StickyNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>
          }
          update: {
            args: Prisma.StickyNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>
          }
          deleteMany: {
            args: Prisma.StickyNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StickyNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StickyNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>[]
          }
          upsert: {
            args: Prisma.StickyNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNotePayload>
          }
          aggregate: {
            args: Prisma.StickyNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStickyNote>
          }
          groupBy: {
            args: Prisma.StickyNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<StickyNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.StickyNoteCountArgs<ExtArgs>
            result: $Utils.Optional<StickyNoteCountAggregateOutputType> | number
          }
        }
      }
      StickyNoteLink: {
        payload: Prisma.$StickyNoteLinkPayload<ExtArgs>
        fields: Prisma.StickyNoteLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StickyNoteLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StickyNoteLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>
          }
          findFirst: {
            args: Prisma.StickyNoteLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StickyNoteLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>
          }
          findMany: {
            args: Prisma.StickyNoteLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>[]
          }
          create: {
            args: Prisma.StickyNoteLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>
          }
          createMany: {
            args: Prisma.StickyNoteLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StickyNoteLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>[]
          }
          delete: {
            args: Prisma.StickyNoteLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>
          }
          update: {
            args: Prisma.StickyNoteLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>
          }
          deleteMany: {
            args: Prisma.StickyNoteLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StickyNoteLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StickyNoteLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>[]
          }
          upsert: {
            args: Prisma.StickyNoteLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StickyNoteLinkPayload>
          }
          aggregate: {
            args: Prisma.StickyNoteLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStickyNoteLink>
          }
          groupBy: {
            args: Prisma.StickyNoteLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<StickyNoteLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StickyNoteLinkCountArgs<ExtArgs>
            result: $Utils.Optional<StickyNoteLinkCountAggregateOutputType> | number
          }
        }
      }
      ProjectGroup: {
        payload: Prisma.$ProjectGroupPayload<ExtArgs>
        fields: Prisma.ProjectGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>
          }
          findFirst: {
            args: Prisma.ProjectGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>
          }
          findMany: {
            args: Prisma.ProjectGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>[]
          }
          create: {
            args: Prisma.ProjectGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>
          }
          createMany: {
            args: Prisma.ProjectGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>[]
          }
          delete: {
            args: Prisma.ProjectGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>
          }
          update: {
            args: Prisma.ProjectGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>
          }
          deleteMany: {
            args: Prisma.ProjectGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>[]
          }
          upsert: {
            args: Prisma.ProjectGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupPayload>
          }
          aggregate: {
            args: Prisma.ProjectGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectGroup>
          }
          groupBy: {
            args: Prisma.ProjectGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupCountAggregateOutputType> | number
          }
        }
      }
      ProjectGroupMember: {
        payload: Prisma.$ProjectGroupMemberPayload<ExtArgs>
        fields: Prisma.ProjectGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>
          }
          update: {
            args: Prisma.ProjectGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectGroupMember>
          }
          groupBy: {
            args: Prisma.ProjectGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      TaskSession: {
        payload: Prisma.$TaskSessionPayload<ExtArgs>
        fields: Prisma.TaskSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>
          }
          findFirst: {
            args: Prisma.TaskSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>
          }
          findMany: {
            args: Prisma.TaskSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>[]
          }
          create: {
            args: Prisma.TaskSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>
          }
          createMany: {
            args: Prisma.TaskSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>[]
          }
          delete: {
            args: Prisma.TaskSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>
          }
          update: {
            args: Prisma.TaskSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>
          }
          deleteMany: {
            args: Prisma.TaskSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>[]
          }
          upsert: {
            args: Prisma.TaskSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskSessionPayload>
          }
          aggregate: {
            args: Prisma.TaskSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskSession>
          }
          groupBy: {
            args: Prisma.TaskSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TaskSessionCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetLine: {
        payload: Prisma.$BudgetLinePayload<ExtArgs>
        fields: Prisma.BudgetLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          findFirst: {
            args: Prisma.BudgetLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          findMany: {
            args: Prisma.BudgetLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>[]
          }
          create: {
            args: Prisma.BudgetLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          createMany: {
            args: Prisma.BudgetLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>[]
          }
          delete: {
            args: Prisma.BudgetLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          update: {
            args: Prisma.BudgetLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          deleteMany: {
            args: Prisma.BudgetLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>[]
          }
          upsert: {
            args: Prisma.BudgetLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLinePayload>
          }
          aggregate: {
            args: Prisma.BudgetLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetLine>
          }
          groupBy: {
            args: Prisma.BudgetLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetLineCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetLineCountAggregateOutputType> | number
          }
        }
      }
      WikiPage: {
        payload: Prisma.$WikiPagePayload<ExtArgs>
        fields: Prisma.WikiPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WikiPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WikiPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          findFirst: {
            args: Prisma.WikiPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WikiPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          findMany: {
            args: Prisma.WikiPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          create: {
            args: Prisma.WikiPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          createMany: {
            args: Prisma.WikiPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WikiPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          delete: {
            args: Prisma.WikiPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          update: {
            args: Prisma.WikiPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          deleteMany: {
            args: Prisma.WikiPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WikiPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WikiPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          upsert: {
            args: Prisma.WikiPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          aggregate: {
            args: Prisma.WikiPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWikiPage>
          }
          groupBy: {
            args: Prisma.WikiPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WikiPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WikiPageCountArgs<ExtArgs>
            result: $Utils.Optional<WikiPageCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      LastLogin: {
        payload: Prisma.$LastLoginPayload<ExtArgs>
        fields: Prisma.LastLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LastLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LastLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>
          }
          findFirst: {
            args: Prisma.LastLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LastLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>
          }
          findMany: {
            args: Prisma.LastLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>[]
          }
          create: {
            args: Prisma.LastLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>
          }
          createMany: {
            args: Prisma.LastLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LastLoginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>[]
          }
          delete: {
            args: Prisma.LastLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>
          }
          update: {
            args: Prisma.LastLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>
          }
          deleteMany: {
            args: Prisma.LastLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LastLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LastLoginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>[]
          }
          upsert: {
            args: Prisma.LastLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastLoginPayload>
          }
          aggregate: {
            args: Prisma.LastLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLastLogin>
          }
          groupBy: {
            args: Prisma.LastLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<LastLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.LastLoginCountArgs<ExtArgs>
            result: $Utils.Optional<LastLoginCountAggregateOutputType> | number
          }
        }
      }
      UserMetadata: {
        payload: Prisma.$UserMetadataPayload<ExtArgs>
        fields: Prisma.UserMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>
          }
          findFirst: {
            args: Prisma.UserMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>
          }
          findMany: {
            args: Prisma.UserMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>[]
          }
          create: {
            args: Prisma.UserMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>
          }
          createMany: {
            args: Prisma.UserMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>[]
          }
          delete: {
            args: Prisma.UserMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>
          }
          update: {
            args: Prisma.UserMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>
          }
          deleteMany: {
            args: Prisma.UserMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>[]
          }
          upsert: {
            args: Prisma.UserMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetadataPayload>
          }
          aggregate: {
            args: Prisma.UserMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMetadata>
          }
          groupBy: {
            args: Prisma.UserMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<UserMetadataCountAggregateOutputType> | number
          }
        }
      }
      UserNotificationSetting: {
        payload: Prisma.$UserNotificationSettingPayload<ExtArgs>
        fields: Prisma.UserNotificationSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotificationSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotificationSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>
          }
          findFirst: {
            args: Prisma.UserNotificationSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotificationSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>
          }
          findMany: {
            args: Prisma.UserNotificationSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>[]
          }
          create: {
            args: Prisma.UserNotificationSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>
          }
          createMany: {
            args: Prisma.UserNotificationSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNotificationSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>[]
          }
          delete: {
            args: Prisma.UserNotificationSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>
          }
          update: {
            args: Prisma.UserNotificationSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>
          }
          deleteMany: {
            args: Prisma.UserNotificationSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotificationSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserNotificationSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>[]
          }
          upsert: {
            args: Prisma.UserNotificationSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationSettingPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotificationSetting>
          }
          groupBy: {
            args: Prisma.UserNotificationSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotificationSettingCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationSettingCountAggregateOutputType> | number
          }
        }
      }
      UserAvatar: {
        payload: Prisma.$UserAvatarPayload<ExtArgs>
        fields: Prisma.UserAvatarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAvatarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAvatarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>
          }
          findFirst: {
            args: Prisma.UserAvatarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAvatarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>
          }
          findMany: {
            args: Prisma.UserAvatarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>[]
          }
          create: {
            args: Prisma.UserAvatarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>
          }
          createMany: {
            args: Prisma.UserAvatarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAvatarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>[]
          }
          delete: {
            args: Prisma.UserAvatarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>
          }
          update: {
            args: Prisma.UserAvatarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>
          }
          deleteMany: {
            args: Prisma.UserAvatarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAvatarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAvatarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>[]
          }
          upsert: {
            args: Prisma.UserAvatarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAvatarPayload>
          }
          aggregate: {
            args: Prisma.UserAvatarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAvatar>
          }
          groupBy: {
            args: Prisma.UserAvatarGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAvatarGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAvatarCountArgs<ExtArgs>
            result: $Utils.Optional<UserAvatarCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      GroupPermission: {
        payload: Prisma.$GroupPermissionPayload<ExtArgs>
        fields: Prisma.GroupPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>
          }
          findFirst: {
            args: Prisma.GroupPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>
          }
          findMany: {
            args: Prisma.GroupPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>[]
          }
          create: {
            args: Prisma.GroupPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>
          }
          createMany: {
            args: Prisma.GroupPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>[]
          }
          delete: {
            args: Prisma.GroupPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>
          }
          update: {
            args: Prisma.GroupPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>
          }
          deleteMany: {
            args: Prisma.GroupPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>[]
          }
          upsert: {
            args: Prisma.GroupPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPermissionPayload>
          }
          aggregate: {
            args: Prisma.GroupPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupPermission>
          }
          groupBy: {
            args: Prisma.GroupPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<GroupPermissionCountAggregateOutputType> | number
          }
        }
      }
      RoleAssignment: {
        payload: Prisma.$RoleAssignmentPayload<ExtArgs>
        fields: Prisma.RoleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.RoleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          findMany: {
            args: Prisma.RoleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>[]
          }
          create: {
            args: Prisma.RoleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          createMany: {
            args: Prisma.RoleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>[]
          }
          delete: {
            args: Prisma.RoleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          update: {
            args: Prisma.RoleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.RoleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.RoleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.RoleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleAssignment>
          }
          groupBy: {
            args: Prisma.RoleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<RoleAssignmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    workspace?: WorkspaceOmit
    workspaceLogo?: WorkspaceLogoOmit
    workspaceUser?: WorkspaceUserOmit
    workspaceInvitation?: WorkspaceInvitationOmit
    user?: UserOmit
    session?: SessionOmit
    rememberToken?: RememberTokenOmit
    invite?: InviteOmit
    systemSetting?: SystemSettingOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    column?: ColumnOmit
    swimlane?: SwimlaneOmit
    task?: TaskOmit
    taskAssignee?: TaskAssigneeOmit
    subtask?: SubtaskOmit
    comment?: CommentOmit
    tag?: TagOmit
    taskTag?: TaskTagOmit
    category?: CategoryOmit
    attachment?: AttachmentOmit
    taskLink?: TaskLinkOmit
    customField?: CustomFieldOmit
    taskCustomValue?: TaskCustomValueOmit
    sprint?: SprintOmit
    module?: ModuleOmit
    milestone?: MilestoneOmit
    stickyNote?: StickyNoteOmit
    stickyNoteLink?: StickyNoteLinkOmit
    projectGroup?: ProjectGroupOmit
    projectGroupMember?: ProjectGroupMemberOmit
    taskSession?: TaskSessionOmit
    budget?: BudgetOmit
    budgetLine?: BudgetLineOmit
    wikiPage?: WikiPageOmit
    apiKey?: ApiKeyOmit
    webhook?: WebhookOmit
    webhookDelivery?: WebhookDeliveryOmit
    notification?: NotificationOmit
    activity?: ActivityOmit
    passwordReset?: PasswordResetOmit
    lastLogin?: LastLoginOmit
    userMetadata?: UserMetadataOmit
    userNotificationSetting?: UserNotificationSettingOmit
    userAvatar?: UserAvatarOmit
    group?: GroupOmit
    groupMember?: GroupMemberOmit
    permission?: PermissionOmit
    groupPermission?: GroupPermissionOmit
    roleAssignment?: RoleAssignmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    users: number
    projects: number
    projectGroups: number
    invitations: number
    groups: number
    roleAssignments: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | WorkspaceCountOutputTypeCountUsersArgs
    projects?: boolean | WorkspaceCountOutputTypeCountProjectsArgs
    projectGroups?: boolean | WorkspaceCountOutputTypeCountProjectGroupsArgs
    invitations?: boolean | WorkspaceCountOutputTypeCountInvitationsArgs
    groups?: boolean | WorkspaceCountOutputTypeCountGroupsArgs
    roleAssignments?: boolean | WorkspaceCountOutputTypeCountRoleAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountProjectGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGroupWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountRoleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    workspaces: number
    workspacesCreated: number
    invitationsCreated: number
    projectMembers: number
    tasksCreated: number
    tasksAssigned: number
    subtasksAssigned: number
    comments: number
    attachments: number
    sessions: number
    rememberTokens: number
    notifications: number
    activities: number
    apiKeys: number
    passwordResets: number
    lastLogins: number
    metadata: number
    notificationSettings: number
    invitesSent: number
    groupMemberships: number
    groupMembersAdded: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    workspacesCreated?: boolean | UserCountOutputTypeCountWorkspacesCreatedArgs
    invitationsCreated?: boolean | UserCountOutputTypeCountInvitationsCreatedArgs
    projectMembers?: boolean | UserCountOutputTypeCountProjectMembersArgs
    tasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
    tasksAssigned?: boolean | UserCountOutputTypeCountTasksAssignedArgs
    subtasksAssigned?: boolean | UserCountOutputTypeCountSubtasksAssignedArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    attachments?: boolean | UserCountOutputTypeCountAttachmentsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    rememberTokens?: boolean | UserCountOutputTypeCountRememberTokensArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
    lastLogins?: boolean | UserCountOutputTypeCountLastLoginsArgs
    metadata?: boolean | UserCountOutputTypeCountMetadataArgs
    notificationSettings?: boolean | UserCountOutputTypeCountNotificationSettingsArgs
    invitesSent?: boolean | UserCountOutputTypeCountInvitesSentArgs
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    groupMembersAdded?: boolean | UserCountOutputTypeCountGroupMembersAddedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubtasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRememberTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RememberTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLastLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastLoginWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMetadataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembersAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    columns: number
    swimlanes: number
    tasks: number
    tags: number
    categories: number
    customFields: number
    modules: number
    milestones: number
    sprints: number
    budgets: number
    wikiPages: number
    activities: number
    projectGroups: number
    webhooks: number
    groups: number
    roleAssignments: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    columns?: boolean | ProjectCountOutputTypeCountColumnsArgs
    swimlanes?: boolean | ProjectCountOutputTypeCountSwimlanesArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    tags?: boolean | ProjectCountOutputTypeCountTagsArgs
    categories?: boolean | ProjectCountOutputTypeCountCategoriesArgs
    customFields?: boolean | ProjectCountOutputTypeCountCustomFieldsArgs
    modules?: boolean | ProjectCountOutputTypeCountModulesArgs
    milestones?: boolean | ProjectCountOutputTypeCountMilestonesArgs
    sprints?: boolean | ProjectCountOutputTypeCountSprintsArgs
    budgets?: boolean | ProjectCountOutputTypeCountBudgetsArgs
    wikiPages?: boolean | ProjectCountOutputTypeCountWikiPagesArgs
    activities?: boolean | ProjectCountOutputTypeCountActivitiesArgs
    projectGroups?: boolean | ProjectCountOutputTypeCountProjectGroupsArgs
    webhooks?: boolean | ProjectCountOutputTypeCountWebhooksArgs
    groups?: boolean | ProjectCountOutputTypeCountGroupsArgs
    roleAssignments?: boolean | ProjectCountOutputTypeCountRoleAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountColumnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColumnWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSwimlanesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwimlaneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWikiPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WikiPageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGroupMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRoleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
  }


  /**
   * Count Type ColumnCountOutputType
   */

  export type ColumnCountOutputType = {
    tasks: number
  }

  export type ColumnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ColumnCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColumnCountOutputType
     */
    select?: ColumnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColumnCountOutputType without action
   */
  export type ColumnCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type SwimlaneCountOutputType
   */

  export type SwimlaneCountOutputType = {
    tasks: number
  }

  export type SwimlaneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | SwimlaneCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * SwimlaneCountOutputType without action
   */
  export type SwimlaneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SwimlaneCountOutputType
     */
    select?: SwimlaneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SwimlaneCountOutputType without action
   */
  export type SwimlaneCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    assignees: number
    subtasks: number
    comments: number
    attachments: number
    tags: number
    customValues: number
    linksFrom: number
    linksTo: number
    genxSessions: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | TaskCountOutputTypeCountAssigneesArgs
    subtasks?: boolean | TaskCountOutputTypeCountSubtasksArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    attachments?: boolean | TaskCountOutputTypeCountAttachmentsArgs
    tags?: boolean | TaskCountOutputTypeCountTagsArgs
    customValues?: boolean | TaskCountOutputTypeCountCustomValuesArgs
    linksFrom?: boolean | TaskCountOutputTypeCountLinksFromArgs
    linksTo?: boolean | TaskCountOutputTypeCountLinksToArgs
    genxSessions?: boolean | TaskCountOutputTypeCountGenxSessionsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTagWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCustomValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomValueWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountLinksFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLinkWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountLinksToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLinkWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountGenxSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskSessionWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    tasks: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TagCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTagWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    tasks: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | CategoryCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type CustomFieldCountOutputType
   */

  export type CustomFieldCountOutputType = {
    values: number
  }

  export type CustomFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | CustomFieldCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldCountOutputType
     */
    select?: CustomFieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomValueWhereInput
  }


  /**
   * Count Type SprintCountOutputType
   */

  export type SprintCountOutputType = {
    tasks: number
  }

  export type SprintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | SprintCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SprintCountOutputType
     */
    select?: SprintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    tasks: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ModuleCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type MilestoneCountOutputType
   */

  export type MilestoneCountOutputType = {
    tasks: number
  }

  export type MilestoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | MilestoneCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestoneCountOutputType
     */
    select?: MilestoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type StickyNoteCountOutputType
   */

  export type StickyNoteCountOutputType = {
    links: number
  }

  export type StickyNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    links?: boolean | StickyNoteCountOutputTypeCountLinksArgs
  }

  // Custom InputTypes
  /**
   * StickyNoteCountOutputType without action
   */
  export type StickyNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteCountOutputType
     */
    select?: StickyNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StickyNoteCountOutputType without action
   */
  export type StickyNoteCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StickyNoteLinkWhereInput
  }


  /**
   * Count Type ProjectGroupCountOutputType
   */

  export type ProjectGroupCountOutputType = {
    projects: number
  }

  export type ProjectGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectGroupCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProjectGroupCountOutputType without action
   */
  export type ProjectGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupCountOutputType
     */
    select?: ProjectGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectGroupCountOutputType without action
   */
  export type ProjectGroupCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGroupMemberWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    lines: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | BudgetCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    deliveries: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    childGroups: number
    members: number
    permissions: number
    roleAssignments: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childGroups?: boolean | GroupCountOutputTypeCountChildGroupsArgs
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    permissions?: boolean | GroupCountOutputTypeCountPermissionsArgs
    roleAssignments?: boolean | GroupCountOutputTypeCountRoleAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountChildGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupPermissionWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountRoleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    children: number
    groupPermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | PermissionCountOutputTypeCountChildrenArgs
    groupPermissions?: boolean | PermissionCountOutputTypeCountGroupPermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountGroupPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupPermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _avg: WorkspaceAvgAggregateOutputType | null
    _sum: WorkspaceSumAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type WorkspaceSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    logoUrl: number
    settings: number
    isActive: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type WorkspaceSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    settings?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _avg?: WorkspaceAvgAggregateInputType
    _sum?: WorkspaceSumAggregateInputType
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    logoUrl: string | null
    settings: JsonValue
    isActive: boolean
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _avg: WorkspaceAvgAggregateOutputType | null
    _sum: WorkspaceSumAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    settings?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Workspace$createdByArgs<ExtArgs>
    users?: boolean | Workspace$usersArgs<ExtArgs>
    projects?: boolean | Workspace$projectsArgs<ExtArgs>
    projectGroups?: boolean | Workspace$projectGroupsArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    logo?: boolean | Workspace$logoArgs<ExtArgs>
    groups?: boolean | Workspace$groupsArgs<ExtArgs>
    roleAssignments?: boolean | Workspace$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    settings?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Workspace$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    settings?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Workspace$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    settings?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "logoUrl" | "settings" | "isActive" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Workspace$createdByArgs<ExtArgs>
    users?: boolean | Workspace$usersArgs<ExtArgs>
    projects?: boolean | Workspace$projectsArgs<ExtArgs>
    projectGroups?: boolean | Workspace$projectGroupsArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    logo?: boolean | Workspace$logoArgs<ExtArgs>
    groups?: boolean | Workspace$groupsArgs<ExtArgs>
    roleAssignments?: boolean | Workspace$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Workspace$createdByArgs<ExtArgs>
  }
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Workspace$createdByArgs<ExtArgs>
  }

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      users: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      projectGroups: Prisma.$ProjectGroupPayload<ExtArgs>[]
      invitations: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      logo: Prisma.$WorkspaceLogoPayload<ExtArgs> | null
      groups: Prisma.$GroupPayload<ExtArgs>[]
      roleAssignments: Prisma.$RoleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      logoUrl: string | null
      settings: Prisma.JsonValue
      isActive: boolean
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Workspace$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Workspace$usersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Workspace$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectGroups<T extends Workspace$projectGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$projectGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Workspace$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logo<T extends Workspace$logoArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$logoArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    groups<T extends Workspace$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleAssignments<T extends Workspace$roleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$roleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'Int'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly slug: FieldRef<"Workspace", 'String'>
    readonly description: FieldRef<"Workspace", 'String'>
    readonly logoUrl: FieldRef<"Workspace", 'String'>
    readonly settings: FieldRef<"Workspace", 'Json'>
    readonly isActive: FieldRef<"Workspace", 'Boolean'>
    readonly createdById: FieldRef<"Workspace", 'Int'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.createdBy
   */
  export type Workspace$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Workspace.users
   */
  export type Workspace$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * Workspace.projects
   */
  export type Workspace$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Workspace.projectGroups
   */
  export type Workspace$projectGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    where?: ProjectGroupWhereInput
    orderBy?: ProjectGroupOrderByWithRelationInput | ProjectGroupOrderByWithRelationInput[]
    cursor?: ProjectGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectGroupScalarFieldEnum | ProjectGroupScalarFieldEnum[]
  }

  /**
   * Workspace.invitations
   */
  export type Workspace$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * Workspace.logo
   */
  export type Workspace$logoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    where?: WorkspaceLogoWhereInput
  }

  /**
   * Workspace.groups
   */
  export type Workspace$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Workspace.roleAssignments
   */
  export type Workspace$roleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    cursor?: RoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceLogo
   */

  export type AggregateWorkspaceLogo = {
    _count: WorkspaceLogoCountAggregateOutputType | null
    _avg: WorkspaceLogoAvgAggregateOutputType | null
    _sum: WorkspaceLogoSumAggregateOutputType | null
    _min: WorkspaceLogoMinAggregateOutputType | null
    _max: WorkspaceLogoMaxAggregateOutputType | null
  }

  export type WorkspaceLogoAvgAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    size: number | null
  }

  export type WorkspaceLogoSumAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    size: number | null
  }

  export type WorkspaceLogoMinAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    data: Bytes | null
    mimeType: string | null
    size: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceLogoMaxAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    data: Bytes | null
    mimeType: string | null
    size: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceLogoCountAggregateOutputType = {
    id: number
    workspaceId: number
    data: number
    mimeType: number
    size: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceLogoAvgAggregateInputType = {
    id?: true
    workspaceId?: true
    size?: true
  }

  export type WorkspaceLogoSumAggregateInputType = {
    id?: true
    workspaceId?: true
    size?: true
  }

  export type WorkspaceLogoMinAggregateInputType = {
    id?: true
    workspaceId?: true
    data?: true
    mimeType?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceLogoMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    data?: true
    mimeType?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceLogoCountAggregateInputType = {
    id?: true
    workspaceId?: true
    data?: true
    mimeType?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceLogoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceLogo to aggregate.
     */
    where?: WorkspaceLogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceLogos to fetch.
     */
    orderBy?: WorkspaceLogoOrderByWithRelationInput | WorkspaceLogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceLogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceLogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceLogos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceLogos
    **/
    _count?: true | WorkspaceLogoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceLogoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceLogoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceLogoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceLogoMaxAggregateInputType
  }

  export type GetWorkspaceLogoAggregateType<T extends WorkspaceLogoAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceLogo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceLogo[P]>
      : GetScalarType<T[P], AggregateWorkspaceLogo[P]>
  }




  export type WorkspaceLogoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceLogoWhereInput
    orderBy?: WorkspaceLogoOrderByWithAggregationInput | WorkspaceLogoOrderByWithAggregationInput[]
    by: WorkspaceLogoScalarFieldEnum[] | WorkspaceLogoScalarFieldEnum
    having?: WorkspaceLogoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceLogoCountAggregateInputType | true
    _avg?: WorkspaceLogoAvgAggregateInputType
    _sum?: WorkspaceLogoSumAggregateInputType
    _min?: WorkspaceLogoMinAggregateInputType
    _max?: WorkspaceLogoMaxAggregateInputType
  }

  export type WorkspaceLogoGroupByOutputType = {
    id: number
    workspaceId: number
    data: Bytes
    mimeType: string
    size: number
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceLogoCountAggregateOutputType | null
    _avg: WorkspaceLogoAvgAggregateOutputType | null
    _sum: WorkspaceLogoSumAggregateOutputType | null
    _min: WorkspaceLogoMinAggregateOutputType | null
    _max: WorkspaceLogoMaxAggregateOutputType | null
  }

  type GetWorkspaceLogoGroupByPayload<T extends WorkspaceLogoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceLogoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceLogoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceLogoGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceLogoGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceLogoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceLogo"]>

  export type WorkspaceLogoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceLogo"]>

  export type WorkspaceLogoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceLogo"]>

  export type WorkspaceLogoSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceLogoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "data" | "mimeType" | "size" | "createdAt" | "updatedAt", ExtArgs["result"]["workspaceLogo"]>
  export type WorkspaceLogoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceLogoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceLogoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceLogoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceLogo"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workspaceId: number
      data: Prisma.Bytes
      mimeType: string
      size: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspaceLogo"]>
    composites: {}
  }

  type WorkspaceLogoGetPayload<S extends boolean | null | undefined | WorkspaceLogoDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceLogoPayload, S>

  type WorkspaceLogoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceLogoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceLogoCountAggregateInputType | true
    }

  export interface WorkspaceLogoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceLogo'], meta: { name: 'WorkspaceLogo' } }
    /**
     * Find zero or one WorkspaceLogo that matches the filter.
     * @param {WorkspaceLogoFindUniqueArgs} args - Arguments to find a WorkspaceLogo
     * @example
     * // Get one WorkspaceLogo
     * const workspaceLogo = await prisma.workspaceLogo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceLogoFindUniqueArgs>(args: SelectSubset<T, WorkspaceLogoFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceLogo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceLogoFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceLogo
     * @example
     * // Get one WorkspaceLogo
     * const workspaceLogo = await prisma.workspaceLogo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceLogoFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceLogoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceLogo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoFindFirstArgs} args - Arguments to find a WorkspaceLogo
     * @example
     * // Get one WorkspaceLogo
     * const workspaceLogo = await prisma.workspaceLogo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceLogoFindFirstArgs>(args?: SelectSubset<T, WorkspaceLogoFindFirstArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceLogo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoFindFirstOrThrowArgs} args - Arguments to find a WorkspaceLogo
     * @example
     * // Get one WorkspaceLogo
     * const workspaceLogo = await prisma.workspaceLogo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceLogoFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceLogoFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceLogos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceLogos
     * const workspaceLogos = await prisma.workspaceLogo.findMany()
     * 
     * // Get first 10 WorkspaceLogos
     * const workspaceLogos = await prisma.workspaceLogo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceLogoWithIdOnly = await prisma.workspaceLogo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceLogoFindManyArgs>(args?: SelectSubset<T, WorkspaceLogoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceLogo.
     * @param {WorkspaceLogoCreateArgs} args - Arguments to create a WorkspaceLogo.
     * @example
     * // Create one WorkspaceLogo
     * const WorkspaceLogo = await prisma.workspaceLogo.create({
     *   data: {
     *     // ... data to create a WorkspaceLogo
     *   }
     * })
     * 
     */
    create<T extends WorkspaceLogoCreateArgs>(args: SelectSubset<T, WorkspaceLogoCreateArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceLogos.
     * @param {WorkspaceLogoCreateManyArgs} args - Arguments to create many WorkspaceLogos.
     * @example
     * // Create many WorkspaceLogos
     * const workspaceLogo = await prisma.workspaceLogo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceLogoCreateManyArgs>(args?: SelectSubset<T, WorkspaceLogoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceLogos and returns the data saved in the database.
     * @param {WorkspaceLogoCreateManyAndReturnArgs} args - Arguments to create many WorkspaceLogos.
     * @example
     * // Create many WorkspaceLogos
     * const workspaceLogo = await prisma.workspaceLogo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceLogos and only return the `id`
     * const workspaceLogoWithIdOnly = await prisma.workspaceLogo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceLogoCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceLogoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceLogo.
     * @param {WorkspaceLogoDeleteArgs} args - Arguments to delete one WorkspaceLogo.
     * @example
     * // Delete one WorkspaceLogo
     * const WorkspaceLogo = await prisma.workspaceLogo.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceLogo
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceLogoDeleteArgs>(args: SelectSubset<T, WorkspaceLogoDeleteArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceLogo.
     * @param {WorkspaceLogoUpdateArgs} args - Arguments to update one WorkspaceLogo.
     * @example
     * // Update one WorkspaceLogo
     * const workspaceLogo = await prisma.workspaceLogo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceLogoUpdateArgs>(args: SelectSubset<T, WorkspaceLogoUpdateArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceLogos.
     * @param {WorkspaceLogoDeleteManyArgs} args - Arguments to filter WorkspaceLogos to delete.
     * @example
     * // Delete a few WorkspaceLogos
     * const { count } = await prisma.workspaceLogo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceLogoDeleteManyArgs>(args?: SelectSubset<T, WorkspaceLogoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceLogos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceLogos
     * const workspaceLogo = await prisma.workspaceLogo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceLogoUpdateManyArgs>(args: SelectSubset<T, WorkspaceLogoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceLogos and returns the data updated in the database.
     * @param {WorkspaceLogoUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceLogos.
     * @example
     * // Update many WorkspaceLogos
     * const workspaceLogo = await prisma.workspaceLogo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceLogos and only return the `id`
     * const workspaceLogoWithIdOnly = await prisma.workspaceLogo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceLogoUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceLogoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceLogo.
     * @param {WorkspaceLogoUpsertArgs} args - Arguments to update or create a WorkspaceLogo.
     * @example
     * // Update or create a WorkspaceLogo
     * const workspaceLogo = await prisma.workspaceLogo.upsert({
     *   create: {
     *     // ... data to create a WorkspaceLogo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceLogo we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceLogoUpsertArgs>(args: SelectSubset<T, WorkspaceLogoUpsertArgs<ExtArgs>>): Prisma__WorkspaceLogoClient<$Result.GetResult<Prisma.$WorkspaceLogoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceLogos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoCountArgs} args - Arguments to filter WorkspaceLogos to count.
     * @example
     * // Count the number of WorkspaceLogos
     * const count = await prisma.workspaceLogo.count({
     *   where: {
     *     // ... the filter for the WorkspaceLogos we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceLogoCountArgs>(
      args?: Subset<T, WorkspaceLogoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceLogoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceLogo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceLogoAggregateArgs>(args: Subset<T, WorkspaceLogoAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceLogoAggregateType<T>>

    /**
     * Group by WorkspaceLogo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceLogoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceLogoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceLogoGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceLogoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceLogoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceLogoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceLogo model
   */
  readonly fields: WorkspaceLogoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceLogo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceLogoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceLogo model
   */
  interface WorkspaceLogoFieldRefs {
    readonly id: FieldRef<"WorkspaceLogo", 'Int'>
    readonly workspaceId: FieldRef<"WorkspaceLogo", 'Int'>
    readonly data: FieldRef<"WorkspaceLogo", 'Bytes'>
    readonly mimeType: FieldRef<"WorkspaceLogo", 'String'>
    readonly size: FieldRef<"WorkspaceLogo", 'Int'>
    readonly createdAt: FieldRef<"WorkspaceLogo", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceLogo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceLogo findUnique
   */
  export type WorkspaceLogoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceLogo to fetch.
     */
    where: WorkspaceLogoWhereUniqueInput
  }

  /**
   * WorkspaceLogo findUniqueOrThrow
   */
  export type WorkspaceLogoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceLogo to fetch.
     */
    where: WorkspaceLogoWhereUniqueInput
  }

  /**
   * WorkspaceLogo findFirst
   */
  export type WorkspaceLogoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceLogo to fetch.
     */
    where?: WorkspaceLogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceLogos to fetch.
     */
    orderBy?: WorkspaceLogoOrderByWithRelationInput | WorkspaceLogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceLogos.
     */
    cursor?: WorkspaceLogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceLogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceLogos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceLogos.
     */
    distinct?: WorkspaceLogoScalarFieldEnum | WorkspaceLogoScalarFieldEnum[]
  }

  /**
   * WorkspaceLogo findFirstOrThrow
   */
  export type WorkspaceLogoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceLogo to fetch.
     */
    where?: WorkspaceLogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceLogos to fetch.
     */
    orderBy?: WorkspaceLogoOrderByWithRelationInput | WorkspaceLogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceLogos.
     */
    cursor?: WorkspaceLogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceLogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceLogos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceLogos.
     */
    distinct?: WorkspaceLogoScalarFieldEnum | WorkspaceLogoScalarFieldEnum[]
  }

  /**
   * WorkspaceLogo findMany
   */
  export type WorkspaceLogoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceLogos to fetch.
     */
    where?: WorkspaceLogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceLogos to fetch.
     */
    orderBy?: WorkspaceLogoOrderByWithRelationInput | WorkspaceLogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceLogos.
     */
    cursor?: WorkspaceLogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceLogos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceLogos.
     */
    skip?: number
    distinct?: WorkspaceLogoScalarFieldEnum | WorkspaceLogoScalarFieldEnum[]
  }

  /**
   * WorkspaceLogo create
   */
  export type WorkspaceLogoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceLogo.
     */
    data: XOR<WorkspaceLogoCreateInput, WorkspaceLogoUncheckedCreateInput>
  }

  /**
   * WorkspaceLogo createMany
   */
  export type WorkspaceLogoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceLogos.
     */
    data: WorkspaceLogoCreateManyInput | WorkspaceLogoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceLogo createManyAndReturn
   */
  export type WorkspaceLogoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceLogos.
     */
    data: WorkspaceLogoCreateManyInput | WorkspaceLogoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceLogo update
   */
  export type WorkspaceLogoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceLogo.
     */
    data: XOR<WorkspaceLogoUpdateInput, WorkspaceLogoUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceLogo to update.
     */
    where: WorkspaceLogoWhereUniqueInput
  }

  /**
   * WorkspaceLogo updateMany
   */
  export type WorkspaceLogoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceLogos.
     */
    data: XOR<WorkspaceLogoUpdateManyMutationInput, WorkspaceLogoUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceLogos to update
     */
    where?: WorkspaceLogoWhereInput
    /**
     * Limit how many WorkspaceLogos to update.
     */
    limit?: number
  }

  /**
   * WorkspaceLogo updateManyAndReturn
   */
  export type WorkspaceLogoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceLogos.
     */
    data: XOR<WorkspaceLogoUpdateManyMutationInput, WorkspaceLogoUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceLogos to update
     */
    where?: WorkspaceLogoWhereInput
    /**
     * Limit how many WorkspaceLogos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceLogo upsert
   */
  export type WorkspaceLogoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceLogo to update in case it exists.
     */
    where: WorkspaceLogoWhereUniqueInput
    /**
     * In case the WorkspaceLogo found by the `where` argument doesn't exist, create a new WorkspaceLogo with this data.
     */
    create: XOR<WorkspaceLogoCreateInput, WorkspaceLogoUncheckedCreateInput>
    /**
     * In case the WorkspaceLogo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceLogoUpdateInput, WorkspaceLogoUncheckedUpdateInput>
  }

  /**
   * WorkspaceLogo delete
   */
  export type WorkspaceLogoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceLogo to delete.
     */
    where: WorkspaceLogoWhereUniqueInput
  }

  /**
   * WorkspaceLogo deleteMany
   */
  export type WorkspaceLogoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceLogos to delete
     */
    where?: WorkspaceLogoWhereInput
    /**
     * Limit how many WorkspaceLogos to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceLogo without action
   */
  export type WorkspaceLogoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceLogo
     */
    select?: WorkspaceLogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceLogo
     */
    omit?: WorkspaceLogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceLogoInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUser
   */

  export type AggregateWorkspaceUser = {
    _count: WorkspaceUserCountAggregateOutputType | null
    _avg: WorkspaceUserAvgAggregateOutputType | null
    _sum: WorkspaceUserSumAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  export type WorkspaceUserAvgAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    userId: number | null
  }

  export type WorkspaceUserSumAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    userId: number | null
  }

  export type WorkspaceUserMinAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    userId: number | null
    role: $Enums.WorkspaceRole | null
    joinedAt: Date | null
  }

  export type WorkspaceUserMaxAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    userId: number | null
    role: $Enums.WorkspaceRole | null
    joinedAt: Date | null
  }

  export type WorkspaceUserCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type WorkspaceUserAvgAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
  }

  export type WorkspaceUserSumAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
  }

  export type WorkspaceUserMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type WorkspaceUserMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type WorkspaceUserCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type WorkspaceUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUser to aggregate.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUsers
    **/
    _count?: true | WorkspaceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type GetWorkspaceUserAggregateType<T extends WorkspaceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUser[P]>
      : GetScalarType<T[P], AggregateWorkspaceUser[P]>
  }




  export type WorkspaceUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithAggregationInput | WorkspaceUserOrderByWithAggregationInput[]
    by: WorkspaceUserScalarFieldEnum[] | WorkspaceUserScalarFieldEnum
    having?: WorkspaceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceUserCountAggregateInputType | true
    _avg?: WorkspaceUserAvgAggregateInputType
    _sum?: WorkspaceUserSumAggregateInputType
    _min?: WorkspaceUserMinAggregateInputType
    _max?: WorkspaceUserMaxAggregateInputType
  }

  export type WorkspaceUserGroupByOutputType = {
    id: number
    workspaceId: number
    userId: number
    role: $Enums.WorkspaceRole
    joinedAt: Date
    _count: WorkspaceUserCountAggregateOutputType | null
    _avg: WorkspaceUserAvgAggregateOutputType | null
    _sum: WorkspaceUserSumAggregateOutputType | null
    _min: WorkspaceUserMinAggregateOutputType | null
    _max: WorkspaceUserMaxAggregateOutputType | null
  }

  type GetWorkspaceUserGroupByPayload<T extends WorkspaceUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUser"]>

  export type WorkspaceUserSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type WorkspaceUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["workspaceUser"]>
  export type WorkspaceUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspaceUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUser"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workspaceId: number
      userId: number
      role: $Enums.WorkspaceRole
      joinedAt: Date
    }, ExtArgs["result"]["workspaceUser"]>
    composites: {}
  }

  type WorkspaceUserGetPayload<S extends boolean | null | undefined | WorkspaceUserDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserPayload, S>

  type WorkspaceUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceUserCountAggregateInputType | true
    }

  export interface WorkspaceUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUser'], meta: { name: 'WorkspaceUser' } }
    /**
     * Find zero or one WorkspaceUser that matches the filter.
     * @param {WorkspaceUserFindUniqueArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceUserFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUser
     * @example
     * // Get one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany()
     * 
     * // Get first 10 WorkspaceUsers
     * const workspaceUsers = await prisma.workspaceUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserFindManyArgs>(args?: SelectSubset<T, WorkspaceUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceUser.
     * @param {WorkspaceUserCreateArgs} args - Arguments to create a WorkspaceUser.
     * @example
     * // Create one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.create({
     *   data: {
     *     // ... data to create a WorkspaceUser
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserCreateArgs>(args: SelectSubset<T, WorkspaceUserCreateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceUsers.
     * @param {WorkspaceUserCreateManyArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUsers and returns the data saved in the database.
     * @param {WorkspaceUserCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUsers.
     * @example
     * // Create many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceUser.
     * @param {WorkspaceUserDeleteArgs} args - Arguments to delete one WorkspaceUser.
     * @example
     * // Delete one WorkspaceUser
     * const WorkspaceUser = await prisma.workspaceUser.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUser
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserDeleteArgs>(args: SelectSubset<T, WorkspaceUserDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceUser.
     * @param {WorkspaceUserUpdateArgs} args - Arguments to update one WorkspaceUser.
     * @example
     * // Update one WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserUpdateArgs>(args: SelectSubset<T, WorkspaceUserUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceUsers.
     * @param {WorkspaceUserDeleteManyArgs} args - Arguments to filter WorkspaceUsers to delete.
     * @example
     * // Delete a few WorkspaceUsers
     * const { count } = await prisma.workspaceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUsers and returns the data updated in the database.
     * @param {WorkspaceUserUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceUsers.
     * @example
     * // Update many WorkspaceUsers
     * const workspaceUser = await prisma.workspaceUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceUsers and only return the `id`
     * const workspaceUserWithIdOnly = await prisma.workspaceUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUserUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceUser.
     * @param {WorkspaceUserUpsertArgs} args - Arguments to update or create a WorkspaceUser.
     * @example
     * // Update or create a WorkspaceUser
     * const workspaceUser = await prisma.workspaceUser.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUser we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserUpsertArgs>(args: SelectSubset<T, WorkspaceUserUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserClient<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserCountArgs} args - Arguments to filter WorkspaceUsers to count.
     * @example
     * // Count the number of WorkspaceUsers
     * const count = await prisma.workspaceUser.count({
     *   where: {
     *     // ... the filter for the WorkspaceUsers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserCountArgs>(
      args?: Subset<T, WorkspaceUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserAggregateArgs>(args: Subset<T, WorkspaceUserAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserAggregateType<T>>

    /**
     * Group by WorkspaceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUser model
   */
  readonly fields: WorkspaceUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUser model
   */
  interface WorkspaceUserFieldRefs {
    readonly id: FieldRef<"WorkspaceUser", 'Int'>
    readonly workspaceId: FieldRef<"WorkspaceUser", 'Int'>
    readonly userId: FieldRef<"WorkspaceUser", 'Int'>
    readonly role: FieldRef<"WorkspaceUser", 'WorkspaceRole'>
    readonly joinedAt: FieldRef<"WorkspaceUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUser findUnique
   */
  export type WorkspaceUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findUniqueOrThrow
   */
  export type WorkspaceUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser findFirst
   */
  export type WorkspaceUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findFirstOrThrow
   */
  export type WorkspaceUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUser to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUsers.
     */
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser findMany
   */
  export type WorkspaceUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUsers to fetch.
     */
    where?: WorkspaceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUsers to fetch.
     */
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUsers.
     */
    cursor?: WorkspaceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUsers.
     */
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * WorkspaceUser create
   */
  export type WorkspaceUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUser.
     */
    data: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
  }

  /**
   * WorkspaceUser createMany
   */
  export type WorkspaceUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceUser createManyAndReturn
   */
  export type WorkspaceUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUsers.
     */
    data: WorkspaceUserCreateManyInput | WorkspaceUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser update
   */
  export type WorkspaceUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUser.
     */
    data: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUser to update.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser updateMany
   */
  export type WorkspaceUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to update.
     */
    limit?: number
  }

  /**
   * WorkspaceUser updateManyAndReturn
   */
  export type WorkspaceUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceUsers.
     */
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUsers to update
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUser upsert
   */
  export type WorkspaceUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUser to update in case it exists.
     */
    where: WorkspaceUserWhereUniqueInput
    /**
     * In case the WorkspaceUser found by the `where` argument doesn't exist, create a new WorkspaceUser with this data.
     */
    create: XOR<WorkspaceUserCreateInput, WorkspaceUserUncheckedCreateInput>
    /**
     * In case the WorkspaceUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserUpdateInput, WorkspaceUserUncheckedUpdateInput>
  }

  /**
   * WorkspaceUser delete
   */
  export type WorkspaceUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUser to delete.
     */
    where: WorkspaceUserWhereUniqueInput
  }

  /**
   * WorkspaceUser deleteMany
   */
  export type WorkspaceUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUsers to delete
     */
    where?: WorkspaceUserWhereInput
    /**
     * Limit how many WorkspaceUsers to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceUser without action
   */
  export type WorkspaceUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceInvitation
   */

  export type AggregateWorkspaceInvitation = {
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _avg: WorkspaceInvitationAvgAggregateOutputType | null
    _sum: WorkspaceInvitationSumAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  export type WorkspaceInvitationAvgAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    createdBy: number | null
  }

  export type WorkspaceInvitationSumAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    createdBy: number | null
  }

  export type WorkspaceInvitationMinAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    email: string | null
    role: $Enums.WorkspaceRole | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type WorkspaceInvitationMaxAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    email: string | null
    role: $Enums.WorkspaceRole | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    createdBy: number | null
  }

  export type WorkspaceInvitationCountAggregateOutputType = {
    id: number
    workspaceId: number
    email: number
    role: number
    token: number
    expiresAt: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type WorkspaceInvitationAvgAggregateInputType = {
    id?: true
    workspaceId?: true
    createdBy?: true
  }

  export type WorkspaceInvitationSumAggregateInputType = {
    id?: true
    workspaceId?: true
    createdBy?: true
  }

  export type WorkspaceInvitationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    createdBy?: true
  }

  export type WorkspaceInvitationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    createdBy?: true
  }

  export type WorkspaceInvitationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    role?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type WorkspaceInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitation to aggregate.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceInvitations
    **/
    _count?: true | WorkspaceInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type GetWorkspaceInvitationAggregateType<T extends WorkspaceInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
      : GetScalarType<T[P], AggregateWorkspaceInvitation[P]>
  }




  export type WorkspaceInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithAggregationInput | WorkspaceInvitationOrderByWithAggregationInput[]
    by: WorkspaceInvitationScalarFieldEnum[] | WorkspaceInvitationScalarFieldEnum
    having?: WorkspaceInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceInvitationCountAggregateInputType | true
    _avg?: WorkspaceInvitationAvgAggregateInputType
    _sum?: WorkspaceInvitationSumAggregateInputType
    _min?: WorkspaceInvitationMinAggregateInputType
    _max?: WorkspaceInvitationMaxAggregateInputType
  }

  export type WorkspaceInvitationGroupByOutputType = {
    id: number
    workspaceId: number
    email: string
    role: $Enums.WorkspaceRole
    token: string
    expiresAt: Date
    createdAt: Date
    createdBy: number
    _count: WorkspaceInvitationCountAggregateOutputType | null
    _avg: WorkspaceInvitationAvgAggregateOutputType | null
    _sum: WorkspaceInvitationSumAggregateOutputType | null
    _min: WorkspaceInvitationMinAggregateOutputType | null
    _max: WorkspaceInvitationMaxAggregateOutputType | null
  }

  type GetWorkspaceInvitationGroupByPayload<T extends WorkspaceInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceInvitationGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceInvitation"]>

  export type WorkspaceInvitationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type WorkspaceInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "email" | "role" | "token" | "expiresAt" | "createdAt" | "createdBy", ExtArgs["result"]["workspaceInvitation"]>
  export type WorkspaceInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspaceInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceInvitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workspaceId: number
      email: string
      role: $Enums.WorkspaceRole
      token: string
      expiresAt: Date
      createdAt: Date
      createdBy: number
    }, ExtArgs["result"]["workspaceInvitation"]>
    composites: {}
  }

  type WorkspaceInvitationGetPayload<S extends boolean | null | undefined | WorkspaceInvitationDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceInvitationPayload, S>

  type WorkspaceInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceInvitationCountAggregateInputType | true
    }

  export interface WorkspaceInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceInvitation'], meta: { name: 'WorkspaceInvitation' } }
    /**
     * Find zero or one WorkspaceInvitation that matches the filter.
     * @param {WorkspaceInvitationFindUniqueArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceInvitationFindUniqueArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceInvitationFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceInvitationFindFirstArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindFirstOrThrowArgs} args - Arguments to find a WorkspaceInvitation
     * @example
     * // Get one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany()
     * 
     * // Get first 10 WorkspaceInvitations
     * const workspaceInvitations = await prisma.workspaceInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceInvitationFindManyArgs>(args?: SelectSubset<T, WorkspaceInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceInvitation.
     * @param {WorkspaceInvitationCreateArgs} args - Arguments to create a WorkspaceInvitation.
     * @example
     * // Create one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.create({
     *   data: {
     *     // ... data to create a WorkspaceInvitation
     *   }
     * })
     * 
     */
    create<T extends WorkspaceInvitationCreateArgs>(args: SelectSubset<T, WorkspaceInvitationCreateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceInvitations.
     * @param {WorkspaceInvitationCreateManyArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceInvitationCreateManyArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceInvitations and returns the data saved in the database.
     * @param {WorkspaceInvitationCreateManyAndReturnArgs} args - Arguments to create many WorkspaceInvitations.
     * @example
     * // Create many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceInvitation.
     * @param {WorkspaceInvitationDeleteArgs} args - Arguments to delete one WorkspaceInvitation.
     * @example
     * // Delete one WorkspaceInvitation
     * const WorkspaceInvitation = await prisma.workspaceInvitation.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceInvitation
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceInvitationDeleteArgs>(args: SelectSubset<T, WorkspaceInvitationDeleteArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpdateArgs} args - Arguments to update one WorkspaceInvitation.
     * @example
     * // Update one WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceInvitationUpdateArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceInvitations.
     * @param {WorkspaceInvitationDeleteManyArgs} args - Arguments to filter WorkspaceInvitations to delete.
     * @example
     * // Delete a few WorkspaceInvitations
     * const { count } = await prisma.workspaceInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceInvitationDeleteManyArgs>(args?: SelectSubset<T, WorkspaceInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceInvitationUpdateManyArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceInvitations and returns the data updated in the database.
     * @param {WorkspaceInvitationUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceInvitations.
     * @example
     * // Update many WorkspaceInvitations
     * const workspaceInvitation = await prisma.workspaceInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceInvitations and only return the `id`
     * const workspaceInvitationWithIdOnly = await prisma.workspaceInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceInvitation.
     * @param {WorkspaceInvitationUpsertArgs} args - Arguments to update or create a WorkspaceInvitation.
     * @example
     * // Update or create a WorkspaceInvitation
     * const workspaceInvitation = await prisma.workspaceInvitation.upsert({
     *   create: {
     *     // ... data to create a WorkspaceInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceInvitation we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceInvitationUpsertArgs>(args: SelectSubset<T, WorkspaceInvitationUpsertArgs<ExtArgs>>): Prisma__WorkspaceInvitationClient<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationCountArgs} args - Arguments to filter WorkspaceInvitations to count.
     * @example
     * // Count the number of WorkspaceInvitations
     * const count = await prisma.workspaceInvitation.count({
     *   where: {
     *     // ... the filter for the WorkspaceInvitations we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceInvitationCountArgs>(
      args?: Subset<T, WorkspaceInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceInvitationAggregateArgs>(args: Subset<T, WorkspaceInvitationAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceInvitationAggregateType<T>>

    /**
     * Group by WorkspaceInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceInvitationGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceInvitation model
   */
  readonly fields: WorkspaceInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceInvitation model
   */
  interface WorkspaceInvitationFieldRefs {
    readonly id: FieldRef<"WorkspaceInvitation", 'Int'>
    readonly workspaceId: FieldRef<"WorkspaceInvitation", 'Int'>
    readonly email: FieldRef<"WorkspaceInvitation", 'String'>
    readonly role: FieldRef<"WorkspaceInvitation", 'WorkspaceRole'>
    readonly token: FieldRef<"WorkspaceInvitation", 'String'>
    readonly expiresAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"WorkspaceInvitation", 'DateTime'>
    readonly createdBy: FieldRef<"WorkspaceInvitation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceInvitation findUnique
   */
  export type WorkspaceInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findUniqueOrThrow
   */
  export type WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation findFirst
   */
  export type WorkspaceInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findFirstOrThrow
   */
  export type WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitation to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceInvitations.
     */
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation findMany
   */
  export type WorkspaceInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceInvitations to fetch.
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceInvitations to fetch.
     */
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceInvitations.
     */
    cursor?: WorkspaceInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceInvitations.
     */
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * WorkspaceInvitation create
   */
  export type WorkspaceInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
  }

  /**
   * WorkspaceInvitation createMany
   */
  export type WorkspaceInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceInvitation createManyAndReturn
   */
  export type WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceInvitations.
     */
    data: WorkspaceInvitationCreateManyInput | WorkspaceInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation update
   */
  export type WorkspaceInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceInvitation.
     */
    data: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceInvitation to update.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation updateMany
   */
  export type WorkspaceInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to update.
     */
    limit?: number
  }

  /**
   * WorkspaceInvitation updateManyAndReturn
   */
  export type WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceInvitations.
     */
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceInvitations to update
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceInvitation upsert
   */
  export type WorkspaceInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceInvitation to update in case it exists.
     */
    where: WorkspaceInvitationWhereUniqueInput
    /**
     * In case the WorkspaceInvitation found by the `where` argument doesn't exist, create a new WorkspaceInvitation with this data.
     */
    create: XOR<WorkspaceInvitationCreateInput, WorkspaceInvitationUncheckedCreateInput>
    /**
     * In case the WorkspaceInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceInvitationUpdateInput, WorkspaceInvitationUncheckedUpdateInput>
  }

  /**
   * WorkspaceInvitation delete
   */
  export type WorkspaceInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceInvitation to delete.
     */
    where: WorkspaceInvitationWhereUniqueInput
  }

  /**
   * WorkspaceInvitation deleteMany
   */
  export type WorkspaceInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceInvitations to delete
     */
    where?: WorkspaceInvitationWhereInput
    /**
     * Limit how many WorkspaceInvitations to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceInvitation without action
   */
  export type WorkspaceInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    failedLoginCount: number | null
    lockoutCount: number | null
    gitlabId: number | null
    hourlyRate: Decimal | null
    notificationFilter: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    failedLoginCount: number | null
    lockoutCount: number | null
    gitlabId: number | null
    hourlyRate: Decimal | null
    notificationFilter: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    name: string | null
    passwordHash: string | null
    avatarUrl: string | null
    timezone: string | null
    language: string | null
    isActive: boolean | null
    emailVerified: boolean | null
    role: $Enums.AppRole | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twofactorActivated: boolean | null
    twofactorSecret: string | null
    failedLoginCount: number | null
    lockedUntil: Date | null
    lockoutCount: number | null
    googleId: string | null
    githubId: string | null
    gitlabId: number | null
    theme: string | null
    defaultFilter: string | null
    publicToken: string | null
    hourlyRate: Decimal | null
    notificationsEnabled: boolean | null
    notificationFilter: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    name: string | null
    passwordHash: string | null
    avatarUrl: string | null
    timezone: string | null
    language: string | null
    isActive: boolean | null
    emailVerified: boolean | null
    role: $Enums.AppRole | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    twofactorActivated: boolean | null
    twofactorSecret: string | null
    failedLoginCount: number | null
    lockedUntil: Date | null
    lockoutCount: number | null
    googleId: string | null
    githubId: string | null
    gitlabId: number | null
    theme: string | null
    defaultFilter: string | null
    publicToken: string | null
    hourlyRate: Decimal | null
    notificationsEnabled: boolean | null
    notificationFilter: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    name: number
    passwordHash: number
    avatarUrl: number
    timezone: number
    language: number
    settings: number
    isActive: number
    emailVerified: number
    role: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    twofactorActivated: number
    twofactorSecret: number
    failedLoginCount: number
    lockedUntil: number
    lockoutCount: number
    googleId: number
    githubId: number
    gitlabId: number
    theme: number
    defaultFilter: number
    publicToken: number
    hourlyRate: number
    notificationsEnabled: number
    notificationFilter: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    failedLoginCount?: true
    lockoutCount?: true
    gitlabId?: true
    hourlyRate?: true
    notificationFilter?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    failedLoginCount?: true
    lockoutCount?: true
    gitlabId?: true
    hourlyRate?: true
    notificationFilter?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    passwordHash?: true
    avatarUrl?: true
    timezone?: true
    language?: true
    isActive?: true
    emailVerified?: true
    role?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twofactorActivated?: true
    twofactorSecret?: true
    failedLoginCount?: true
    lockedUntil?: true
    lockoutCount?: true
    googleId?: true
    githubId?: true
    gitlabId?: true
    theme?: true
    defaultFilter?: true
    publicToken?: true
    hourlyRate?: true
    notificationsEnabled?: true
    notificationFilter?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    passwordHash?: true
    avatarUrl?: true
    timezone?: true
    language?: true
    isActive?: true
    emailVerified?: true
    role?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twofactorActivated?: true
    twofactorSecret?: true
    failedLoginCount?: true
    lockedUntil?: true
    lockoutCount?: true
    googleId?: true
    githubId?: true
    gitlabId?: true
    theme?: true
    defaultFilter?: true
    publicToken?: true
    hourlyRate?: true
    notificationsEnabled?: true
    notificationFilter?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    passwordHash?: true
    avatarUrl?: true
    timezone?: true
    language?: true
    settings?: true
    isActive?: true
    emailVerified?: true
    role?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    twofactorActivated?: true
    twofactorSecret?: true
    failedLoginCount?: true
    lockedUntil?: true
    lockoutCount?: true
    googleId?: true
    githubId?: true
    gitlabId?: true
    theme?: true
    defaultFilter?: true
    publicToken?: true
    hourlyRate?: true
    notificationsEnabled?: true
    notificationFilter?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    username: string
    name: string
    passwordHash: string | null
    avatarUrl: string | null
    timezone: string
    language: string
    settings: JsonValue
    isActive: boolean
    emailVerified: boolean
    role: $Enums.AppRole
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    twofactorActivated: boolean
    twofactorSecret: string | null
    failedLoginCount: number
    lockedUntil: Date | null
    lockoutCount: number
    googleId: string | null
    githubId: string | null
    gitlabId: number | null
    theme: string
    defaultFilter: string | null
    publicToken: string | null
    hourlyRate: Decimal | null
    notificationsEnabled: boolean
    notificationFilter: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    passwordHash?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    language?: boolean
    settings?: boolean
    isActive?: boolean
    emailVerified?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twofactorActivated?: boolean
    twofactorSecret?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    lockoutCount?: boolean
    googleId?: boolean
    githubId?: boolean
    gitlabId?: boolean
    theme?: boolean
    defaultFilter?: boolean
    publicToken?: boolean
    hourlyRate?: boolean
    notificationsEnabled?: boolean
    notificationFilter?: boolean
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    workspacesCreated?: boolean | User$workspacesCreatedArgs<ExtArgs>
    invitationsCreated?: boolean | User$invitationsCreatedArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    subtasksAssigned?: boolean | User$subtasksAssignedArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    attachments?: boolean | User$attachmentsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    rememberTokens?: boolean | User$rememberTokensArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    lastLogins?: boolean | User$lastLoginsArgs<ExtArgs>
    metadata?: boolean | User$metadataArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    avatar?: boolean | User$avatarArgs<ExtArgs>
    invitesSent?: boolean | User$invitesSentArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    groupMembersAdded?: boolean | User$groupMembersAddedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    passwordHash?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    language?: boolean
    settings?: boolean
    isActive?: boolean
    emailVerified?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twofactorActivated?: boolean
    twofactorSecret?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    lockoutCount?: boolean
    googleId?: boolean
    githubId?: boolean
    gitlabId?: boolean
    theme?: boolean
    defaultFilter?: boolean
    publicToken?: boolean
    hourlyRate?: boolean
    notificationsEnabled?: boolean
    notificationFilter?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    passwordHash?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    language?: boolean
    settings?: boolean
    isActive?: boolean
    emailVerified?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twofactorActivated?: boolean
    twofactorSecret?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    lockoutCount?: boolean
    googleId?: boolean
    githubId?: boolean
    gitlabId?: boolean
    theme?: boolean
    defaultFilter?: boolean
    publicToken?: boolean
    hourlyRate?: boolean
    notificationsEnabled?: boolean
    notificationFilter?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    passwordHash?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    language?: boolean
    settings?: boolean
    isActive?: boolean
    emailVerified?: boolean
    role?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twofactorActivated?: boolean
    twofactorSecret?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    lockoutCount?: boolean
    googleId?: boolean
    githubId?: boolean
    gitlabId?: boolean
    theme?: boolean
    defaultFilter?: boolean
    publicToken?: boolean
    hourlyRate?: boolean
    notificationsEnabled?: boolean
    notificationFilter?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "name" | "passwordHash" | "avatarUrl" | "timezone" | "language" | "settings" | "isActive" | "emailVerified" | "role" | "lastLoginAt" | "createdAt" | "updatedAt" | "twofactorActivated" | "twofactorSecret" | "failedLoginCount" | "lockedUntil" | "lockoutCount" | "googleId" | "githubId" | "gitlabId" | "theme" | "defaultFilter" | "publicToken" | "hourlyRate" | "notificationsEnabled" | "notificationFilter", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    workspacesCreated?: boolean | User$workspacesCreatedArgs<ExtArgs>
    invitationsCreated?: boolean | User$invitationsCreatedArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    subtasksAssigned?: boolean | User$subtasksAssignedArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    attachments?: boolean | User$attachmentsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    rememberTokens?: boolean | User$rememberTokensArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    lastLogins?: boolean | User$lastLoginsArgs<ExtArgs>
    metadata?: boolean | User$metadataArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    avatar?: boolean | User$avatarArgs<ExtArgs>
    invitesSent?: boolean | User$invitesSentArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    groupMembersAdded?: boolean | User$groupMembersAddedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      workspaces: Prisma.$WorkspaceUserPayload<ExtArgs>[]
      workspacesCreated: Prisma.$WorkspacePayload<ExtArgs>[]
      invitationsCreated: Prisma.$WorkspaceInvitationPayload<ExtArgs>[]
      projectMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
      tasksCreated: Prisma.$TaskPayload<ExtArgs>[]
      tasksAssigned: Prisma.$TaskAssigneePayload<ExtArgs>[]
      subtasksAssigned: Prisma.$SubtaskPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      rememberTokens: Prisma.$RememberTokenPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      passwordResets: Prisma.$PasswordResetPayload<ExtArgs>[]
      lastLogins: Prisma.$LastLoginPayload<ExtArgs>[]
      metadata: Prisma.$UserMetadataPayload<ExtArgs>[]
      notificationSettings: Prisma.$UserNotificationSettingPayload<ExtArgs>[]
      avatar: Prisma.$UserAvatarPayload<ExtArgs> | null
      invitesSent: Prisma.$InvitePayload<ExtArgs>[]
      groupMemberships: Prisma.$GroupMemberPayload<ExtArgs>[]
      groupMembersAdded: Prisma.$GroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      username: string
      name: string
      passwordHash: string | null
      avatarUrl: string | null
      timezone: string
      language: string
      settings: Prisma.JsonValue
      isActive: boolean
      emailVerified: boolean
      role: $Enums.AppRole
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      twofactorActivated: boolean
      twofactorSecret: string | null
      failedLoginCount: number
      lockedUntil: Date | null
      lockoutCount: number
      googleId: string | null
      githubId: string | null
      gitlabId: number | null
      theme: string
      defaultFilter: string | null
      publicToken: string | null
      hourlyRate: Prisma.Decimal | null
      notificationsEnabled: boolean
      notificationFilter: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspacesCreated<T extends User$workspacesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitationsCreated<T extends User$invitationsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMembers<T extends User$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksCreated<T extends User$tasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksAssigned<T extends User$tasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subtasksAssigned<T extends User$subtasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$subtasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends User$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rememberTokens<T extends User$rememberTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$rememberTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lastLogins<T extends User$lastLoginsArgs<ExtArgs> = {}>(args?: Subset<T, User$lastLoginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metadata<T extends User$metadataArgs<ExtArgs> = {}>(args?: Subset<T, User$metadataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationSettings<T extends User$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    avatar<T extends User$avatarArgs<ExtArgs> = {}>(args?: Subset<T, User$avatarArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invitesSent<T extends User$invitesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMembersAdded<T extends User$groupMembersAddedArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembersAddedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly language: FieldRef<"User", 'String'>
    readonly settings: FieldRef<"User", 'Json'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'AppRole'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twofactorActivated: FieldRef<"User", 'Boolean'>
    readonly twofactorSecret: FieldRef<"User", 'String'>
    readonly failedLoginCount: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly lockoutCount: FieldRef<"User", 'Int'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly githubId: FieldRef<"User", 'String'>
    readonly gitlabId: FieldRef<"User", 'Int'>
    readonly theme: FieldRef<"User", 'String'>
    readonly defaultFilter: FieldRef<"User", 'String'>
    readonly publicToken: FieldRef<"User", 'String'>
    readonly hourlyRate: FieldRef<"User", 'Decimal'>
    readonly notificationsEnabled: FieldRef<"User", 'Boolean'>
    readonly notificationFilter: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUser
     */
    select?: WorkspaceUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUser
     */
    omit?: WorkspaceUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserInclude<ExtArgs> | null
    where?: WorkspaceUserWhereInput
    orderBy?: WorkspaceUserOrderByWithRelationInput | WorkspaceUserOrderByWithRelationInput[]
    cursor?: WorkspaceUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserScalarFieldEnum | WorkspaceUserScalarFieldEnum[]
  }

  /**
   * User.workspacesCreated
   */
  export type User$workspacesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    cursor?: WorkspaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * User.invitationsCreated
   */
  export type User$invitationsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceInvitation
     */
    select?: WorkspaceInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceInvitation
     */
    omit?: WorkspaceInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInvitationInclude<ExtArgs> | null
    where?: WorkspaceInvitationWhereInput
    orderBy?: WorkspaceInvitationOrderByWithRelationInput | WorkspaceInvitationOrderByWithRelationInput[]
    cursor?: WorkspaceInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceInvitationScalarFieldEnum | WorkspaceInvitationScalarFieldEnum[]
  }

  /**
   * User.projectMembers
   */
  export type User$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.tasksCreated
   */
  export type User$tasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.tasksAssigned
   */
  export type User$tasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * User.subtasksAssigned
   */
  export type User$subtasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.attachments
   */
  export type User$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.rememberTokens
   */
  export type User$rememberTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    where?: RememberTokenWhereInput
    orderBy?: RememberTokenOrderByWithRelationInput | RememberTokenOrderByWithRelationInput[]
    cursor?: RememberTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RememberTokenScalarFieldEnum | RememberTokenScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    cursor?: PasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * User.lastLogins
   */
  export type User$lastLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    where?: LastLoginWhereInput
    orderBy?: LastLoginOrderByWithRelationInput | LastLoginOrderByWithRelationInput[]
    cursor?: LastLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastLoginScalarFieldEnum | LastLoginScalarFieldEnum[]
  }

  /**
   * User.metadata
   */
  export type User$metadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    where?: UserMetadataWhereInput
    orderBy?: UserMetadataOrderByWithRelationInput | UserMetadataOrderByWithRelationInput[]
    cursor?: UserMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMetadataScalarFieldEnum | UserMetadataScalarFieldEnum[]
  }

  /**
   * User.notificationSettings
   */
  export type User$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    where?: UserNotificationSettingWhereInput
    orderBy?: UserNotificationSettingOrderByWithRelationInput | UserNotificationSettingOrderByWithRelationInput[]
    cursor?: UserNotificationSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNotificationSettingScalarFieldEnum | UserNotificationSettingScalarFieldEnum[]
  }

  /**
   * User.avatar
   */
  export type User$avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    where?: UserAvatarWhereInput
  }

  /**
   * User.invitesSent
   */
  export type User$invitesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.groupMembersAdded
   */
  export type User$groupMembersAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    data: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    data?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: number
    data: JsonValue
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    data?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "data" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      data: Prisma.JsonValue
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly data: FieldRef<"Session", 'Json'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model RememberToken
   */

  export type AggregateRememberToken = {
    _count: RememberTokenCountAggregateOutputType | null
    _avg: RememberTokenAvgAggregateOutputType | null
    _sum: RememberTokenSumAggregateOutputType | null
    _min: RememberTokenMinAggregateOutputType | null
    _max: RememberTokenMaxAggregateOutputType | null
  }

  export type RememberTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RememberTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RememberTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RememberTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RememberTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RememberTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RememberTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RememberTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RememberTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RememberTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RememberTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RememberToken to aggregate.
     */
    where?: RememberTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RememberTokens to fetch.
     */
    orderBy?: RememberTokenOrderByWithRelationInput | RememberTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RememberTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RememberTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RememberTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RememberTokens
    **/
    _count?: true | RememberTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RememberTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RememberTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RememberTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RememberTokenMaxAggregateInputType
  }

  export type GetRememberTokenAggregateType<T extends RememberTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRememberToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRememberToken[P]>
      : GetScalarType<T[P], AggregateRememberToken[P]>
  }




  export type RememberTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RememberTokenWhereInput
    orderBy?: RememberTokenOrderByWithAggregationInput | RememberTokenOrderByWithAggregationInput[]
    by: RememberTokenScalarFieldEnum[] | RememberTokenScalarFieldEnum
    having?: RememberTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RememberTokenCountAggregateInputType | true
    _avg?: RememberTokenAvgAggregateInputType
    _sum?: RememberTokenSumAggregateInputType
    _min?: RememberTokenMinAggregateInputType
    _max?: RememberTokenMaxAggregateInputType
  }

  export type RememberTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    createdAt: Date
    _count: RememberTokenCountAggregateOutputType | null
    _avg: RememberTokenAvgAggregateOutputType | null
    _sum: RememberTokenSumAggregateOutputType | null
    _min: RememberTokenMinAggregateOutputType | null
    _max: RememberTokenMaxAggregateOutputType | null
  }

  type GetRememberTokenGroupByPayload<T extends RememberTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RememberTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RememberTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RememberTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RememberTokenGroupByOutputType[P]>
        }
      >
    >


  export type RememberTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rememberToken"]>

  export type RememberTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rememberToken"]>

  export type RememberTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rememberToken"]>

  export type RememberTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RememberTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt", ExtArgs["result"]["rememberToken"]>
  export type RememberTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RememberTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RememberTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RememberTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RememberToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["rememberToken"]>
    composites: {}
  }

  type RememberTokenGetPayload<S extends boolean | null | undefined | RememberTokenDefaultArgs> = $Result.GetResult<Prisma.$RememberTokenPayload, S>

  type RememberTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RememberTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RememberTokenCountAggregateInputType | true
    }

  export interface RememberTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RememberToken'], meta: { name: 'RememberToken' } }
    /**
     * Find zero or one RememberToken that matches the filter.
     * @param {RememberTokenFindUniqueArgs} args - Arguments to find a RememberToken
     * @example
     * // Get one RememberToken
     * const rememberToken = await prisma.rememberToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RememberTokenFindUniqueArgs>(args: SelectSubset<T, RememberTokenFindUniqueArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RememberToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RememberTokenFindUniqueOrThrowArgs} args - Arguments to find a RememberToken
     * @example
     * // Get one RememberToken
     * const rememberToken = await prisma.rememberToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RememberTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RememberTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RememberToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenFindFirstArgs} args - Arguments to find a RememberToken
     * @example
     * // Get one RememberToken
     * const rememberToken = await prisma.rememberToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RememberTokenFindFirstArgs>(args?: SelectSubset<T, RememberTokenFindFirstArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RememberToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenFindFirstOrThrowArgs} args - Arguments to find a RememberToken
     * @example
     * // Get one RememberToken
     * const rememberToken = await prisma.rememberToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RememberTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RememberTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RememberTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RememberTokens
     * const rememberTokens = await prisma.rememberToken.findMany()
     * 
     * // Get first 10 RememberTokens
     * const rememberTokens = await prisma.rememberToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rememberTokenWithIdOnly = await prisma.rememberToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RememberTokenFindManyArgs>(args?: SelectSubset<T, RememberTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RememberToken.
     * @param {RememberTokenCreateArgs} args - Arguments to create a RememberToken.
     * @example
     * // Create one RememberToken
     * const RememberToken = await prisma.rememberToken.create({
     *   data: {
     *     // ... data to create a RememberToken
     *   }
     * })
     * 
     */
    create<T extends RememberTokenCreateArgs>(args: SelectSubset<T, RememberTokenCreateArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RememberTokens.
     * @param {RememberTokenCreateManyArgs} args - Arguments to create many RememberTokens.
     * @example
     * // Create many RememberTokens
     * const rememberToken = await prisma.rememberToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RememberTokenCreateManyArgs>(args?: SelectSubset<T, RememberTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RememberTokens and returns the data saved in the database.
     * @param {RememberTokenCreateManyAndReturnArgs} args - Arguments to create many RememberTokens.
     * @example
     * // Create many RememberTokens
     * const rememberToken = await prisma.rememberToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RememberTokens and only return the `id`
     * const rememberTokenWithIdOnly = await prisma.rememberToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RememberTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RememberTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RememberToken.
     * @param {RememberTokenDeleteArgs} args - Arguments to delete one RememberToken.
     * @example
     * // Delete one RememberToken
     * const RememberToken = await prisma.rememberToken.delete({
     *   where: {
     *     // ... filter to delete one RememberToken
     *   }
     * })
     * 
     */
    delete<T extends RememberTokenDeleteArgs>(args: SelectSubset<T, RememberTokenDeleteArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RememberToken.
     * @param {RememberTokenUpdateArgs} args - Arguments to update one RememberToken.
     * @example
     * // Update one RememberToken
     * const rememberToken = await prisma.rememberToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RememberTokenUpdateArgs>(args: SelectSubset<T, RememberTokenUpdateArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RememberTokens.
     * @param {RememberTokenDeleteManyArgs} args - Arguments to filter RememberTokens to delete.
     * @example
     * // Delete a few RememberTokens
     * const { count } = await prisma.rememberToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RememberTokenDeleteManyArgs>(args?: SelectSubset<T, RememberTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RememberTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RememberTokens
     * const rememberToken = await prisma.rememberToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RememberTokenUpdateManyArgs>(args: SelectSubset<T, RememberTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RememberTokens and returns the data updated in the database.
     * @param {RememberTokenUpdateManyAndReturnArgs} args - Arguments to update many RememberTokens.
     * @example
     * // Update many RememberTokens
     * const rememberToken = await prisma.rememberToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RememberTokens and only return the `id`
     * const rememberTokenWithIdOnly = await prisma.rememberToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RememberTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RememberTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RememberToken.
     * @param {RememberTokenUpsertArgs} args - Arguments to update or create a RememberToken.
     * @example
     * // Update or create a RememberToken
     * const rememberToken = await prisma.rememberToken.upsert({
     *   create: {
     *     // ... data to create a RememberToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RememberToken we want to update
     *   }
     * })
     */
    upsert<T extends RememberTokenUpsertArgs>(args: SelectSubset<T, RememberTokenUpsertArgs<ExtArgs>>): Prisma__RememberTokenClient<$Result.GetResult<Prisma.$RememberTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RememberTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenCountArgs} args - Arguments to filter RememberTokens to count.
     * @example
     * // Count the number of RememberTokens
     * const count = await prisma.rememberToken.count({
     *   where: {
     *     // ... the filter for the RememberTokens we want to count
     *   }
     * })
    **/
    count<T extends RememberTokenCountArgs>(
      args?: Subset<T, RememberTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RememberTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RememberToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RememberTokenAggregateArgs>(args: Subset<T, RememberTokenAggregateArgs>): Prisma.PrismaPromise<GetRememberTokenAggregateType<T>>

    /**
     * Group by RememberToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RememberTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RememberTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RememberTokenGroupByArgs['orderBy'] }
        : { orderBy?: RememberTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RememberTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRememberTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RememberToken model
   */
  readonly fields: RememberTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RememberToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RememberTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RememberToken model
   */
  interface RememberTokenFieldRefs {
    readonly id: FieldRef<"RememberToken", 'Int'>
    readonly userId: FieldRef<"RememberToken", 'Int'>
    readonly token: FieldRef<"RememberToken", 'String'>
    readonly expiresAt: FieldRef<"RememberToken", 'DateTime'>
    readonly createdAt: FieldRef<"RememberToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RememberToken findUnique
   */
  export type RememberTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * Filter, which RememberToken to fetch.
     */
    where: RememberTokenWhereUniqueInput
  }

  /**
   * RememberToken findUniqueOrThrow
   */
  export type RememberTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * Filter, which RememberToken to fetch.
     */
    where: RememberTokenWhereUniqueInput
  }

  /**
   * RememberToken findFirst
   */
  export type RememberTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * Filter, which RememberToken to fetch.
     */
    where?: RememberTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RememberTokens to fetch.
     */
    orderBy?: RememberTokenOrderByWithRelationInput | RememberTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RememberTokens.
     */
    cursor?: RememberTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RememberTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RememberTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RememberTokens.
     */
    distinct?: RememberTokenScalarFieldEnum | RememberTokenScalarFieldEnum[]
  }

  /**
   * RememberToken findFirstOrThrow
   */
  export type RememberTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * Filter, which RememberToken to fetch.
     */
    where?: RememberTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RememberTokens to fetch.
     */
    orderBy?: RememberTokenOrderByWithRelationInput | RememberTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RememberTokens.
     */
    cursor?: RememberTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RememberTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RememberTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RememberTokens.
     */
    distinct?: RememberTokenScalarFieldEnum | RememberTokenScalarFieldEnum[]
  }

  /**
   * RememberToken findMany
   */
  export type RememberTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * Filter, which RememberTokens to fetch.
     */
    where?: RememberTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RememberTokens to fetch.
     */
    orderBy?: RememberTokenOrderByWithRelationInput | RememberTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RememberTokens.
     */
    cursor?: RememberTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RememberTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RememberTokens.
     */
    skip?: number
    distinct?: RememberTokenScalarFieldEnum | RememberTokenScalarFieldEnum[]
  }

  /**
   * RememberToken create
   */
  export type RememberTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RememberToken.
     */
    data: XOR<RememberTokenCreateInput, RememberTokenUncheckedCreateInput>
  }

  /**
   * RememberToken createMany
   */
  export type RememberTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RememberTokens.
     */
    data: RememberTokenCreateManyInput | RememberTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RememberToken createManyAndReturn
   */
  export type RememberTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RememberTokens.
     */
    data: RememberTokenCreateManyInput | RememberTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RememberToken update
   */
  export type RememberTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RememberToken.
     */
    data: XOR<RememberTokenUpdateInput, RememberTokenUncheckedUpdateInput>
    /**
     * Choose, which RememberToken to update.
     */
    where: RememberTokenWhereUniqueInput
  }

  /**
   * RememberToken updateMany
   */
  export type RememberTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RememberTokens.
     */
    data: XOR<RememberTokenUpdateManyMutationInput, RememberTokenUncheckedUpdateManyInput>
    /**
     * Filter which RememberTokens to update
     */
    where?: RememberTokenWhereInput
    /**
     * Limit how many RememberTokens to update.
     */
    limit?: number
  }

  /**
   * RememberToken updateManyAndReturn
   */
  export type RememberTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * The data used to update RememberTokens.
     */
    data: XOR<RememberTokenUpdateManyMutationInput, RememberTokenUncheckedUpdateManyInput>
    /**
     * Filter which RememberTokens to update
     */
    where?: RememberTokenWhereInput
    /**
     * Limit how many RememberTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RememberToken upsert
   */
  export type RememberTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RememberToken to update in case it exists.
     */
    where: RememberTokenWhereUniqueInput
    /**
     * In case the RememberToken found by the `where` argument doesn't exist, create a new RememberToken with this data.
     */
    create: XOR<RememberTokenCreateInput, RememberTokenUncheckedCreateInput>
    /**
     * In case the RememberToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RememberTokenUpdateInput, RememberTokenUncheckedUpdateInput>
  }

  /**
   * RememberToken delete
   */
  export type RememberTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
    /**
     * Filter which RememberToken to delete.
     */
    where: RememberTokenWhereUniqueInput
  }

  /**
   * RememberToken deleteMany
   */
  export type RememberTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RememberTokens to delete
     */
    where?: RememberTokenWhereInput
    /**
     * Limit how many RememberTokens to delete.
     */
    limit?: number
  }

  /**
   * RememberToken without action
   */
  export type RememberTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RememberToken
     */
    select?: RememberTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RememberToken
     */
    omit?: RememberTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RememberTokenInclude<ExtArgs> | null
  }


  /**
   * Model Invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _avg: InviteAvgAggregateOutputType | null
    _sum: InviteSumAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteAvgAggregateOutputType = {
    id: number | null
    invitedById: number | null
  }

  export type InviteSumAggregateOutputType = {
    id: number | null
    invitedById: number | null
  }

  export type InviteMinAggregateOutputType = {
    id: number | null
    email: string | null
    token: string | null
    role: $Enums.AppRole | null
    invitedById: number | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type InviteMaxAggregateOutputType = {
    id: number | null
    email: string | null
    token: string | null
    role: $Enums.AppRole | null
    invitedById: number | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    email: number
    token: number
    role: number
    invitedById: number
    expiresAt: number
    acceptedAt: number
    createdAt: number
    _all: number
  }


  export type InviteAvgAggregateInputType = {
    id?: true
    invitedById?: true
  }

  export type InviteSumAggregateInputType = {
    id?: true
    invitedById?: true
  }

  export type InviteMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    role?: true
    invitedById?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    role?: true
    invitedById?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    role?: true
    invitedById?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invite to aggregate.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type InviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithAggregationInput | InviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: InviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _avg?: InviteAvgAggregateInputType
    _sum?: InviteSumAggregateInputType
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: number
    email: string
    token: string
    role: $Enums.AppRole
    invitedById: number
    expiresAt: Date
    acceptedAt: Date | null
    createdAt: Date
    _count: InviteCountAggregateOutputType | null
    _avg: InviteAvgAggregateOutputType | null
    _sum: InviteSumAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends InviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type InviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    role?: boolean
    invitedById?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    role?: boolean
    invitedById?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    role?: boolean
    invitedById?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    role?: boolean
    invitedById?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
  }

  export type InviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "role" | "invitedById" | "expiresAt" | "acceptedAt" | "createdAt", ExtArgs["result"]["invite"]>
  export type InviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invite"
    objects: {
      invitedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      token: string
      role: $Enums.AppRole
      invitedById: number
      expiresAt: Date
      acceptedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type InviteGetPayload<S extends boolean | null | undefined | InviteDefaultArgs> = $Result.GetResult<Prisma.$InvitePayload, S>

  type InviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface InviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invite'], meta: { name: 'Invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {InviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteFindUniqueArgs>(args: SelectSubset<T, InviteFindUniqueArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteFindFirstArgs>(args?: SelectSubset<T, InviteFindFirstArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteFindManyArgs>(args?: SelectSubset<T, InviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invite.
     * @param {InviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends InviteCreateArgs>(args: SelectSubset<T, InviteCreateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invites.
     * @param {InviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCreateManyArgs>(args?: SelectSubset<T, InviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invites and returns the data saved in the database.
     * @param {InviteCreateManyAndReturnArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invite.
     * @param {InviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends InviteDeleteArgs>(args: SelectSubset<T, InviteDeleteArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invite.
     * @param {InviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteUpdateArgs>(args: SelectSubset<T, InviteUpdateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invites.
     * @param {InviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteDeleteManyArgs>(args?: SelectSubset<T, InviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteUpdateManyArgs>(args: SelectSubset<T, InviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites and returns the data updated in the database.
     * @param {InviteUpdateManyAndReturnArgs} args - Arguments to update many Invites.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InviteUpdateManyAndReturnArgs>(args: SelectSubset<T, InviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invite.
     * @param {InviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends InviteUpsertArgs>(args: SelectSubset<T, InviteUpsertArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends InviteCountArgs>(
      args?: Subset<T, InviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteGroupByArgs['orderBy'] }
        : { orderBy?: InviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invite model
   */
  readonly fields: InviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invite model
   */
  interface InviteFieldRefs {
    readonly id: FieldRef<"Invite", 'Int'>
    readonly email: FieldRef<"Invite", 'String'>
    readonly token: FieldRef<"Invite", 'String'>
    readonly role: FieldRef<"Invite", 'AppRole'>
    readonly invitedById: FieldRef<"Invite", 'Int'>
    readonly expiresAt: FieldRef<"Invite", 'DateTime'>
    readonly acceptedAt: FieldRef<"Invite", 'DateTime'>
    readonly createdAt: FieldRef<"Invite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invite findUnique
   */
  export type InviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findUniqueOrThrow
   */
  export type InviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findFirst
   */
  export type InviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findFirstOrThrow
   */
  export type InviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findMany
   */
  export type InviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invites to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite create
   */
  export type InviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to create a Invite.
     */
    data: XOR<InviteCreateInput, InviteUncheckedCreateInput>
  }

  /**
   * Invite createMany
   */
  export type InviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invite createManyAndReturn
   */
  export type InviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invite update
   */
  export type InviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to update a Invite.
     */
    data: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
    /**
     * Choose, which Invite to update.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite updateMany
   */
  export type InviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to update.
     */
    limit?: number
  }

  /**
   * Invite updateManyAndReturn
   */
  export type InviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invite upsert
   */
  export type InviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The filter to search for the Invite to update in case it exists.
     */
    where: InviteWhereUniqueInput
    /**
     * In case the Invite found by the `where` argument doesn't exist, create a new Invite with this data.
     */
    create: XOR<InviteCreateInput, InviteUncheckedCreateInput>
    /**
     * In case the Invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
  }

  /**
   * Invite delete
   */
  export type InviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter which Invite to delete.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite deleteMany
   */
  export type InviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invites to delete
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to delete.
     */
    limit?: number
  }

  /**
   * Invite without action
   */
  export type InviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingAvgAggregateOutputType = {
    changedBy: number | null
  }

  export type SystemSettingSumAggregateOutputType = {
    changedBy: number | null
  }

  export type SystemSettingMinAggregateOutputType = {
    key: string | null
    value: string | null
    changedBy: number | null
    changedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    key: string | null
    value: string | null
    changedBy: number | null
    changedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    key: number
    value: number
    changedBy: number
    changedAt: number
    _all: number
  }


  export type SystemSettingAvgAggregateInputType = {
    changedBy?: true
  }

  export type SystemSettingSumAggregateInputType = {
    changedBy?: true
  }

  export type SystemSettingMinAggregateInputType = {
    key?: true
    value?: true
    changedBy?: true
    changedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    key?: true
    value?: true
    changedBy?: true
    changedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    key?: true
    value?: true
    changedBy?: true
    changedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _avg?: SystemSettingAvgAggregateInputType
    _sum?: SystemSettingSumAggregateInputType
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    key: string
    value: string | null
    changedBy: number | null
    changedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    changedBy?: boolean
    changedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    changedBy?: boolean
    changedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    changedBy?: boolean
    changedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    key?: boolean
    value?: boolean
    changedBy?: boolean
    changedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "changedBy" | "changedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string | null
      changedBy: number | null
      changedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const systemSettingWithKeyOnly = await prisma.systemSetting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `key`
     * const systemSettingWithKeyOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `key`
     * const systemSettingWithKeyOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly changedBy: FieldRef<"SystemSetting", 'Int'>
    readonly changedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    workspaceId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    workspaceId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    name: string | null
    identifier: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isPublic: boolean | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    name: string | null
    identifier: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isPublic: boolean | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    identifier: number
    description: number
    startDate: number
    endDate: number
    isActive: number
    isPublic: number
    settings: number
    lastActivityAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    workspaceId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    workspaceId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    identifier?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isPublic?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    identifier?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isPublic?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    identifier?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isPublic?: true
    settings?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    workspaceId: number
    name: string
    identifier: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean
    isPublic: boolean
    settings: JsonValue
    lastActivityAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    identifier?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isPublic?: boolean
    settings?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    columns?: boolean | Project$columnsArgs<ExtArgs>
    swimlanes?: boolean | Project$swimlanesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    tags?: boolean | Project$tagsArgs<ExtArgs>
    categories?: boolean | Project$categoriesArgs<ExtArgs>
    customFields?: boolean | Project$customFieldsArgs<ExtArgs>
    modules?: boolean | Project$modulesArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    sprints?: boolean | Project$sprintsArgs<ExtArgs>
    budgets?: boolean | Project$budgetsArgs<ExtArgs>
    wikiPages?: boolean | Project$wikiPagesArgs<ExtArgs>
    activities?: boolean | Project$activitiesArgs<ExtArgs>
    projectGroups?: boolean | Project$projectGroupsArgs<ExtArgs>
    webhooks?: boolean | Project$webhooksArgs<ExtArgs>
    groups?: boolean | Project$groupsArgs<ExtArgs>
    roleAssignments?: boolean | Project$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    identifier?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isPublic?: boolean
    settings?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    identifier?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isPublic?: boolean
    settings?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    identifier?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isPublic?: boolean
    settings?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "identifier" | "description" | "startDate" | "endDate" | "isActive" | "isPublic" | "settings" | "lastActivityAt" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    columns?: boolean | Project$columnsArgs<ExtArgs>
    swimlanes?: boolean | Project$swimlanesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    tags?: boolean | Project$tagsArgs<ExtArgs>
    categories?: boolean | Project$categoriesArgs<ExtArgs>
    customFields?: boolean | Project$customFieldsArgs<ExtArgs>
    modules?: boolean | Project$modulesArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    sprints?: boolean | Project$sprintsArgs<ExtArgs>
    budgets?: boolean | Project$budgetsArgs<ExtArgs>
    wikiPages?: boolean | Project$wikiPagesArgs<ExtArgs>
    activities?: boolean | Project$activitiesArgs<ExtArgs>
    projectGroups?: boolean | Project$projectGroupsArgs<ExtArgs>
    webhooks?: boolean | Project$webhooksArgs<ExtArgs>
    groups?: boolean | Project$groupsArgs<ExtArgs>
    roleAssignments?: boolean | Project$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      columns: Prisma.$ColumnPayload<ExtArgs>[]
      swimlanes: Prisma.$SwimlanePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      customFields: Prisma.$CustomFieldPayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      sprints: Prisma.$SprintPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      wikiPages: Prisma.$WikiPagePayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      projectGroups: Prisma.$ProjectGroupMemberPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
      roleAssignments: Prisma.$RoleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workspaceId: number
      name: string
      identifier: string | null
      description: string | null
      startDate: Date | null
      endDate: Date | null
      isActive: boolean
      isPublic: boolean
      settings: Prisma.JsonValue
      lastActivityAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    columns<T extends Project$columnsArgs<ExtArgs> = {}>(args?: Subset<T, Project$columnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    swimlanes<T extends Project$swimlanesArgs<ExtArgs> = {}>(args?: Subset<T, Project$swimlanesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Project$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Project$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Project$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customFields<T extends Project$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Project$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modules<T extends Project$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Project$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Project$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Project$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sprints<T extends Project$sprintsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sprintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgets<T extends Project$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Project$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wikiPages<T extends Project$wikiPagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$wikiPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Project$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Project$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectGroups<T extends Project$projectGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    webhooks<T extends Project$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Project$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Project$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Project$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleAssignments<T extends Project$roleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$roleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly workspaceId: FieldRef<"Project", 'Int'>
    readonly name: FieldRef<"Project", 'String'>
    readonly identifier: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly isActive: FieldRef<"Project", 'Boolean'>
    readonly isPublic: FieldRef<"Project", 'Boolean'>
    readonly settings: FieldRef<"Project", 'Json'>
    readonly lastActivityAt: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.columns
   */
  export type Project$columnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    where?: ColumnWhereInput
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    cursor?: ColumnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Project.swimlanes
   */
  export type Project$swimlanesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    where?: SwimlaneWhereInput
    orderBy?: SwimlaneOrderByWithRelationInput | SwimlaneOrderByWithRelationInput[]
    cursor?: SwimlaneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SwimlaneScalarFieldEnum | SwimlaneScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.tags
   */
  export type Project$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Project.categories
   */
  export type Project$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Project.customFields
   */
  export type Project$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    cursor?: CustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * Project.modules
   */
  export type Project$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Project.milestones
   */
  export type Project$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Project.sprints
   */
  export type Project$sprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    cursor?: SprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Project.budgets
   */
  export type Project$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Project.wikiPages
   */
  export type Project$wikiPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    where?: WikiPageWhereInput
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    cursor?: WikiPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * Project.activities
   */
  export type Project$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Project.projectGroups
   */
  export type Project$projectGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    where?: ProjectGroupMemberWhereInput
    orderBy?: ProjectGroupMemberOrderByWithRelationInput | ProjectGroupMemberOrderByWithRelationInput[]
    cursor?: ProjectGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectGroupMemberScalarFieldEnum | ProjectGroupMemberScalarFieldEnum[]
  }

  /**
   * Project.webhooks
   */
  export type Project$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Project.groups
   */
  export type Project$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Project.roleAssignments
   */
  export type Project$roleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    cursor?: RoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectMemberSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: $Enums.ProjectRole | null
    joinedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: $Enums.ProjectRole | null
    joinedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ProjectMemberAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _avg?: ProjectMemberAvgAggregateInputType
    _sum?: ProjectMemberSumAggregateInputType
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    role: $Enums.ProjectRole
    joinedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      role: $Enums.ProjectRole
      joinedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'Int'>
    readonly projectId: FieldRef<"ProjectMember", 'Int'>
    readonly userId: FieldRef<"ProjectMember", 'Int'>
    readonly role: FieldRef<"ProjectMember", 'ProjectRole'>
    readonly joinedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model Column
   */

  export type AggregateColumn = {
    _count: ColumnCountAggregateOutputType | null
    _avg: ColumnAvgAggregateOutputType | null
    _sum: ColumnSumAggregateOutputType | null
    _min: ColumnMinAggregateOutputType | null
    _max: ColumnMaxAggregateOutputType | null
  }

  export type ColumnAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
    taskLimit: number | null
  }

  export type ColumnSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
    taskLimit: number | null
  }

  export type ColumnMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    title: string | null
    description: string | null
    position: number | null
    taskLimit: number | null
    isCollapsed: boolean | null
    showClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColumnMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    title: string | null
    description: string | null
    position: number | null
    taskLimit: number | null
    isCollapsed: boolean | null
    showClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColumnCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    position: number
    taskLimit: number
    isCollapsed: number
    showClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ColumnAvgAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
    taskLimit?: true
  }

  export type ColumnSumAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
    taskLimit?: true
  }

  export type ColumnMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    position?: true
    taskLimit?: true
    isCollapsed?: true
    showClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColumnMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    position?: true
    taskLimit?: true
    isCollapsed?: true
    showClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColumnCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    position?: true
    taskLimit?: true
    isCollapsed?: true
    showClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ColumnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Column to aggregate.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Columns
    **/
    _count?: true | ColumnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColumnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColumnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColumnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColumnMaxAggregateInputType
  }

  export type GetColumnAggregateType<T extends ColumnAggregateArgs> = {
        [P in keyof T & keyof AggregateColumn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColumn[P]>
      : GetScalarType<T[P], AggregateColumn[P]>
  }




  export type ColumnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColumnWhereInput
    orderBy?: ColumnOrderByWithAggregationInput | ColumnOrderByWithAggregationInput[]
    by: ColumnScalarFieldEnum[] | ColumnScalarFieldEnum
    having?: ColumnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColumnCountAggregateInputType | true
    _avg?: ColumnAvgAggregateInputType
    _sum?: ColumnSumAggregateInputType
    _min?: ColumnMinAggregateInputType
    _max?: ColumnMaxAggregateInputType
  }

  export type ColumnGroupByOutputType = {
    id: number
    projectId: number
    title: string
    description: string | null
    position: number
    taskLimit: number
    isCollapsed: boolean
    showClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: ColumnCountAggregateOutputType | null
    _avg: ColumnAvgAggregateOutputType | null
    _sum: ColumnSumAggregateOutputType | null
    _min: ColumnMinAggregateOutputType | null
    _max: ColumnMaxAggregateOutputType | null
  }

  type GetColumnGroupByPayload<T extends ColumnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColumnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColumnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColumnGroupByOutputType[P]>
            : GetScalarType<T[P], ColumnGroupByOutputType[P]>
        }
      >
    >


  export type ColumnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    taskLimit?: boolean
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Column$tasksArgs<ExtArgs>
    _count?: boolean | ColumnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    taskLimit?: boolean
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    taskLimit?: boolean
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["column"]>

  export type ColumnSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    position?: boolean
    taskLimit?: boolean
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ColumnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "description" | "position" | "taskLimit" | "isCollapsed" | "showClosed" | "createdAt" | "updatedAt", ExtArgs["result"]["column"]>
  export type ColumnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Column$tasksArgs<ExtArgs>
    _count?: boolean | ColumnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColumnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ColumnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ColumnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Column"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      title: string
      description: string | null
      position: number
      taskLimit: number
      isCollapsed: boolean
      showClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["column"]>
    composites: {}
  }

  type ColumnGetPayload<S extends boolean | null | undefined | ColumnDefaultArgs> = $Result.GetResult<Prisma.$ColumnPayload, S>

  type ColumnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColumnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColumnCountAggregateInputType | true
    }

  export interface ColumnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Column'], meta: { name: 'Column' } }
    /**
     * Find zero or one Column that matches the filter.
     * @param {ColumnFindUniqueArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColumnFindUniqueArgs>(args: SelectSubset<T, ColumnFindUniqueArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Column that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColumnFindUniqueOrThrowArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColumnFindUniqueOrThrowArgs>(args: SelectSubset<T, ColumnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Column that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindFirstArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColumnFindFirstArgs>(args?: SelectSubset<T, ColumnFindFirstArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Column that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindFirstOrThrowArgs} args - Arguments to find a Column
     * @example
     * // Get one Column
     * const column = await prisma.column.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColumnFindFirstOrThrowArgs>(args?: SelectSubset<T, ColumnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Columns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Columns
     * const columns = await prisma.column.findMany()
     * 
     * // Get first 10 Columns
     * const columns = await prisma.column.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const columnWithIdOnly = await prisma.column.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColumnFindManyArgs>(args?: SelectSubset<T, ColumnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Column.
     * @param {ColumnCreateArgs} args - Arguments to create a Column.
     * @example
     * // Create one Column
     * const Column = await prisma.column.create({
     *   data: {
     *     // ... data to create a Column
     *   }
     * })
     * 
     */
    create<T extends ColumnCreateArgs>(args: SelectSubset<T, ColumnCreateArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Columns.
     * @param {ColumnCreateManyArgs} args - Arguments to create many Columns.
     * @example
     * // Create many Columns
     * const column = await prisma.column.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColumnCreateManyArgs>(args?: SelectSubset<T, ColumnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Columns and returns the data saved in the database.
     * @param {ColumnCreateManyAndReturnArgs} args - Arguments to create many Columns.
     * @example
     * // Create many Columns
     * const column = await prisma.column.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Columns and only return the `id`
     * const columnWithIdOnly = await prisma.column.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColumnCreateManyAndReturnArgs>(args?: SelectSubset<T, ColumnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Column.
     * @param {ColumnDeleteArgs} args - Arguments to delete one Column.
     * @example
     * // Delete one Column
     * const Column = await prisma.column.delete({
     *   where: {
     *     // ... filter to delete one Column
     *   }
     * })
     * 
     */
    delete<T extends ColumnDeleteArgs>(args: SelectSubset<T, ColumnDeleteArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Column.
     * @param {ColumnUpdateArgs} args - Arguments to update one Column.
     * @example
     * // Update one Column
     * const column = await prisma.column.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColumnUpdateArgs>(args: SelectSubset<T, ColumnUpdateArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Columns.
     * @param {ColumnDeleteManyArgs} args - Arguments to filter Columns to delete.
     * @example
     * // Delete a few Columns
     * const { count } = await prisma.column.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColumnDeleteManyArgs>(args?: SelectSubset<T, ColumnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Columns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Columns
     * const column = await prisma.column.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColumnUpdateManyArgs>(args: SelectSubset<T, ColumnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Columns and returns the data updated in the database.
     * @param {ColumnUpdateManyAndReturnArgs} args - Arguments to update many Columns.
     * @example
     * // Update many Columns
     * const column = await prisma.column.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Columns and only return the `id`
     * const columnWithIdOnly = await prisma.column.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColumnUpdateManyAndReturnArgs>(args: SelectSubset<T, ColumnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Column.
     * @param {ColumnUpsertArgs} args - Arguments to update or create a Column.
     * @example
     * // Update or create a Column
     * const column = await prisma.column.upsert({
     *   create: {
     *     // ... data to create a Column
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Column we want to update
     *   }
     * })
     */
    upsert<T extends ColumnUpsertArgs>(args: SelectSubset<T, ColumnUpsertArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Columns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnCountArgs} args - Arguments to filter Columns to count.
     * @example
     * // Count the number of Columns
     * const count = await prisma.column.count({
     *   where: {
     *     // ... the filter for the Columns we want to count
     *   }
     * })
    **/
    count<T extends ColumnCountArgs>(
      args?: Subset<T, ColumnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColumnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Column.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColumnAggregateArgs>(args: Subset<T, ColumnAggregateArgs>): Prisma.PrismaPromise<GetColumnAggregateType<T>>

    /**
     * Group by Column.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColumnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColumnGroupByArgs['orderBy'] }
        : { orderBy?: ColumnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColumnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColumnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Column model
   */
  readonly fields: ColumnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Column.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColumnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Column$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Column$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Column model
   */
  interface ColumnFieldRefs {
    readonly id: FieldRef<"Column", 'Int'>
    readonly projectId: FieldRef<"Column", 'Int'>
    readonly title: FieldRef<"Column", 'String'>
    readonly description: FieldRef<"Column", 'String'>
    readonly position: FieldRef<"Column", 'Int'>
    readonly taskLimit: FieldRef<"Column", 'Int'>
    readonly isCollapsed: FieldRef<"Column", 'Boolean'>
    readonly showClosed: FieldRef<"Column", 'Boolean'>
    readonly createdAt: FieldRef<"Column", 'DateTime'>
    readonly updatedAt: FieldRef<"Column", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Column findUnique
   */
  export type ColumnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column findUniqueOrThrow
   */
  export type ColumnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column findFirst
   */
  export type ColumnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Columns.
     */
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column findFirstOrThrow
   */
  export type ColumnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Column to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Columns.
     */
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column findMany
   */
  export type ColumnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter, which Columns to fetch.
     */
    where?: ColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Columns to fetch.
     */
    orderBy?: ColumnOrderByWithRelationInput | ColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Columns.
     */
    cursor?: ColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Columns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Columns.
     */
    skip?: number
    distinct?: ColumnScalarFieldEnum | ColumnScalarFieldEnum[]
  }

  /**
   * Column create
   */
  export type ColumnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The data needed to create a Column.
     */
    data: XOR<ColumnCreateInput, ColumnUncheckedCreateInput>
  }

  /**
   * Column createMany
   */
  export type ColumnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Columns.
     */
    data: ColumnCreateManyInput | ColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Column createManyAndReturn
   */
  export type ColumnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * The data used to create many Columns.
     */
    data: ColumnCreateManyInput | ColumnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Column update
   */
  export type ColumnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The data needed to update a Column.
     */
    data: XOR<ColumnUpdateInput, ColumnUncheckedUpdateInput>
    /**
     * Choose, which Column to update.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column updateMany
   */
  export type ColumnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Columns.
     */
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyInput>
    /**
     * Filter which Columns to update
     */
    where?: ColumnWhereInput
    /**
     * Limit how many Columns to update.
     */
    limit?: number
  }

  /**
   * Column updateManyAndReturn
   */
  export type ColumnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * The data used to update Columns.
     */
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyInput>
    /**
     * Filter which Columns to update
     */
    where?: ColumnWhereInput
    /**
     * Limit how many Columns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Column upsert
   */
  export type ColumnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * The filter to search for the Column to update in case it exists.
     */
    where: ColumnWhereUniqueInput
    /**
     * In case the Column found by the `where` argument doesn't exist, create a new Column with this data.
     */
    create: XOR<ColumnCreateInput, ColumnUncheckedCreateInput>
    /**
     * In case the Column was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColumnUpdateInput, ColumnUncheckedUpdateInput>
  }

  /**
   * Column delete
   */
  export type ColumnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
    /**
     * Filter which Column to delete.
     */
    where: ColumnWhereUniqueInput
  }

  /**
   * Column deleteMany
   */
  export type ColumnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Columns to delete
     */
    where?: ColumnWhereInput
    /**
     * Limit how many Columns to delete.
     */
    limit?: number
  }

  /**
   * Column.tasks
   */
  export type Column$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Column without action
   */
  export type ColumnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Column
     */
    select?: ColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Column
     */
    omit?: ColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnInclude<ExtArgs> | null
  }


  /**
   * Model Swimlane
   */

  export type AggregateSwimlane = {
    _count: SwimlaneCountAggregateOutputType | null
    _avg: SwimlaneAvgAggregateOutputType | null
    _sum: SwimlaneSumAggregateOutputType | null
    _min: SwimlaneMinAggregateOutputType | null
    _max: SwimlaneMaxAggregateOutputType | null
  }

  export type SwimlaneAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
  }

  export type SwimlaneSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
  }

  export type SwimlaneMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    position: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwimlaneMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    position: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SwimlaneCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    position: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SwimlaneAvgAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
  }

  export type SwimlaneSumAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
  }

  export type SwimlaneMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    position?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwimlaneMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    position?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SwimlaneCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    position?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SwimlaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Swimlane to aggregate.
     */
    where?: SwimlaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Swimlanes to fetch.
     */
    orderBy?: SwimlaneOrderByWithRelationInput | SwimlaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SwimlaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Swimlanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Swimlanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Swimlanes
    **/
    _count?: true | SwimlaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SwimlaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SwimlaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SwimlaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SwimlaneMaxAggregateInputType
  }

  export type GetSwimlaneAggregateType<T extends SwimlaneAggregateArgs> = {
        [P in keyof T & keyof AggregateSwimlane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSwimlane[P]>
      : GetScalarType<T[P], AggregateSwimlane[P]>
  }




  export type SwimlaneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SwimlaneWhereInput
    orderBy?: SwimlaneOrderByWithAggregationInput | SwimlaneOrderByWithAggregationInput[]
    by: SwimlaneScalarFieldEnum[] | SwimlaneScalarFieldEnum
    having?: SwimlaneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SwimlaneCountAggregateInputType | true
    _avg?: SwimlaneAvgAggregateInputType
    _sum?: SwimlaneSumAggregateInputType
    _min?: SwimlaneMinAggregateInputType
    _max?: SwimlaneMaxAggregateInputType
  }

  export type SwimlaneGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    position: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SwimlaneCountAggregateOutputType | null
    _avg: SwimlaneAvgAggregateOutputType | null
    _sum: SwimlaneSumAggregateOutputType | null
    _min: SwimlaneMinAggregateOutputType | null
    _max: SwimlaneMaxAggregateOutputType | null
  }

  type GetSwimlaneGroupByPayload<T extends SwimlaneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SwimlaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SwimlaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SwimlaneGroupByOutputType[P]>
            : GetScalarType<T[P], SwimlaneGroupByOutputType[P]>
        }
      >
    >


  export type SwimlaneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Swimlane$tasksArgs<ExtArgs>
    _count?: boolean | SwimlaneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["swimlane"]>

  export type SwimlaneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["swimlane"]>

  export type SwimlaneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["swimlane"]>

  export type SwimlaneSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SwimlaneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "position" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["swimlane"]>
  export type SwimlaneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Swimlane$tasksArgs<ExtArgs>
    _count?: boolean | SwimlaneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SwimlaneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SwimlaneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SwimlanePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Swimlane"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      position: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["swimlane"]>
    composites: {}
  }

  type SwimlaneGetPayload<S extends boolean | null | undefined | SwimlaneDefaultArgs> = $Result.GetResult<Prisma.$SwimlanePayload, S>

  type SwimlaneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SwimlaneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SwimlaneCountAggregateInputType | true
    }

  export interface SwimlaneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Swimlane'], meta: { name: 'Swimlane' } }
    /**
     * Find zero or one Swimlane that matches the filter.
     * @param {SwimlaneFindUniqueArgs} args - Arguments to find a Swimlane
     * @example
     * // Get one Swimlane
     * const swimlane = await prisma.swimlane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SwimlaneFindUniqueArgs>(args: SelectSubset<T, SwimlaneFindUniqueArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Swimlane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SwimlaneFindUniqueOrThrowArgs} args - Arguments to find a Swimlane
     * @example
     * // Get one Swimlane
     * const swimlane = await prisma.swimlane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SwimlaneFindUniqueOrThrowArgs>(args: SelectSubset<T, SwimlaneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Swimlane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneFindFirstArgs} args - Arguments to find a Swimlane
     * @example
     * // Get one Swimlane
     * const swimlane = await prisma.swimlane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SwimlaneFindFirstArgs>(args?: SelectSubset<T, SwimlaneFindFirstArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Swimlane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneFindFirstOrThrowArgs} args - Arguments to find a Swimlane
     * @example
     * // Get one Swimlane
     * const swimlane = await prisma.swimlane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SwimlaneFindFirstOrThrowArgs>(args?: SelectSubset<T, SwimlaneFindFirstOrThrowArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Swimlanes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Swimlanes
     * const swimlanes = await prisma.swimlane.findMany()
     * 
     * // Get first 10 Swimlanes
     * const swimlanes = await prisma.swimlane.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const swimlaneWithIdOnly = await prisma.swimlane.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SwimlaneFindManyArgs>(args?: SelectSubset<T, SwimlaneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Swimlane.
     * @param {SwimlaneCreateArgs} args - Arguments to create a Swimlane.
     * @example
     * // Create one Swimlane
     * const Swimlane = await prisma.swimlane.create({
     *   data: {
     *     // ... data to create a Swimlane
     *   }
     * })
     * 
     */
    create<T extends SwimlaneCreateArgs>(args: SelectSubset<T, SwimlaneCreateArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Swimlanes.
     * @param {SwimlaneCreateManyArgs} args - Arguments to create many Swimlanes.
     * @example
     * // Create many Swimlanes
     * const swimlane = await prisma.swimlane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SwimlaneCreateManyArgs>(args?: SelectSubset<T, SwimlaneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Swimlanes and returns the data saved in the database.
     * @param {SwimlaneCreateManyAndReturnArgs} args - Arguments to create many Swimlanes.
     * @example
     * // Create many Swimlanes
     * const swimlane = await prisma.swimlane.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Swimlanes and only return the `id`
     * const swimlaneWithIdOnly = await prisma.swimlane.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SwimlaneCreateManyAndReturnArgs>(args?: SelectSubset<T, SwimlaneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Swimlane.
     * @param {SwimlaneDeleteArgs} args - Arguments to delete one Swimlane.
     * @example
     * // Delete one Swimlane
     * const Swimlane = await prisma.swimlane.delete({
     *   where: {
     *     // ... filter to delete one Swimlane
     *   }
     * })
     * 
     */
    delete<T extends SwimlaneDeleteArgs>(args: SelectSubset<T, SwimlaneDeleteArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Swimlane.
     * @param {SwimlaneUpdateArgs} args - Arguments to update one Swimlane.
     * @example
     * // Update one Swimlane
     * const swimlane = await prisma.swimlane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SwimlaneUpdateArgs>(args: SelectSubset<T, SwimlaneUpdateArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Swimlanes.
     * @param {SwimlaneDeleteManyArgs} args - Arguments to filter Swimlanes to delete.
     * @example
     * // Delete a few Swimlanes
     * const { count } = await prisma.swimlane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SwimlaneDeleteManyArgs>(args?: SelectSubset<T, SwimlaneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Swimlanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Swimlanes
     * const swimlane = await prisma.swimlane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SwimlaneUpdateManyArgs>(args: SelectSubset<T, SwimlaneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Swimlanes and returns the data updated in the database.
     * @param {SwimlaneUpdateManyAndReturnArgs} args - Arguments to update many Swimlanes.
     * @example
     * // Update many Swimlanes
     * const swimlane = await prisma.swimlane.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Swimlanes and only return the `id`
     * const swimlaneWithIdOnly = await prisma.swimlane.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SwimlaneUpdateManyAndReturnArgs>(args: SelectSubset<T, SwimlaneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Swimlane.
     * @param {SwimlaneUpsertArgs} args - Arguments to update or create a Swimlane.
     * @example
     * // Update or create a Swimlane
     * const swimlane = await prisma.swimlane.upsert({
     *   create: {
     *     // ... data to create a Swimlane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Swimlane we want to update
     *   }
     * })
     */
    upsert<T extends SwimlaneUpsertArgs>(args: SelectSubset<T, SwimlaneUpsertArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Swimlanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneCountArgs} args - Arguments to filter Swimlanes to count.
     * @example
     * // Count the number of Swimlanes
     * const count = await prisma.swimlane.count({
     *   where: {
     *     // ... the filter for the Swimlanes we want to count
     *   }
     * })
    **/
    count<T extends SwimlaneCountArgs>(
      args?: Subset<T, SwimlaneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SwimlaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Swimlane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SwimlaneAggregateArgs>(args: Subset<T, SwimlaneAggregateArgs>): Prisma.PrismaPromise<GetSwimlaneAggregateType<T>>

    /**
     * Group by Swimlane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwimlaneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SwimlaneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SwimlaneGroupByArgs['orderBy'] }
        : { orderBy?: SwimlaneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SwimlaneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSwimlaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Swimlane model
   */
  readonly fields: SwimlaneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Swimlane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SwimlaneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Swimlane$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Swimlane$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Swimlane model
   */
  interface SwimlaneFieldRefs {
    readonly id: FieldRef<"Swimlane", 'Int'>
    readonly projectId: FieldRef<"Swimlane", 'Int'>
    readonly name: FieldRef<"Swimlane", 'String'>
    readonly description: FieldRef<"Swimlane", 'String'>
    readonly position: FieldRef<"Swimlane", 'Int'>
    readonly isActive: FieldRef<"Swimlane", 'Boolean'>
    readonly createdAt: FieldRef<"Swimlane", 'DateTime'>
    readonly updatedAt: FieldRef<"Swimlane", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Swimlane findUnique
   */
  export type SwimlaneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * Filter, which Swimlane to fetch.
     */
    where: SwimlaneWhereUniqueInput
  }

  /**
   * Swimlane findUniqueOrThrow
   */
  export type SwimlaneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * Filter, which Swimlane to fetch.
     */
    where: SwimlaneWhereUniqueInput
  }

  /**
   * Swimlane findFirst
   */
  export type SwimlaneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * Filter, which Swimlane to fetch.
     */
    where?: SwimlaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Swimlanes to fetch.
     */
    orderBy?: SwimlaneOrderByWithRelationInput | SwimlaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Swimlanes.
     */
    cursor?: SwimlaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Swimlanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Swimlanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Swimlanes.
     */
    distinct?: SwimlaneScalarFieldEnum | SwimlaneScalarFieldEnum[]
  }

  /**
   * Swimlane findFirstOrThrow
   */
  export type SwimlaneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * Filter, which Swimlane to fetch.
     */
    where?: SwimlaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Swimlanes to fetch.
     */
    orderBy?: SwimlaneOrderByWithRelationInput | SwimlaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Swimlanes.
     */
    cursor?: SwimlaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Swimlanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Swimlanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Swimlanes.
     */
    distinct?: SwimlaneScalarFieldEnum | SwimlaneScalarFieldEnum[]
  }

  /**
   * Swimlane findMany
   */
  export type SwimlaneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * Filter, which Swimlanes to fetch.
     */
    where?: SwimlaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Swimlanes to fetch.
     */
    orderBy?: SwimlaneOrderByWithRelationInput | SwimlaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Swimlanes.
     */
    cursor?: SwimlaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Swimlanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Swimlanes.
     */
    skip?: number
    distinct?: SwimlaneScalarFieldEnum | SwimlaneScalarFieldEnum[]
  }

  /**
   * Swimlane create
   */
  export type SwimlaneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * The data needed to create a Swimlane.
     */
    data: XOR<SwimlaneCreateInput, SwimlaneUncheckedCreateInput>
  }

  /**
   * Swimlane createMany
   */
  export type SwimlaneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Swimlanes.
     */
    data: SwimlaneCreateManyInput | SwimlaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Swimlane createManyAndReturn
   */
  export type SwimlaneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * The data used to create many Swimlanes.
     */
    data: SwimlaneCreateManyInput | SwimlaneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Swimlane update
   */
  export type SwimlaneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * The data needed to update a Swimlane.
     */
    data: XOR<SwimlaneUpdateInput, SwimlaneUncheckedUpdateInput>
    /**
     * Choose, which Swimlane to update.
     */
    where: SwimlaneWhereUniqueInput
  }

  /**
   * Swimlane updateMany
   */
  export type SwimlaneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Swimlanes.
     */
    data: XOR<SwimlaneUpdateManyMutationInput, SwimlaneUncheckedUpdateManyInput>
    /**
     * Filter which Swimlanes to update
     */
    where?: SwimlaneWhereInput
    /**
     * Limit how many Swimlanes to update.
     */
    limit?: number
  }

  /**
   * Swimlane updateManyAndReturn
   */
  export type SwimlaneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * The data used to update Swimlanes.
     */
    data: XOR<SwimlaneUpdateManyMutationInput, SwimlaneUncheckedUpdateManyInput>
    /**
     * Filter which Swimlanes to update
     */
    where?: SwimlaneWhereInput
    /**
     * Limit how many Swimlanes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Swimlane upsert
   */
  export type SwimlaneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * The filter to search for the Swimlane to update in case it exists.
     */
    where: SwimlaneWhereUniqueInput
    /**
     * In case the Swimlane found by the `where` argument doesn't exist, create a new Swimlane with this data.
     */
    create: XOR<SwimlaneCreateInput, SwimlaneUncheckedCreateInput>
    /**
     * In case the Swimlane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SwimlaneUpdateInput, SwimlaneUncheckedUpdateInput>
  }

  /**
   * Swimlane delete
   */
  export type SwimlaneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    /**
     * Filter which Swimlane to delete.
     */
    where: SwimlaneWhereUniqueInput
  }

  /**
   * Swimlane deleteMany
   */
  export type SwimlaneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Swimlanes to delete
     */
    where?: SwimlaneWhereInput
    /**
     * Limit how many Swimlanes to delete.
     */
    limit?: number
  }

  /**
   * Swimlane.tasks
   */
  export type Swimlane$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Swimlane without action
   */
  export type SwimlaneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    columnId: number | null
    swimlaneId: number | null
    creatorId: number | null
    priority: number | null
    score: number | null
    progress: number | null
    position: number | null
    timeEstimated: number | null
    timeSpent: number | null
    milestoneId: number | null
    moduleId: number | null
    sprintId: number | null
    categoryId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    columnId: number | null
    swimlaneId: number | null
    creatorId: number | null
    priority: number | null
    score: number | null
    progress: number | null
    position: number | null
    timeEstimated: number | null
    timeSpent: number | null
    milestoneId: number | null
    moduleId: number | null
    sprintId: number | null
    categoryId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    columnId: number | null
    swimlaneId: number | null
    creatorId: number | null
    title: string | null
    description: string | null
    reference: string | null
    priority: number | null
    score: number | null
    progress: number | null
    position: number | null
    color: string | null
    dateStarted: Date | null
    dateDue: Date | null
    dateCompleted: Date | null
    reminderAt: Date | null
    timeEstimated: number | null
    timeSpent: number | null
    isActive: boolean | null
    isDraggable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    milestoneId: number | null
    moduleId: number | null
    sprintId: number | null
    categoryId: number | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    columnId: number | null
    swimlaneId: number | null
    creatorId: number | null
    title: string | null
    description: string | null
    reference: string | null
    priority: number | null
    score: number | null
    progress: number | null
    position: number | null
    color: string | null
    dateStarted: Date | null
    dateDue: Date | null
    dateCompleted: Date | null
    reminderAt: Date | null
    timeEstimated: number | null
    timeSpent: number | null
    isActive: boolean | null
    isDraggable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    milestoneId: number | null
    moduleId: number | null
    sprintId: number | null
    categoryId: number | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    projectId: number
    columnId: number
    swimlaneId: number
    creatorId: number
    title: number
    description: number
    reference: number
    priority: number
    score: number
    progress: number
    position: number
    color: number
    dateStarted: number
    dateDue: number
    dateCompleted: number
    reminderAt: number
    timeEstimated: number
    timeSpent: number
    isActive: number
    isDraggable: number
    recurrenceData: number
    createdAt: number
    updatedAt: number
    milestoneId: number
    moduleId: number
    sprintId: number
    categoryId: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    projectId?: true
    columnId?: true
    swimlaneId?: true
    creatorId?: true
    priority?: true
    score?: true
    progress?: true
    position?: true
    timeEstimated?: true
    timeSpent?: true
    milestoneId?: true
    moduleId?: true
    sprintId?: true
    categoryId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    projectId?: true
    columnId?: true
    swimlaneId?: true
    creatorId?: true
    priority?: true
    score?: true
    progress?: true
    position?: true
    timeEstimated?: true
    timeSpent?: true
    milestoneId?: true
    moduleId?: true
    sprintId?: true
    categoryId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    projectId?: true
    columnId?: true
    swimlaneId?: true
    creatorId?: true
    title?: true
    description?: true
    reference?: true
    priority?: true
    score?: true
    progress?: true
    position?: true
    color?: true
    dateStarted?: true
    dateDue?: true
    dateCompleted?: true
    reminderAt?: true
    timeEstimated?: true
    timeSpent?: true
    isActive?: true
    isDraggable?: true
    createdAt?: true
    updatedAt?: true
    milestoneId?: true
    moduleId?: true
    sprintId?: true
    categoryId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    projectId?: true
    columnId?: true
    swimlaneId?: true
    creatorId?: true
    title?: true
    description?: true
    reference?: true
    priority?: true
    score?: true
    progress?: true
    position?: true
    color?: true
    dateStarted?: true
    dateDue?: true
    dateCompleted?: true
    reminderAt?: true
    timeEstimated?: true
    timeSpent?: true
    isActive?: true
    isDraggable?: true
    createdAt?: true
    updatedAt?: true
    milestoneId?: true
    moduleId?: true
    sprintId?: true
    categoryId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    projectId?: true
    columnId?: true
    swimlaneId?: true
    creatorId?: true
    title?: true
    description?: true
    reference?: true
    priority?: true
    score?: true
    progress?: true
    position?: true
    color?: true
    dateStarted?: true
    dateDue?: true
    dateCompleted?: true
    reminderAt?: true
    timeEstimated?: true
    timeSpent?: true
    isActive?: true
    isDraggable?: true
    recurrenceData?: true
    createdAt?: true
    updatedAt?: true
    milestoneId?: true
    moduleId?: true
    sprintId?: true
    categoryId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    projectId: number
    columnId: number
    swimlaneId: number | null
    creatorId: number
    title: string
    description: string | null
    reference: string | null
    priority: number
    score: number
    progress: number
    position: number
    color: string | null
    dateStarted: Date | null
    dateDue: Date | null
    dateCompleted: Date | null
    reminderAt: Date | null
    timeEstimated: number
    timeSpent: number
    isActive: boolean
    isDraggable: boolean
    recurrenceData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    milestoneId: number | null
    moduleId: number | null
    sprintId: number | null
    categoryId: number | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    columnId?: boolean
    swimlaneId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    reference?: boolean
    priority?: boolean
    score?: boolean
    progress?: boolean
    position?: boolean
    color?: boolean
    dateStarted?: boolean
    dateDue?: boolean
    dateCompleted?: boolean
    reminderAt?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestoneId?: boolean
    moduleId?: boolean
    sprintId?: boolean
    categoryId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    swimlane?: boolean | Task$swimlaneArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | Task$milestoneArgs<ExtArgs>
    module?: boolean | Task$moduleArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    category?: boolean | Task$categoryArgs<ExtArgs>
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    tags?: boolean | Task$tagsArgs<ExtArgs>
    customValues?: boolean | Task$customValuesArgs<ExtArgs>
    linksFrom?: boolean | Task$linksFromArgs<ExtArgs>
    linksTo?: boolean | Task$linksToArgs<ExtArgs>
    genxSessions?: boolean | Task$genxSessionsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    columnId?: boolean
    swimlaneId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    reference?: boolean
    priority?: boolean
    score?: boolean
    progress?: boolean
    position?: boolean
    color?: boolean
    dateStarted?: boolean
    dateDue?: boolean
    dateCompleted?: boolean
    reminderAt?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestoneId?: boolean
    moduleId?: boolean
    sprintId?: boolean
    categoryId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    swimlane?: boolean | Task$swimlaneArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | Task$milestoneArgs<ExtArgs>
    module?: boolean | Task$moduleArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    category?: boolean | Task$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    columnId?: boolean
    swimlaneId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    reference?: boolean
    priority?: boolean
    score?: boolean
    progress?: boolean
    position?: boolean
    color?: boolean
    dateStarted?: boolean
    dateDue?: boolean
    dateCompleted?: boolean
    reminderAt?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestoneId?: boolean
    moduleId?: boolean
    sprintId?: boolean
    categoryId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    swimlane?: boolean | Task$swimlaneArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | Task$milestoneArgs<ExtArgs>
    module?: boolean | Task$moduleArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    category?: boolean | Task$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    projectId?: boolean
    columnId?: boolean
    swimlaneId?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    reference?: boolean
    priority?: boolean
    score?: boolean
    progress?: boolean
    position?: boolean
    color?: boolean
    dateStarted?: boolean
    dateDue?: boolean
    dateCompleted?: boolean
    reminderAt?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestoneId?: boolean
    moduleId?: boolean
    sprintId?: boolean
    categoryId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "columnId" | "swimlaneId" | "creatorId" | "title" | "description" | "reference" | "priority" | "score" | "progress" | "position" | "color" | "dateStarted" | "dateDue" | "dateCompleted" | "reminderAt" | "timeEstimated" | "timeSpent" | "isActive" | "isDraggable" | "recurrenceData" | "createdAt" | "updatedAt" | "milestoneId" | "moduleId" | "sprintId" | "categoryId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    swimlane?: boolean | Task$swimlaneArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | Task$milestoneArgs<ExtArgs>
    module?: boolean | Task$moduleArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    category?: boolean | Task$categoryArgs<ExtArgs>
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    tags?: boolean | Task$tagsArgs<ExtArgs>
    customValues?: boolean | Task$customValuesArgs<ExtArgs>
    linksFrom?: boolean | Task$linksFromArgs<ExtArgs>
    linksTo?: boolean | Task$linksToArgs<ExtArgs>
    genxSessions?: boolean | Task$genxSessionsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    swimlane?: boolean | Task$swimlaneArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | Task$milestoneArgs<ExtArgs>
    module?: boolean | Task$moduleArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    category?: boolean | Task$categoryArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    column?: boolean | ColumnDefaultArgs<ExtArgs>
    swimlane?: boolean | Task$swimlaneArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    milestone?: boolean | Task$milestoneArgs<ExtArgs>
    module?: boolean | Task$moduleArgs<ExtArgs>
    sprint?: boolean | Task$sprintArgs<ExtArgs>
    category?: boolean | Task$categoryArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      column: Prisma.$ColumnPayload<ExtArgs>
      swimlane: Prisma.$SwimlanePayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      milestone: Prisma.$MilestonePayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      assignees: Prisma.$TaskAssigneePayload<ExtArgs>[]
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      tags: Prisma.$TaskTagPayload<ExtArgs>[]
      customValues: Prisma.$TaskCustomValuePayload<ExtArgs>[]
      linksFrom: Prisma.$TaskLinkPayload<ExtArgs>[]
      linksTo: Prisma.$TaskLinkPayload<ExtArgs>[]
      genxSessions: Prisma.$TaskSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      columnId: number
      swimlaneId: number | null
      creatorId: number
      title: string
      description: string | null
      reference: string | null
      priority: number
      score: number
      progress: number
      position: number
      color: string | null
      dateStarted: Date | null
      dateDue: Date | null
      dateCompleted: Date | null
      reminderAt: Date | null
      timeEstimated: number
      timeSpent: number
      isActive: boolean
      isDraggable: boolean
      recurrenceData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      milestoneId: number | null
      moduleId: number | null
      sprintId: number | null
      categoryId: number | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    column<T extends ColumnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColumnDefaultArgs<ExtArgs>>): Prisma__ColumnClient<$Result.GetResult<Prisma.$ColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    swimlane<T extends Task$swimlaneArgs<ExtArgs> = {}>(args?: Subset<T, Task$swimlaneArgs<ExtArgs>>): Prisma__SwimlaneClient<$Result.GetResult<Prisma.$SwimlanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    milestone<T extends Task$milestoneArgs<ExtArgs> = {}>(args?: Subset<T, Task$milestoneArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    module<T extends Task$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Task$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sprint<T extends Task$sprintArgs<ExtArgs> = {}>(args?: Subset<T, Task$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Task$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Task$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignees<T extends Task$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subtasks<T extends Task$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Task$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Task$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Task$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Task$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customValues<T extends Task$customValuesArgs<ExtArgs> = {}>(args?: Subset<T, Task$customValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linksFrom<T extends Task$linksFromArgs<ExtArgs> = {}>(args?: Subset<T, Task$linksFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linksTo<T extends Task$linksToArgs<ExtArgs> = {}>(args?: Subset<T, Task$linksToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genxSessions<T extends Task$genxSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Task$genxSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly projectId: FieldRef<"Task", 'Int'>
    readonly columnId: FieldRef<"Task", 'Int'>
    readonly swimlaneId: FieldRef<"Task", 'Int'>
    readonly creatorId: FieldRef<"Task", 'Int'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly reference: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'Int'>
    readonly score: FieldRef<"Task", 'Int'>
    readonly progress: FieldRef<"Task", 'Int'>
    readonly position: FieldRef<"Task", 'Int'>
    readonly color: FieldRef<"Task", 'String'>
    readonly dateStarted: FieldRef<"Task", 'DateTime'>
    readonly dateDue: FieldRef<"Task", 'DateTime'>
    readonly dateCompleted: FieldRef<"Task", 'DateTime'>
    readonly reminderAt: FieldRef<"Task", 'DateTime'>
    readonly timeEstimated: FieldRef<"Task", 'Float'>
    readonly timeSpent: FieldRef<"Task", 'Float'>
    readonly isActive: FieldRef<"Task", 'Boolean'>
    readonly isDraggable: FieldRef<"Task", 'Boolean'>
    readonly recurrenceData: FieldRef<"Task", 'Json'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly milestoneId: FieldRef<"Task", 'Int'>
    readonly moduleId: FieldRef<"Task", 'Int'>
    readonly sprintId: FieldRef<"Task", 'Int'>
    readonly categoryId: FieldRef<"Task", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.swimlane
   */
  export type Task$swimlaneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Swimlane
     */
    select?: SwimlaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Swimlane
     */
    omit?: SwimlaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SwimlaneInclude<ExtArgs> | null
    where?: SwimlaneWhereInput
  }

  /**
   * Task.milestone
   */
  export type Task$milestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
  }

  /**
   * Task.module
   */
  export type Task$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Task.sprint
   */
  export type Task$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * Task.category
   */
  export type Task$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Task.assignees
   */
  export type Task$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * Task.subtasks
   */
  export type Task$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Task.attachments
   */
  export type Task$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Task.tags
   */
  export type Task$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    where?: TaskTagWhereInput
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    cursor?: TaskTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * Task.customValues
   */
  export type Task$customValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    where?: TaskCustomValueWhereInput
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    cursor?: TaskCustomValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * Task.linksFrom
   */
  export type Task$linksFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    where?: TaskLinkWhereInput
    orderBy?: TaskLinkOrderByWithRelationInput | TaskLinkOrderByWithRelationInput[]
    cursor?: TaskLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLinkScalarFieldEnum | TaskLinkScalarFieldEnum[]
  }

  /**
   * Task.linksTo
   */
  export type Task$linksToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    where?: TaskLinkWhereInput
    orderBy?: TaskLinkOrderByWithRelationInput | TaskLinkOrderByWithRelationInput[]
    cursor?: TaskLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLinkScalarFieldEnum | TaskLinkScalarFieldEnum[]
  }

  /**
   * Task.genxSessions
   */
  export type Task$genxSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    where?: TaskSessionWhereInput
    orderBy?: TaskSessionOrderByWithRelationInput | TaskSessionOrderByWithRelationInput[]
    cursor?: TaskSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskSessionScalarFieldEnum | TaskSessionScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignee
   */

  export type AggregateTaskAssignee = {
    _count: TaskAssigneeCountAggregateOutputType | null
    _avg: TaskAssigneeAvgAggregateOutputType | null
    _sum: TaskAssigneeSumAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  export type TaskAssigneeAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
  }

  export type TaskAssigneeSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
  }

  export type TaskAssigneeMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    createdAt: Date | null
  }

  export type TaskAssigneeMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    createdAt: Date | null
  }

  export type TaskAssigneeCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type TaskAssigneeAvgAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type TaskAssigneeSumAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type TaskAssigneeMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    createdAt?: true
  }

  export type TaskAssigneeMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    createdAt?: true
  }

  export type TaskAssigneeCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type TaskAssigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignee to aggregate.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignees
    **/
    _count?: true | TaskAssigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAssigneeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskAssigneeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type GetTaskAssigneeAggregateType<T extends TaskAssigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignee[P]>
      : GetScalarType<T[P], AggregateTaskAssignee[P]>
  }




  export type TaskAssigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithAggregationInput | TaskAssigneeOrderByWithAggregationInput[]
    by: TaskAssigneeScalarFieldEnum[] | TaskAssigneeScalarFieldEnum
    having?: TaskAssigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssigneeCountAggregateInputType | true
    _avg?: TaskAssigneeAvgAggregateInputType
    _sum?: TaskAssigneeSumAggregateInputType
    _min?: TaskAssigneeMinAggregateInputType
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type TaskAssigneeGroupByOutputType = {
    id: number
    taskId: number
    userId: number
    createdAt: Date
    _count: TaskAssigneeCountAggregateOutputType | null
    _avg: TaskAssigneeAvgAggregateOutputType | null
    _sum: TaskAssigneeSumAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  type GetTaskAssigneeGroupByPayload<T extends TaskAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type TaskAssigneeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "createdAt", ExtArgs["result"]["taskAssignee"]>
  export type TaskAssigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskAssigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignee"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["taskAssignee"]>
    composites: {}
  }

  type TaskAssigneeGetPayload<S extends boolean | null | undefined | TaskAssigneeDefaultArgs> = $Result.GetResult<Prisma.$TaskAssigneePayload, S>

  type TaskAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssigneeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssigneeCountAggregateInputType | true
    }

  export interface TaskAssigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignee'], meta: { name: 'TaskAssignee' } }
    /**
     * Find zero or one TaskAssignee that matches the filter.
     * @param {TaskAssigneeFindUniqueArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssigneeFindUniqueArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAssignee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssigneeFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssigneeFindFirstArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany()
     * 
     * // Get first 10 TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAssigneeFindManyArgs>(args?: SelectSubset<T, TaskAssigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAssignee.
     * @param {TaskAssigneeCreateArgs} args - Arguments to create a TaskAssignee.
     * @example
     * // Create one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.create({
     *   data: {
     *     // ... data to create a TaskAssignee
     *   }
     * })
     * 
     */
    create<T extends TaskAssigneeCreateArgs>(args: SelectSubset<T, TaskAssigneeCreateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAssignees.
     * @param {TaskAssigneeCreateManyArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssigneeCreateManyArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignees and returns the data saved in the database.
     * @param {TaskAssigneeCreateManyAndReturnArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignees and only return the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAssignee.
     * @param {TaskAssigneeDeleteArgs} args - Arguments to delete one TaskAssignee.
     * @example
     * // Delete one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignee
     *   }
     * })
     * 
     */
    delete<T extends TaskAssigneeDeleteArgs>(args: SelectSubset<T, TaskAssigneeDeleteArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAssignee.
     * @param {TaskAssigneeUpdateArgs} args - Arguments to update one TaskAssignee.
     * @example
     * // Update one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssigneeUpdateArgs>(args: SelectSubset<T, TaskAssigneeUpdateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAssignees.
     * @param {TaskAssigneeDeleteManyArgs} args - Arguments to filter TaskAssignees to delete.
     * @example
     * // Delete a few TaskAssignees
     * const { count } = await prisma.taskAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssigneeDeleteManyArgs>(args?: SelectSubset<T, TaskAssigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssigneeUpdateManyArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees and returns the data updated in the database.
     * @param {TaskAssigneeUpdateManyAndReturnArgs} args - Arguments to update many TaskAssignees.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAssignees and only return the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAssigneeUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAssignee.
     * @param {TaskAssigneeUpsertArgs} args - Arguments to update or create a TaskAssignee.
     * @example
     * // Update or create a TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.upsert({
     *   create: {
     *     // ... data to create a TaskAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignee we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssigneeUpsertArgs>(args: SelectSubset<T, TaskAssigneeUpsertArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeCountArgs} args - Arguments to filter TaskAssignees to count.
     * @example
     * // Count the number of TaskAssignees
     * const count = await prisma.taskAssignee.count({
     *   where: {
     *     // ... the filter for the TaskAssignees we want to count
     *   }
     * })
    **/
    count<T extends TaskAssigneeCountArgs>(
      args?: Subset<T, TaskAssigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssigneeAggregateArgs>(args: Subset<T, TaskAssigneeAggregateArgs>): Prisma.PrismaPromise<GetTaskAssigneeAggregateType<T>>

    /**
     * Group by TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignee model
   */
  readonly fields: TaskAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignee model
   */
  interface TaskAssigneeFieldRefs {
    readonly id: FieldRef<"TaskAssignee", 'Int'>
    readonly taskId: FieldRef<"TaskAssignee", 'Int'>
    readonly userId: FieldRef<"TaskAssignee", 'Int'>
    readonly createdAt: FieldRef<"TaskAssignee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignee findUnique
   */
  export type TaskAssigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findUniqueOrThrow
   */
  export type TaskAssigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findFirst
   */
  export type TaskAssigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findFirstOrThrow
   */
  export type TaskAssigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findMany
   */
  export type TaskAssigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignees to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee create
   */
  export type TaskAssigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignee.
     */
    data: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
  }

  /**
   * TaskAssignee createMany
   */
  export type TaskAssigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignee createManyAndReturn
   */
  export type TaskAssigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee update
   */
  export type TaskAssigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignee.
     */
    data: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignee to update.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee updateMany
   */
  export type TaskAssigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number
  }

  /**
   * TaskAssignee updateManyAndReturn
   */
  export type TaskAssigneeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee upsert
   */
  export type TaskAssigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignee to update in case it exists.
     */
    where: TaskAssigneeWhereUniqueInput
    /**
     * In case the TaskAssignee found by the `where` argument doesn't exist, create a new TaskAssignee with this data.
     */
    create: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
    /**
     * In case the TaskAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
  }

  /**
   * TaskAssignee delete
   */
  export type TaskAssigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignee to delete.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee deleteMany
   */
  export type TaskAssigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignees to delete
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to delete.
     */
    limit?: number
  }

  /**
   * TaskAssignee without action
   */
  export type TaskAssigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
  }


  /**
   * Model Subtask
   */

  export type AggregateSubtask = {
    _count: SubtaskCountAggregateOutputType | null
    _avg: SubtaskAvgAggregateOutputType | null
    _sum: SubtaskSumAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  export type SubtaskAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    position: number | null
    assigneeId: number | null
    timeEstimated: number | null
    timeSpent: number | null
  }

  export type SubtaskSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    position: number | null
    assigneeId: number | null
    timeEstimated: number | null
    timeSpent: number | null
  }

  export type SubtaskMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    title: string | null
    description: string | null
    status: $Enums.SubtaskStatus | null
    position: number | null
    assigneeId: number | null
    timeEstimated: number | null
    timeSpent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtaskMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    title: string | null
    description: string | null
    status: $Enums.SubtaskStatus | null
    position: number | null
    assigneeId: number | null
    timeEstimated: number | null
    timeSpent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtaskCountAggregateOutputType = {
    id: number
    taskId: number
    title: number
    description: number
    status: number
    position: number
    assigneeId: number
    timeEstimated: number
    timeSpent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubtaskAvgAggregateInputType = {
    id?: true
    taskId?: true
    position?: true
    assigneeId?: true
    timeEstimated?: true
    timeSpent?: true
  }

  export type SubtaskSumAggregateInputType = {
    id?: true
    taskId?: true
    position?: true
    assigneeId?: true
    timeEstimated?: true
    timeSpent?: true
  }

  export type SubtaskMinAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    description?: true
    status?: true
    position?: true
    assigneeId?: true
    timeEstimated?: true
    timeSpent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtaskMaxAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    description?: true
    status?: true
    position?: true
    assigneeId?: true
    timeEstimated?: true
    timeSpent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtaskCountAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    description?: true
    status?: true
    position?: true
    assigneeId?: true
    timeEstimated?: true
    timeSpent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubtaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtask to aggregate.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subtasks
    **/
    _count?: true | SubtaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubtaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubtaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtaskMaxAggregateInputType
  }

  export type GetSubtaskAggregateType<T extends SubtaskAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtask[P]>
      : GetScalarType<T[P], AggregateSubtask[P]>
  }




  export type SubtaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithAggregationInput | SubtaskOrderByWithAggregationInput[]
    by: SubtaskScalarFieldEnum[] | SubtaskScalarFieldEnum
    having?: SubtaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtaskCountAggregateInputType | true
    _avg?: SubtaskAvgAggregateInputType
    _sum?: SubtaskSumAggregateInputType
    _min?: SubtaskMinAggregateInputType
    _max?: SubtaskMaxAggregateInputType
  }

  export type SubtaskGroupByOutputType = {
    id: number
    taskId: number
    title: string
    description: string | null
    status: $Enums.SubtaskStatus
    position: number
    assigneeId: number | null
    timeEstimated: number
    timeSpent: number
    createdAt: Date
    updatedAt: Date
    _count: SubtaskCountAggregateOutputType | null
    _avg: SubtaskAvgAggregateOutputType | null
    _sum: SubtaskSumAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  type GetSubtaskGroupByPayload<T extends SubtaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
            : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
        }
      >
    >


  export type SubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    position?: boolean
    assigneeId?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    position?: boolean
    assigneeId?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    position?: boolean
    assigneeId?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectScalar = {
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    position?: boolean
    assigneeId?: boolean
    timeEstimated?: boolean
    timeSpent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubtaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "title" | "description" | "status" | "position" | "assigneeId" | "timeEstimated" | "timeSpent" | "createdAt" | "updatedAt", ExtArgs["result"]["subtask"]>
  export type SubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }
  export type SubtaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }
  export type SubtaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    assignee?: boolean | Subtask$assigneeArgs<ExtArgs>
  }

  export type $SubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subtask"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      title: string
      description: string | null
      status: $Enums.SubtaskStatus
      position: number
      assigneeId: number | null
      timeEstimated: number
      timeSpent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subtask"]>
    composites: {}
  }

  type SubtaskGetPayload<S extends boolean | null | undefined | SubtaskDefaultArgs> = $Result.GetResult<Prisma.$SubtaskPayload, S>

  type SubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubtaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubtaskCountAggregateInputType | true
    }

  export interface SubtaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subtask'], meta: { name: 'Subtask' } }
    /**
     * Find zero or one Subtask that matches the filter.
     * @param {SubtaskFindUniqueArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtaskFindUniqueArgs>(args: SelectSubset<T, SubtaskFindUniqueArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subtask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubtaskFindUniqueOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtaskFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subtask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtaskFindFirstArgs>(args?: SelectSubset<T, SubtaskFindFirstArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subtask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtaskFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subtasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtasks
     * const subtasks = await prisma.subtask.findMany()
     * 
     * // Get first 10 Subtasks
     * const subtasks = await prisma.subtask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtaskWithIdOnly = await prisma.subtask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtaskFindManyArgs>(args?: SelectSubset<T, SubtaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subtask.
     * @param {SubtaskCreateArgs} args - Arguments to create a Subtask.
     * @example
     * // Create one Subtask
     * const Subtask = await prisma.subtask.create({
     *   data: {
     *     // ... data to create a Subtask
     *   }
     * })
     * 
     */
    create<T extends SubtaskCreateArgs>(args: SelectSubset<T, SubtaskCreateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subtasks.
     * @param {SubtaskCreateManyArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtaskCreateManyArgs>(args?: SelectSubset<T, SubtaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subtasks and returns the data saved in the database.
     * @param {SubtaskCreateManyAndReturnArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subtasks and only return the `id`
     * const subtaskWithIdOnly = await prisma.subtask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtaskCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subtask.
     * @param {SubtaskDeleteArgs} args - Arguments to delete one Subtask.
     * @example
     * // Delete one Subtask
     * const Subtask = await prisma.subtask.delete({
     *   where: {
     *     // ... filter to delete one Subtask
     *   }
     * })
     * 
     */
    delete<T extends SubtaskDeleteArgs>(args: SelectSubset<T, SubtaskDeleteArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subtask.
     * @param {SubtaskUpdateArgs} args - Arguments to update one Subtask.
     * @example
     * // Update one Subtask
     * const subtask = await prisma.subtask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtaskUpdateArgs>(args: SelectSubset<T, SubtaskUpdateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subtasks.
     * @param {SubtaskDeleteManyArgs} args - Arguments to filter Subtasks to delete.
     * @example
     * // Delete a few Subtasks
     * const { count } = await prisma.subtask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtaskDeleteManyArgs>(args?: SelectSubset<T, SubtaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtasks
     * const subtask = await prisma.subtask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtaskUpdateManyArgs>(args: SelectSubset<T, SubtaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtasks and returns the data updated in the database.
     * @param {SubtaskUpdateManyAndReturnArgs} args - Arguments to update many Subtasks.
     * @example
     * // Update many Subtasks
     * const subtask = await prisma.subtask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subtasks and only return the `id`
     * const subtaskWithIdOnly = await prisma.subtask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubtaskUpdateManyAndReturnArgs>(args: SelectSubset<T, SubtaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subtask.
     * @param {SubtaskUpsertArgs} args - Arguments to update or create a Subtask.
     * @example
     * // Update or create a Subtask
     * const subtask = await prisma.subtask.upsert({
     *   create: {
     *     // ... data to create a Subtask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtask we want to update
     *   }
     * })
     */
    upsert<T extends SubtaskUpsertArgs>(args: SelectSubset<T, SubtaskUpsertArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskCountArgs} args - Arguments to filter Subtasks to count.
     * @example
     * // Count the number of Subtasks
     * const count = await prisma.subtask.count({
     *   where: {
     *     // ... the filter for the Subtasks we want to count
     *   }
     * })
    **/
    count<T extends SubtaskCountArgs>(
      args?: Subset<T, SubtaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtaskAggregateArgs>(args: Subset<T, SubtaskAggregateArgs>): Prisma.PrismaPromise<GetSubtaskAggregateType<T>>

    /**
     * Group by Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtaskGroupByArgs['orderBy'] }
        : { orderBy?: SubtaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subtask model
   */
  readonly fields: SubtaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subtask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Subtask$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subtask model
   */
  interface SubtaskFieldRefs {
    readonly id: FieldRef<"Subtask", 'Int'>
    readonly taskId: FieldRef<"Subtask", 'Int'>
    readonly title: FieldRef<"Subtask", 'String'>
    readonly description: FieldRef<"Subtask", 'String'>
    readonly status: FieldRef<"Subtask", 'SubtaskStatus'>
    readonly position: FieldRef<"Subtask", 'Int'>
    readonly assigneeId: FieldRef<"Subtask", 'Int'>
    readonly timeEstimated: FieldRef<"Subtask", 'Float'>
    readonly timeSpent: FieldRef<"Subtask", 'Float'>
    readonly createdAt: FieldRef<"Subtask", 'DateTime'>
    readonly updatedAt: FieldRef<"Subtask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subtask findUnique
   */
  export type SubtaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findUniqueOrThrow
   */
  export type SubtaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findFirst
   */
  export type SubtaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findFirstOrThrow
   */
  export type SubtaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findMany
   */
  export type SubtaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtasks to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask create
   */
  export type SubtaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Subtask.
     */
    data: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
  }

  /**
   * Subtask createMany
   */
  export type SubtaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subtask createManyAndReturn
   */
  export type SubtaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtask update
   */
  export type SubtaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Subtask.
     */
    data: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
    /**
     * Choose, which Subtask to update.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask updateMany
   */
  export type SubtaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subtasks.
     */
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>
    /**
     * Filter which Subtasks to update
     */
    where?: SubtaskWhereInput
    /**
     * Limit how many Subtasks to update.
     */
    limit?: number
  }

  /**
   * Subtask updateManyAndReturn
   */
  export type SubtaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * The data used to update Subtasks.
     */
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>
    /**
     * Filter which Subtasks to update
     */
    where?: SubtaskWhereInput
    /**
     * Limit how many Subtasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtask upsert
   */
  export type SubtaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Subtask to update in case it exists.
     */
    where: SubtaskWhereUniqueInput
    /**
     * In case the Subtask found by the `where` argument doesn't exist, create a new Subtask with this data.
     */
    create: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
    /**
     * In case the Subtask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
  }

  /**
   * Subtask delete
   */
  export type SubtaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter which Subtask to delete.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask deleteMany
   */
  export type SubtaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtasks to delete
     */
    where?: SubtaskWhereInput
    /**
     * Limit how many Subtasks to delete.
     */
    limit?: number
  }

  /**
   * Subtask.assignee
   */
  export type Subtask$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subtask without action
   */
  export type SubtaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subtask
     */
    omit?: SubtaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    taskId: number
    userId: number
    content: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      userId: number
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly taskId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    color: number
    createdAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    projectId: number
    name: string
    color: string
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Tag$tasksArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "color" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Tag$tasksArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      color: string
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Tag$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Tag$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly projectId: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.tasks
   */
  export type Tag$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    where?: TaskTagWhereInput
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    cursor?: TaskTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TaskTag
   */

  export type AggregateTaskTag = {
    _count: TaskTagCountAggregateOutputType | null
    _avg: TaskTagAvgAggregateOutputType | null
    _sum: TaskTagSumAggregateOutputType | null
    _min: TaskTagMinAggregateOutputType | null
    _max: TaskTagMaxAggregateOutputType | null
  }

  export type TaskTagAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    tagId: number | null
  }

  export type TaskTagSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    tagId: number | null
  }

  export type TaskTagMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    tagId: number | null
    createdAt: Date | null
  }

  export type TaskTagMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    tagId: number | null
    createdAt: Date | null
  }

  export type TaskTagCountAggregateOutputType = {
    id: number
    taskId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type TaskTagAvgAggregateInputType = {
    id?: true
    taskId?: true
    tagId?: true
  }

  export type TaskTagSumAggregateInputType = {
    id?: true
    taskId?: true
    tagId?: true
  }

  export type TaskTagMinAggregateInputType = {
    id?: true
    taskId?: true
    tagId?: true
    createdAt?: true
  }

  export type TaskTagMaxAggregateInputType = {
    id?: true
    taskId?: true
    tagId?: true
    createdAt?: true
  }

  export type TaskTagCountAggregateInputType = {
    id?: true
    taskId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type TaskTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTag to aggregate.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTags
    **/
    _count?: true | TaskTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTagMaxAggregateInputType
  }

  export type GetTaskTagAggregateType<T extends TaskTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskTag[P]>
      : GetScalarType<T[P], AggregateTaskTag[P]>
  }




  export type TaskTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTagWhereInput
    orderBy?: TaskTagOrderByWithAggregationInput | TaskTagOrderByWithAggregationInput[]
    by: TaskTagScalarFieldEnum[] | TaskTagScalarFieldEnum
    having?: TaskTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTagCountAggregateInputType | true
    _avg?: TaskTagAvgAggregateInputType
    _sum?: TaskTagSumAggregateInputType
    _min?: TaskTagMinAggregateInputType
    _max?: TaskTagMaxAggregateInputType
  }

  export type TaskTagGroupByOutputType = {
    id: number
    taskId: number
    tagId: number
    createdAt: Date
    _count: TaskTagCountAggregateOutputType | null
    _avg: TaskTagAvgAggregateOutputType | null
    _sum: TaskTagSumAggregateOutputType | null
    _min: TaskTagMinAggregateOutputType | null
    _max: TaskTagMaxAggregateOutputType | null
  }

  type GetTaskTagGroupByPayload<T extends TaskTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTagGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTagGroupByOutputType[P]>
        }
      >
    >


  export type TaskTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    tagId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTag"]>

  export type TaskTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    tagId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTag"]>

  export type TaskTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    tagId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskTag"]>

  export type TaskTagSelectScalar = {
    id?: boolean
    taskId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type TaskTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "tagId" | "createdAt", ExtArgs["result"]["taskTag"]>
  export type TaskTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TaskTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TaskTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TaskTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskTag"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      tagId: number
      createdAt: Date
    }, ExtArgs["result"]["taskTag"]>
    composites: {}
  }

  type TaskTagGetPayload<S extends boolean | null | undefined | TaskTagDefaultArgs> = $Result.GetResult<Prisma.$TaskTagPayload, S>

  type TaskTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskTagCountAggregateInputType | true
    }

  export interface TaskTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskTag'], meta: { name: 'TaskTag' } }
    /**
     * Find zero or one TaskTag that matches the filter.
     * @param {TaskTagFindUniqueArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTagFindUniqueArgs>(args: SelectSubset<T, TaskTagFindUniqueArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskTagFindUniqueOrThrowArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagFindFirstArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTagFindFirstArgs>(args?: SelectSubset<T, TaskTagFindFirstArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagFindFirstOrThrowArgs} args - Arguments to find a TaskTag
     * @example
     * // Get one TaskTag
     * const taskTag = await prisma.taskTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTags
     * const taskTags = await prisma.taskTag.findMany()
     * 
     * // Get first 10 TaskTags
     * const taskTags = await prisma.taskTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskTagWithIdOnly = await prisma.taskTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskTagFindManyArgs>(args?: SelectSubset<T, TaskTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskTag.
     * @param {TaskTagCreateArgs} args - Arguments to create a TaskTag.
     * @example
     * // Create one TaskTag
     * const TaskTag = await prisma.taskTag.create({
     *   data: {
     *     // ... data to create a TaskTag
     *   }
     * })
     * 
     */
    create<T extends TaskTagCreateArgs>(args: SelectSubset<T, TaskTagCreateArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskTags.
     * @param {TaskTagCreateManyArgs} args - Arguments to create many TaskTags.
     * @example
     * // Create many TaskTags
     * const taskTag = await prisma.taskTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTagCreateManyArgs>(args?: SelectSubset<T, TaskTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTags and returns the data saved in the database.
     * @param {TaskTagCreateManyAndReturnArgs} args - Arguments to create many TaskTags.
     * @example
     * // Create many TaskTags
     * const taskTag = await prisma.taskTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTags and only return the `id`
     * const taskTagWithIdOnly = await prisma.taskTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTagCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskTag.
     * @param {TaskTagDeleteArgs} args - Arguments to delete one TaskTag.
     * @example
     * // Delete one TaskTag
     * const TaskTag = await prisma.taskTag.delete({
     *   where: {
     *     // ... filter to delete one TaskTag
     *   }
     * })
     * 
     */
    delete<T extends TaskTagDeleteArgs>(args: SelectSubset<T, TaskTagDeleteArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskTag.
     * @param {TaskTagUpdateArgs} args - Arguments to update one TaskTag.
     * @example
     * // Update one TaskTag
     * const taskTag = await prisma.taskTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTagUpdateArgs>(args: SelectSubset<T, TaskTagUpdateArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskTags.
     * @param {TaskTagDeleteManyArgs} args - Arguments to filter TaskTags to delete.
     * @example
     * // Delete a few TaskTags
     * const { count } = await prisma.taskTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTagDeleteManyArgs>(args?: SelectSubset<T, TaskTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTags
     * const taskTag = await prisma.taskTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTagUpdateManyArgs>(args: SelectSubset<T, TaskTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTags and returns the data updated in the database.
     * @param {TaskTagUpdateManyAndReturnArgs} args - Arguments to update many TaskTags.
     * @example
     * // Update many TaskTags
     * const taskTag = await prisma.taskTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskTags and only return the `id`
     * const taskTagWithIdOnly = await prisma.taskTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskTagUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskTag.
     * @param {TaskTagUpsertArgs} args - Arguments to update or create a TaskTag.
     * @example
     * // Update or create a TaskTag
     * const taskTag = await prisma.taskTag.upsert({
     *   create: {
     *     // ... data to create a TaskTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskTag we want to update
     *   }
     * })
     */
    upsert<T extends TaskTagUpsertArgs>(args: SelectSubset<T, TaskTagUpsertArgs<ExtArgs>>): Prisma__TaskTagClient<$Result.GetResult<Prisma.$TaskTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagCountArgs} args - Arguments to filter TaskTags to count.
     * @example
     * // Count the number of TaskTags
     * const count = await prisma.taskTag.count({
     *   where: {
     *     // ... the filter for the TaskTags we want to count
     *   }
     * })
    **/
    count<T extends TaskTagCountArgs>(
      args?: Subset<T, TaskTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTagAggregateArgs>(args: Subset<T, TaskTagAggregateArgs>): Prisma.PrismaPromise<GetTaskTagAggregateType<T>>

    /**
     * Group by TaskTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTagGroupByArgs['orderBy'] }
        : { orderBy?: TaskTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskTag model
   */
  readonly fields: TaskTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskTag model
   */
  interface TaskTagFieldRefs {
    readonly id: FieldRef<"TaskTag", 'Int'>
    readonly taskId: FieldRef<"TaskTag", 'Int'>
    readonly tagId: FieldRef<"TaskTag", 'Int'>
    readonly createdAt: FieldRef<"TaskTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskTag findUnique
   */
  export type TaskTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag findUniqueOrThrow
   */
  export type TaskTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag findFirst
   */
  export type TaskTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTags.
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTags.
     */
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * TaskTag findFirstOrThrow
   */
  export type TaskTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTag to fetch.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTags.
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTags.
     */
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * TaskTag findMany
   */
  export type TaskTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter, which TaskTags to fetch.
     */
    where?: TaskTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTags to fetch.
     */
    orderBy?: TaskTagOrderByWithRelationInput | TaskTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTags.
     */
    cursor?: TaskTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTags.
     */
    skip?: number
    distinct?: TaskTagScalarFieldEnum | TaskTagScalarFieldEnum[]
  }

  /**
   * TaskTag create
   */
  export type TaskTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskTag.
     */
    data: XOR<TaskTagCreateInput, TaskTagUncheckedCreateInput>
  }

  /**
   * TaskTag createMany
   */
  export type TaskTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTags.
     */
    data: TaskTagCreateManyInput | TaskTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskTag createManyAndReturn
   */
  export type TaskTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * The data used to create many TaskTags.
     */
    data: TaskTagCreateManyInput | TaskTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTag update
   */
  export type TaskTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskTag.
     */
    data: XOR<TaskTagUpdateInput, TaskTagUncheckedUpdateInput>
    /**
     * Choose, which TaskTag to update.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag updateMany
   */
  export type TaskTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTags.
     */
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyInput>
    /**
     * Filter which TaskTags to update
     */
    where?: TaskTagWhereInput
    /**
     * Limit how many TaskTags to update.
     */
    limit?: number
  }

  /**
   * TaskTag updateManyAndReturn
   */
  export type TaskTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * The data used to update TaskTags.
     */
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyInput>
    /**
     * Filter which TaskTags to update
     */
    where?: TaskTagWhereInput
    /**
     * Limit how many TaskTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskTag upsert
   */
  export type TaskTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskTag to update in case it exists.
     */
    where: TaskTagWhereUniqueInput
    /**
     * In case the TaskTag found by the `where` argument doesn't exist, create a new TaskTag with this data.
     */
    create: XOR<TaskTagCreateInput, TaskTagUncheckedCreateInput>
    /**
     * In case the TaskTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTagUpdateInput, TaskTagUncheckedUpdateInput>
  }

  /**
   * TaskTag delete
   */
  export type TaskTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
    /**
     * Filter which TaskTag to delete.
     */
    where: TaskTagWhereUniqueInput
  }

  /**
   * TaskTag deleteMany
   */
  export type TaskTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTags to delete
     */
    where?: TaskTagWhereInput
    /**
     * Limit how many TaskTags to delete.
     */
    limit?: number
  }

  /**
   * TaskTag without action
   */
  export type TaskTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTag
     */
    select?: TaskTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskTag
     */
    omit?: TaskTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTagInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    color: number
    createdAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    color: string
    createdAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Category$tasksArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "color" | "createdAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Category$tasksArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      color: string
      createdAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Category$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Category$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly projectId: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.tasks
   */
  export type Category$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    size: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    size: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    name: string | null
    path: string | null
    mimeType: string | null
    size: number | null
    isImage: boolean | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    userId: number | null
    name: string | null
    path: string | null
    mimeType: string | null
    size: number | null
    isImage: boolean | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    name: number
    path: number
    mimeType: number
    size: number
    isImage: number
    createdAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    size?: true
  }

  export type AttachmentSumAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    size?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    name?: true
    path?: true
    mimeType?: true
    size?: true
    isImage?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    name?: true
    path?: true
    mimeType?: true
    size?: true
    isImage?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    name?: true
    path?: true
    mimeType?: true
    size?: true
    isImage?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: number
    taskId: number
    userId: number
    name: string
    path: string
    mimeType: string | null
    size: number
    isImage: boolean
    createdAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    isImage?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    isImage?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    isImage?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
    name?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    isImage?: boolean
    createdAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId" | "name" | "path" | "mimeType" | "size" | "isImage" | "createdAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      userId: number
      name: string
      path: string
      mimeType: string | null
      size: number
      isImage: boolean
      createdAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'Int'>
    readonly taskId: FieldRef<"Attachment", 'Int'>
    readonly userId: FieldRef<"Attachment", 'Int'>
    readonly name: FieldRef<"Attachment", 'String'>
    readonly path: FieldRef<"Attachment", 'String'>
    readonly mimeType: FieldRef<"Attachment", 'String'>
    readonly size: FieldRef<"Attachment", 'Int'>
    readonly isImage: FieldRef<"Attachment", 'Boolean'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TaskLink
   */

  export type AggregateTaskLink = {
    _count: TaskLinkCountAggregateOutputType | null
    _avg: TaskLinkAvgAggregateOutputType | null
    _sum: TaskLinkSumAggregateOutputType | null
    _min: TaskLinkMinAggregateOutputType | null
    _max: TaskLinkMaxAggregateOutputType | null
  }

  export type TaskLinkAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    oppositeTaskId: number | null
  }

  export type TaskLinkSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    oppositeTaskId: number | null
  }

  export type TaskLinkMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    oppositeTaskId: number | null
    linkType: $Enums.TaskLinkType | null
    createdAt: Date | null
  }

  export type TaskLinkMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    oppositeTaskId: number | null
    linkType: $Enums.TaskLinkType | null
    createdAt: Date | null
  }

  export type TaskLinkCountAggregateOutputType = {
    id: number
    taskId: number
    oppositeTaskId: number
    linkType: number
    createdAt: number
    _all: number
  }


  export type TaskLinkAvgAggregateInputType = {
    id?: true
    taskId?: true
    oppositeTaskId?: true
  }

  export type TaskLinkSumAggregateInputType = {
    id?: true
    taskId?: true
    oppositeTaskId?: true
  }

  export type TaskLinkMinAggregateInputType = {
    id?: true
    taskId?: true
    oppositeTaskId?: true
    linkType?: true
    createdAt?: true
  }

  export type TaskLinkMaxAggregateInputType = {
    id?: true
    taskId?: true
    oppositeTaskId?: true
    linkType?: true
    createdAt?: true
  }

  export type TaskLinkCountAggregateInputType = {
    id?: true
    taskId?: true
    oppositeTaskId?: true
    linkType?: true
    createdAt?: true
    _all?: true
  }

  export type TaskLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLink to aggregate.
     */
    where?: TaskLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLinks to fetch.
     */
    orderBy?: TaskLinkOrderByWithRelationInput | TaskLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskLinks
    **/
    _count?: true | TaskLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskLinkMaxAggregateInputType
  }

  export type GetTaskLinkAggregateType<T extends TaskLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskLink[P]>
      : GetScalarType<T[P], AggregateTaskLink[P]>
  }




  export type TaskLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLinkWhereInput
    orderBy?: TaskLinkOrderByWithAggregationInput | TaskLinkOrderByWithAggregationInput[]
    by: TaskLinkScalarFieldEnum[] | TaskLinkScalarFieldEnum
    having?: TaskLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskLinkCountAggregateInputType | true
    _avg?: TaskLinkAvgAggregateInputType
    _sum?: TaskLinkSumAggregateInputType
    _min?: TaskLinkMinAggregateInputType
    _max?: TaskLinkMaxAggregateInputType
  }

  export type TaskLinkGroupByOutputType = {
    id: number
    taskId: number
    oppositeTaskId: number
    linkType: $Enums.TaskLinkType
    createdAt: Date
    _count: TaskLinkCountAggregateOutputType | null
    _avg: TaskLinkAvgAggregateOutputType | null
    _sum: TaskLinkSumAggregateOutputType | null
    _min: TaskLinkMinAggregateOutputType | null
    _max: TaskLinkMaxAggregateOutputType | null
  }

  type GetTaskLinkGroupByPayload<T extends TaskLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskLinkGroupByOutputType[P]>
            : GetScalarType<T[P], TaskLinkGroupByOutputType[P]>
        }
      >
    >


  export type TaskLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    oppositeTaskId?: boolean
    linkType?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    oppositeTask?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLink"]>

  export type TaskLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    oppositeTaskId?: boolean
    linkType?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    oppositeTask?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLink"]>

  export type TaskLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    oppositeTaskId?: boolean
    linkType?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    oppositeTask?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLink"]>

  export type TaskLinkSelectScalar = {
    id?: boolean
    taskId?: boolean
    oppositeTaskId?: boolean
    linkType?: boolean
    createdAt?: boolean
  }

  export type TaskLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "oppositeTaskId" | "linkType" | "createdAt", ExtArgs["result"]["taskLink"]>
  export type TaskLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    oppositeTask?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    oppositeTask?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    oppositeTask?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskLink"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      oppositeTask: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      oppositeTaskId: number
      linkType: $Enums.TaskLinkType
      createdAt: Date
    }, ExtArgs["result"]["taskLink"]>
    composites: {}
  }

  type TaskLinkGetPayload<S extends boolean | null | undefined | TaskLinkDefaultArgs> = $Result.GetResult<Prisma.$TaskLinkPayload, S>

  type TaskLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskLinkCountAggregateInputType | true
    }

  export interface TaskLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskLink'], meta: { name: 'TaskLink' } }
    /**
     * Find zero or one TaskLink that matches the filter.
     * @param {TaskLinkFindUniqueArgs} args - Arguments to find a TaskLink
     * @example
     * // Get one TaskLink
     * const taskLink = await prisma.taskLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskLinkFindUniqueArgs>(args: SelectSubset<T, TaskLinkFindUniqueArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskLinkFindUniqueOrThrowArgs} args - Arguments to find a TaskLink
     * @example
     * // Get one TaskLink
     * const taskLink = await prisma.taskLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkFindFirstArgs} args - Arguments to find a TaskLink
     * @example
     * // Get one TaskLink
     * const taskLink = await prisma.taskLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskLinkFindFirstArgs>(args?: SelectSubset<T, TaskLinkFindFirstArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkFindFirstOrThrowArgs} args - Arguments to find a TaskLink
     * @example
     * // Get one TaskLink
     * const taskLink = await prisma.taskLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskLinks
     * const taskLinks = await prisma.taskLink.findMany()
     * 
     * // Get first 10 TaskLinks
     * const taskLinks = await prisma.taskLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskLinkWithIdOnly = await prisma.taskLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskLinkFindManyArgs>(args?: SelectSubset<T, TaskLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskLink.
     * @param {TaskLinkCreateArgs} args - Arguments to create a TaskLink.
     * @example
     * // Create one TaskLink
     * const TaskLink = await prisma.taskLink.create({
     *   data: {
     *     // ... data to create a TaskLink
     *   }
     * })
     * 
     */
    create<T extends TaskLinkCreateArgs>(args: SelectSubset<T, TaskLinkCreateArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskLinks.
     * @param {TaskLinkCreateManyArgs} args - Arguments to create many TaskLinks.
     * @example
     * // Create many TaskLinks
     * const taskLink = await prisma.taskLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskLinkCreateManyArgs>(args?: SelectSubset<T, TaskLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskLinks and returns the data saved in the database.
     * @param {TaskLinkCreateManyAndReturnArgs} args - Arguments to create many TaskLinks.
     * @example
     * // Create many TaskLinks
     * const taskLink = await prisma.taskLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskLinks and only return the `id`
     * const taskLinkWithIdOnly = await prisma.taskLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskLink.
     * @param {TaskLinkDeleteArgs} args - Arguments to delete one TaskLink.
     * @example
     * // Delete one TaskLink
     * const TaskLink = await prisma.taskLink.delete({
     *   where: {
     *     // ... filter to delete one TaskLink
     *   }
     * })
     * 
     */
    delete<T extends TaskLinkDeleteArgs>(args: SelectSubset<T, TaskLinkDeleteArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskLink.
     * @param {TaskLinkUpdateArgs} args - Arguments to update one TaskLink.
     * @example
     * // Update one TaskLink
     * const taskLink = await prisma.taskLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskLinkUpdateArgs>(args: SelectSubset<T, TaskLinkUpdateArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskLinks.
     * @param {TaskLinkDeleteManyArgs} args - Arguments to filter TaskLinks to delete.
     * @example
     * // Delete a few TaskLinks
     * const { count } = await prisma.taskLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskLinkDeleteManyArgs>(args?: SelectSubset<T, TaskLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskLinks
     * const taskLink = await prisma.taskLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskLinkUpdateManyArgs>(args: SelectSubset<T, TaskLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLinks and returns the data updated in the database.
     * @param {TaskLinkUpdateManyAndReturnArgs} args - Arguments to update many TaskLinks.
     * @example
     * // Update many TaskLinks
     * const taskLink = await prisma.taskLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskLinks and only return the `id`
     * const taskLinkWithIdOnly = await prisma.taskLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskLink.
     * @param {TaskLinkUpsertArgs} args - Arguments to update or create a TaskLink.
     * @example
     * // Update or create a TaskLink
     * const taskLink = await prisma.taskLink.upsert({
     *   create: {
     *     // ... data to create a TaskLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskLink we want to update
     *   }
     * })
     */
    upsert<T extends TaskLinkUpsertArgs>(args: SelectSubset<T, TaskLinkUpsertArgs<ExtArgs>>): Prisma__TaskLinkClient<$Result.GetResult<Prisma.$TaskLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkCountArgs} args - Arguments to filter TaskLinks to count.
     * @example
     * // Count the number of TaskLinks
     * const count = await prisma.taskLink.count({
     *   where: {
     *     // ... the filter for the TaskLinks we want to count
     *   }
     * })
    **/
    count<T extends TaskLinkCountArgs>(
      args?: Subset<T, TaskLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskLinkAggregateArgs>(args: Subset<T, TaskLinkAggregateArgs>): Prisma.PrismaPromise<GetTaskLinkAggregateType<T>>

    /**
     * Group by TaskLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskLinkGroupByArgs['orderBy'] }
        : { orderBy?: TaskLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskLink model
   */
  readonly fields: TaskLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    oppositeTask<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskLink model
   */
  interface TaskLinkFieldRefs {
    readonly id: FieldRef<"TaskLink", 'Int'>
    readonly taskId: FieldRef<"TaskLink", 'Int'>
    readonly oppositeTaskId: FieldRef<"TaskLink", 'Int'>
    readonly linkType: FieldRef<"TaskLink", 'TaskLinkType'>
    readonly createdAt: FieldRef<"TaskLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskLink findUnique
   */
  export type TaskLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * Filter, which TaskLink to fetch.
     */
    where: TaskLinkWhereUniqueInput
  }

  /**
   * TaskLink findUniqueOrThrow
   */
  export type TaskLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * Filter, which TaskLink to fetch.
     */
    where: TaskLinkWhereUniqueInput
  }

  /**
   * TaskLink findFirst
   */
  export type TaskLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * Filter, which TaskLink to fetch.
     */
    where?: TaskLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLinks to fetch.
     */
    orderBy?: TaskLinkOrderByWithRelationInput | TaskLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLinks.
     */
    cursor?: TaskLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLinks.
     */
    distinct?: TaskLinkScalarFieldEnum | TaskLinkScalarFieldEnum[]
  }

  /**
   * TaskLink findFirstOrThrow
   */
  export type TaskLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * Filter, which TaskLink to fetch.
     */
    where?: TaskLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLinks to fetch.
     */
    orderBy?: TaskLinkOrderByWithRelationInput | TaskLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLinks.
     */
    cursor?: TaskLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLinks.
     */
    distinct?: TaskLinkScalarFieldEnum | TaskLinkScalarFieldEnum[]
  }

  /**
   * TaskLink findMany
   */
  export type TaskLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * Filter, which TaskLinks to fetch.
     */
    where?: TaskLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLinks to fetch.
     */
    orderBy?: TaskLinkOrderByWithRelationInput | TaskLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskLinks.
     */
    cursor?: TaskLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLinks.
     */
    skip?: number
    distinct?: TaskLinkScalarFieldEnum | TaskLinkScalarFieldEnum[]
  }

  /**
   * TaskLink create
   */
  export type TaskLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskLink.
     */
    data: XOR<TaskLinkCreateInput, TaskLinkUncheckedCreateInput>
  }

  /**
   * TaskLink createMany
   */
  export type TaskLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskLinks.
     */
    data: TaskLinkCreateManyInput | TaskLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskLink createManyAndReturn
   */
  export type TaskLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * The data used to create many TaskLinks.
     */
    data: TaskLinkCreateManyInput | TaskLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLink update
   */
  export type TaskLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskLink.
     */
    data: XOR<TaskLinkUpdateInput, TaskLinkUncheckedUpdateInput>
    /**
     * Choose, which TaskLink to update.
     */
    where: TaskLinkWhereUniqueInput
  }

  /**
   * TaskLink updateMany
   */
  export type TaskLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskLinks.
     */
    data: XOR<TaskLinkUpdateManyMutationInput, TaskLinkUncheckedUpdateManyInput>
    /**
     * Filter which TaskLinks to update
     */
    where?: TaskLinkWhereInput
    /**
     * Limit how many TaskLinks to update.
     */
    limit?: number
  }

  /**
   * TaskLink updateManyAndReturn
   */
  export type TaskLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * The data used to update TaskLinks.
     */
    data: XOR<TaskLinkUpdateManyMutationInput, TaskLinkUncheckedUpdateManyInput>
    /**
     * Filter which TaskLinks to update
     */
    where?: TaskLinkWhereInput
    /**
     * Limit how many TaskLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLink upsert
   */
  export type TaskLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskLink to update in case it exists.
     */
    where: TaskLinkWhereUniqueInput
    /**
     * In case the TaskLink found by the `where` argument doesn't exist, create a new TaskLink with this data.
     */
    create: XOR<TaskLinkCreateInput, TaskLinkUncheckedCreateInput>
    /**
     * In case the TaskLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskLinkUpdateInput, TaskLinkUncheckedUpdateInput>
  }

  /**
   * TaskLink delete
   */
  export type TaskLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
    /**
     * Filter which TaskLink to delete.
     */
    where: TaskLinkWhereUniqueInput
  }

  /**
   * TaskLink deleteMany
   */
  export type TaskLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLinks to delete
     */
    where?: TaskLinkWhereInput
    /**
     * Limit how many TaskLinks to delete.
     */
    limit?: number
  }

  /**
   * TaskLink without action
   */
  export type TaskLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLink
     */
    select?: TaskLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskLink
     */
    omit?: TaskLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLinkInclude<ExtArgs> | null
  }


  /**
   * Model CustomField
   */

  export type AggregateCustomField = {
    _count: CustomFieldCountAggregateOutputType | null
    _avg: CustomFieldAvgAggregateOutputType | null
    _sum: CustomFieldSumAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  export type CustomFieldAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
  }

  export type CustomFieldSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
  }

  export type CustomFieldMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    type: $Enums.CustomFieldType | null
    isRequired: boolean | null
    position: number | null
    createdAt: Date | null
  }

  export type CustomFieldMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    type: $Enums.CustomFieldType | null
    isRequired: boolean | null
    position: number | null
    createdAt: Date | null
  }

  export type CustomFieldCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    type: number
    options: number
    isRequired: number
    position: number
    createdAt: number
    _all: number
  }


  export type CustomFieldAvgAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
  }

  export type CustomFieldSumAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
  }

  export type CustomFieldMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    isRequired?: true
    position?: true
    createdAt?: true
  }

  export type CustomFieldMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    isRequired?: true
    position?: true
    createdAt?: true
  }

  export type CustomFieldCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    options?: true
    isRequired?: true
    position?: true
    createdAt?: true
    _all?: true
  }

  export type CustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomField to aggregate.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFields
    **/
    _count?: true | CustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldMaxAggregateInputType
  }

  export type GetCustomFieldAggregateType<T extends CustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomField[P]>
      : GetScalarType<T[P], AggregateCustomField[P]>
  }




  export type CustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithAggregationInput | CustomFieldOrderByWithAggregationInput[]
    by: CustomFieldScalarFieldEnum[] | CustomFieldScalarFieldEnum
    having?: CustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldCountAggregateInputType | true
    _avg?: CustomFieldAvgAggregateInputType
    _sum?: CustomFieldSumAggregateInputType
    _min?: CustomFieldMinAggregateInputType
    _max?: CustomFieldMaxAggregateInputType
  }

  export type CustomFieldGroupByOutputType = {
    id: number
    projectId: number
    name: string
    type: $Enums.CustomFieldType
    options: JsonValue | null
    isRequired: boolean
    position: number
    createdAt: Date
    _count: CustomFieldCountAggregateOutputType | null
    _avg: CustomFieldAvgAggregateOutputType | null
    _sum: CustomFieldSumAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  type GetCustomFieldGroupByPayload<T extends CustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    isRequired?: boolean
    position?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    values?: boolean | CustomField$valuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    isRequired?: boolean
    position?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    isRequired?: boolean
    position?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    isRequired?: boolean
    position?: boolean
    createdAt?: boolean
  }

  export type CustomFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "type" | "options" | "isRequired" | "position" | "createdAt", ExtArgs["result"]["customField"]>
  export type CustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    values?: boolean | CustomField$valuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CustomFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomField"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      values: Prisma.$TaskCustomValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      type: $Enums.CustomFieldType
      options: Prisma.JsonValue | null
      isRequired: boolean
      position: number
      createdAt: Date
    }, ExtArgs["result"]["customField"]>
    composites: {}
  }

  type CustomFieldGetPayload<S extends boolean | null | undefined | CustomFieldDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldPayload, S>

  type CustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomFieldCountAggregateInputType | true
    }

  export interface CustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomField'], meta: { name: 'CustomField' } }
    /**
     * Find zero or one CustomField that matches the filter.
     * @param {CustomFieldFindUniqueArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFieldFindUniqueArgs>(args: SelectSubset<T, CustomFieldFindUniqueArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomFieldFindUniqueOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFieldFindFirstArgs>(args?: SelectSubset<T, CustomFieldFindFirstArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFields
     * const customFields = await prisma.customField.findMany()
     * 
     * // Get first 10 CustomFields
     * const customFields = await prisma.customField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldWithIdOnly = await prisma.customField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFieldFindManyArgs>(args?: SelectSubset<T, CustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomField.
     * @param {CustomFieldCreateArgs} args - Arguments to create a CustomField.
     * @example
     * // Create one CustomField
     * const CustomField = await prisma.customField.create({
     *   data: {
     *     // ... data to create a CustomField
     *   }
     * })
     * 
     */
    create<T extends CustomFieldCreateArgs>(args: SelectSubset<T, CustomFieldCreateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomFields.
     * @param {CustomFieldCreateManyArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFieldCreateManyArgs>(args?: SelectSubset<T, CustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomFields and returns the data saved in the database.
     * @param {CustomFieldCreateManyAndReturnArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomFields and only return the `id`
     * const customFieldWithIdOnly = await prisma.customField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomField.
     * @param {CustomFieldDeleteArgs} args - Arguments to delete one CustomField.
     * @example
     * // Delete one CustomField
     * const CustomField = await prisma.customField.delete({
     *   where: {
     *     // ... filter to delete one CustomField
     *   }
     * })
     * 
     */
    delete<T extends CustomFieldDeleteArgs>(args: SelectSubset<T, CustomFieldDeleteArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomField.
     * @param {CustomFieldUpdateArgs} args - Arguments to update one CustomField.
     * @example
     * // Update one CustomField
     * const customField = await prisma.customField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFieldUpdateArgs>(args: SelectSubset<T, CustomFieldUpdateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomFields.
     * @param {CustomFieldDeleteManyArgs} args - Arguments to filter CustomFields to delete.
     * @example
     * // Delete a few CustomFields
     * const { count } = await prisma.customField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFieldDeleteManyArgs>(args?: SelectSubset<T, CustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFieldUpdateManyArgs>(args: SelectSubset<T, CustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields and returns the data updated in the database.
     * @param {CustomFieldUpdateManyAndReturnArgs} args - Arguments to update many CustomFields.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomFields and only return the `id`
     * const customFieldWithIdOnly = await prisma.customField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomField.
     * @param {CustomFieldUpsertArgs} args - Arguments to update or create a CustomField.
     * @example
     * // Update or create a CustomField
     * const customField = await prisma.customField.upsert({
     *   create: {
     *     // ... data to create a CustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomField we want to update
     *   }
     * })
     */
    upsert<T extends CustomFieldUpsertArgs>(args: SelectSubset<T, CustomFieldUpsertArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldCountArgs} args - Arguments to filter CustomFields to count.
     * @example
     * // Count the number of CustomFields
     * const count = await prisma.customField.count({
     *   where: {
     *     // ... the filter for the CustomFields we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldCountArgs>(
      args?: Subset<T, CustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldAggregateArgs>(args: Subset<T, CustomFieldAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldAggregateType<T>>

    /**
     * Group by CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomField model
   */
  readonly fields: CustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends CustomField$valuesArgs<ExtArgs> = {}>(args?: Subset<T, CustomField$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomField model
   */
  interface CustomFieldFieldRefs {
    readonly id: FieldRef<"CustomField", 'Int'>
    readonly projectId: FieldRef<"CustomField", 'Int'>
    readonly name: FieldRef<"CustomField", 'String'>
    readonly type: FieldRef<"CustomField", 'CustomFieldType'>
    readonly options: FieldRef<"CustomField", 'Json'>
    readonly isRequired: FieldRef<"CustomField", 'Boolean'>
    readonly position: FieldRef<"CustomField", 'Int'>
    readonly createdAt: FieldRef<"CustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomField findUnique
   */
  export type CustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findUniqueOrThrow
   */
  export type CustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findFirst
   */
  export type CustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findFirstOrThrow
   */
  export type CustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findMany
   */
  export type CustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomFields to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField create
   */
  export type CustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomField.
     */
    data: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
  }

  /**
   * CustomField createMany
   */
  export type CustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomField createManyAndReturn
   */
  export type CustomFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomField update
   */
  export type CustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomField.
     */
    data: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
    /**
     * Choose, which CustomField to update.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField updateMany
   */
  export type CustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to update.
     */
    limit?: number
  }

  /**
   * CustomField updateManyAndReturn
   */
  export type CustomFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomField upsert
   */
  export type CustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomField to update in case it exists.
     */
    where: CustomFieldWhereUniqueInput
    /**
     * In case the CustomField found by the `where` argument doesn't exist, create a new CustomField with this data.
     */
    create: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
    /**
     * In case the CustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
  }

  /**
   * CustomField delete
   */
  export type CustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter which CustomField to delete.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField deleteMany
   */
  export type CustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFields to delete
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to delete.
     */
    limit?: number
  }

  /**
   * CustomField.values
   */
  export type CustomField$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    where?: TaskCustomValueWhereInput
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    cursor?: TaskCustomValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * CustomField without action
   */
  export type CustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model TaskCustomValue
   */

  export type AggregateTaskCustomValue = {
    _count: TaskCustomValueCountAggregateOutputType | null
    _avg: TaskCustomValueAvgAggregateOutputType | null
    _sum: TaskCustomValueSumAggregateOutputType | null
    _min: TaskCustomValueMinAggregateOutputType | null
    _max: TaskCustomValueMaxAggregateOutputType | null
  }

  export type TaskCustomValueAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    customFieldId: number | null
  }

  export type TaskCustomValueSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    customFieldId: number | null
  }

  export type TaskCustomValueMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    customFieldId: number | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCustomValueMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    customFieldId: number | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCustomValueCountAggregateOutputType = {
    id: number
    taskId: number
    customFieldId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskCustomValueAvgAggregateInputType = {
    id?: true
    taskId?: true
    customFieldId?: true
  }

  export type TaskCustomValueSumAggregateInputType = {
    id?: true
    taskId?: true
    customFieldId?: true
  }

  export type TaskCustomValueMinAggregateInputType = {
    id?: true
    taskId?: true
    customFieldId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCustomValueMaxAggregateInputType = {
    id?: true
    taskId?: true
    customFieldId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCustomValueCountAggregateInputType = {
    id?: true
    taskId?: true
    customFieldId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskCustomValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCustomValue to aggregate.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCustomValues
    **/
    _count?: true | TaskCustomValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskCustomValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskCustomValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCustomValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCustomValueMaxAggregateInputType
  }

  export type GetTaskCustomValueAggregateType<T extends TaskCustomValueAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCustomValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCustomValue[P]>
      : GetScalarType<T[P], AggregateTaskCustomValue[P]>
  }




  export type TaskCustomValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomValueWhereInput
    orderBy?: TaskCustomValueOrderByWithAggregationInput | TaskCustomValueOrderByWithAggregationInput[]
    by: TaskCustomValueScalarFieldEnum[] | TaskCustomValueScalarFieldEnum
    having?: TaskCustomValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCustomValueCountAggregateInputType | true
    _avg?: TaskCustomValueAvgAggregateInputType
    _sum?: TaskCustomValueSumAggregateInputType
    _min?: TaskCustomValueMinAggregateInputType
    _max?: TaskCustomValueMaxAggregateInputType
  }

  export type TaskCustomValueGroupByOutputType = {
    id: number
    taskId: number
    customFieldId: number
    value: string
    createdAt: Date
    updatedAt: Date
    _count: TaskCustomValueCountAggregateOutputType | null
    _avg: TaskCustomValueAvgAggregateOutputType | null
    _sum: TaskCustomValueSumAggregateOutputType | null
    _min: TaskCustomValueMinAggregateOutputType | null
    _max: TaskCustomValueMaxAggregateOutputType | null
  }

  type GetTaskCustomValueGroupByPayload<T extends TaskCustomValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCustomValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCustomValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCustomValueGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCustomValueGroupByOutputType[P]>
        }
      >
    >


  export type TaskCustomValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    customFieldId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    customField?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomValue"]>

  export type TaskCustomValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    customFieldId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    customField?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomValue"]>

  export type TaskCustomValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    customFieldId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    customField?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomValue"]>

  export type TaskCustomValueSelectScalar = {
    id?: boolean
    taskId?: boolean
    customFieldId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskCustomValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "customFieldId" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["taskCustomValue"]>
  export type TaskCustomValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    customField?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }
  export type TaskCustomValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    customField?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }
  export type TaskCustomValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    customField?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }

  export type $TaskCustomValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCustomValue"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      customField: Prisma.$CustomFieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      customFieldId: number
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taskCustomValue"]>
    composites: {}
  }

  type TaskCustomValueGetPayload<S extends boolean | null | undefined | TaskCustomValueDefaultArgs> = $Result.GetResult<Prisma.$TaskCustomValuePayload, S>

  type TaskCustomValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCustomValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCustomValueCountAggregateInputType | true
    }

  export interface TaskCustomValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCustomValue'], meta: { name: 'TaskCustomValue' } }
    /**
     * Find zero or one TaskCustomValue that matches the filter.
     * @param {TaskCustomValueFindUniqueArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCustomValueFindUniqueArgs>(args: SelectSubset<T, TaskCustomValueFindUniqueArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskCustomValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCustomValueFindUniqueOrThrowArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCustomValueFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCustomValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCustomValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueFindFirstArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCustomValueFindFirstArgs>(args?: SelectSubset<T, TaskCustomValueFindFirstArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCustomValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueFindFirstOrThrowArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCustomValueFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCustomValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskCustomValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCustomValues
     * const taskCustomValues = await prisma.taskCustomValue.findMany()
     * 
     * // Get first 10 TaskCustomValues
     * const taskCustomValues = await prisma.taskCustomValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCustomValueWithIdOnly = await prisma.taskCustomValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCustomValueFindManyArgs>(args?: SelectSubset<T, TaskCustomValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskCustomValue.
     * @param {TaskCustomValueCreateArgs} args - Arguments to create a TaskCustomValue.
     * @example
     * // Create one TaskCustomValue
     * const TaskCustomValue = await prisma.taskCustomValue.create({
     *   data: {
     *     // ... data to create a TaskCustomValue
     *   }
     * })
     * 
     */
    create<T extends TaskCustomValueCreateArgs>(args: SelectSubset<T, TaskCustomValueCreateArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskCustomValues.
     * @param {TaskCustomValueCreateManyArgs} args - Arguments to create many TaskCustomValues.
     * @example
     * // Create many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCustomValueCreateManyArgs>(args?: SelectSubset<T, TaskCustomValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskCustomValues and returns the data saved in the database.
     * @param {TaskCustomValueCreateManyAndReturnArgs} args - Arguments to create many TaskCustomValues.
     * @example
     * // Create many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskCustomValues and only return the `id`
     * const taskCustomValueWithIdOnly = await prisma.taskCustomValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCustomValueCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCustomValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskCustomValue.
     * @param {TaskCustomValueDeleteArgs} args - Arguments to delete one TaskCustomValue.
     * @example
     * // Delete one TaskCustomValue
     * const TaskCustomValue = await prisma.taskCustomValue.delete({
     *   where: {
     *     // ... filter to delete one TaskCustomValue
     *   }
     * })
     * 
     */
    delete<T extends TaskCustomValueDeleteArgs>(args: SelectSubset<T, TaskCustomValueDeleteArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskCustomValue.
     * @param {TaskCustomValueUpdateArgs} args - Arguments to update one TaskCustomValue.
     * @example
     * // Update one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCustomValueUpdateArgs>(args: SelectSubset<T, TaskCustomValueUpdateArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskCustomValues.
     * @param {TaskCustomValueDeleteManyArgs} args - Arguments to filter TaskCustomValues to delete.
     * @example
     * // Delete a few TaskCustomValues
     * const { count } = await prisma.taskCustomValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCustomValueDeleteManyArgs>(args?: SelectSubset<T, TaskCustomValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCustomValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCustomValueUpdateManyArgs>(args: SelectSubset<T, TaskCustomValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCustomValues and returns the data updated in the database.
     * @param {TaskCustomValueUpdateManyAndReturnArgs} args - Arguments to update many TaskCustomValues.
     * @example
     * // Update many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskCustomValues and only return the `id`
     * const taskCustomValueWithIdOnly = await prisma.taskCustomValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskCustomValueUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskCustomValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskCustomValue.
     * @param {TaskCustomValueUpsertArgs} args - Arguments to update or create a TaskCustomValue.
     * @example
     * // Update or create a TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.upsert({
     *   create: {
     *     // ... data to create a TaskCustomValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCustomValue we want to update
     *   }
     * })
     */
    upsert<T extends TaskCustomValueUpsertArgs>(args: SelectSubset<T, TaskCustomValueUpsertArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskCustomValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueCountArgs} args - Arguments to filter TaskCustomValues to count.
     * @example
     * // Count the number of TaskCustomValues
     * const count = await prisma.taskCustomValue.count({
     *   where: {
     *     // ... the filter for the TaskCustomValues we want to count
     *   }
     * })
    **/
    count<T extends TaskCustomValueCountArgs>(
      args?: Subset<T, TaskCustomValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCustomValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCustomValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCustomValueAggregateArgs>(args: Subset<T, TaskCustomValueAggregateArgs>): Prisma.PrismaPromise<GetTaskCustomValueAggregateType<T>>

    /**
     * Group by TaskCustomValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCustomValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCustomValueGroupByArgs['orderBy'] }
        : { orderBy?: TaskCustomValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCustomValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCustomValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCustomValue model
   */
  readonly fields: TaskCustomValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCustomValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCustomValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customField<T extends CustomFieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomFieldDefaultArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskCustomValue model
   */
  interface TaskCustomValueFieldRefs {
    readonly id: FieldRef<"TaskCustomValue", 'Int'>
    readonly taskId: FieldRef<"TaskCustomValue", 'Int'>
    readonly customFieldId: FieldRef<"TaskCustomValue", 'Int'>
    readonly value: FieldRef<"TaskCustomValue", 'String'>
    readonly createdAt: FieldRef<"TaskCustomValue", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskCustomValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskCustomValue findUnique
   */
  export type TaskCustomValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue findUniqueOrThrow
   */
  export type TaskCustomValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue findFirst
   */
  export type TaskCustomValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCustomValues.
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCustomValues.
     */
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomValue findFirstOrThrow
   */
  export type TaskCustomValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCustomValues.
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCustomValues.
     */
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomValue findMany
   */
  export type TaskCustomValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValues to fetch.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCustomValues.
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomValue create
   */
  export type TaskCustomValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskCustomValue.
     */
    data: XOR<TaskCustomValueCreateInput, TaskCustomValueUncheckedCreateInput>
  }

  /**
   * TaskCustomValue createMany
   */
  export type TaskCustomValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCustomValues.
     */
    data: TaskCustomValueCreateManyInput | TaskCustomValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskCustomValue createManyAndReturn
   */
  export type TaskCustomValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * The data used to create many TaskCustomValues.
     */
    data: TaskCustomValueCreateManyInput | TaskCustomValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCustomValue update
   */
  export type TaskCustomValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskCustomValue.
     */
    data: XOR<TaskCustomValueUpdateInput, TaskCustomValueUncheckedUpdateInput>
    /**
     * Choose, which TaskCustomValue to update.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue updateMany
   */
  export type TaskCustomValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCustomValues.
     */
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyInput>
    /**
     * Filter which TaskCustomValues to update
     */
    where?: TaskCustomValueWhereInput
    /**
     * Limit how many TaskCustomValues to update.
     */
    limit?: number
  }

  /**
   * TaskCustomValue updateManyAndReturn
   */
  export type TaskCustomValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * The data used to update TaskCustomValues.
     */
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyInput>
    /**
     * Filter which TaskCustomValues to update
     */
    where?: TaskCustomValueWhereInput
    /**
     * Limit how many TaskCustomValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCustomValue upsert
   */
  export type TaskCustomValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskCustomValue to update in case it exists.
     */
    where: TaskCustomValueWhereUniqueInput
    /**
     * In case the TaskCustomValue found by the `where` argument doesn't exist, create a new TaskCustomValue with this data.
     */
    create: XOR<TaskCustomValueCreateInput, TaskCustomValueUncheckedCreateInput>
    /**
     * In case the TaskCustomValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCustomValueUpdateInput, TaskCustomValueUncheckedUpdateInput>
  }

  /**
   * TaskCustomValue delete
   */
  export type TaskCustomValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter which TaskCustomValue to delete.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue deleteMany
   */
  export type TaskCustomValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCustomValues to delete
     */
    where?: TaskCustomValueWhereInput
    /**
     * Limit how many TaskCustomValues to delete.
     */
    limit?: number
  }

  /**
   * TaskCustomValue without action
   */
  export type TaskCustomValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
  }


  /**
   * Model Sprint
   */

  export type AggregateSprint = {
    _count: SprintCountAggregateOutputType | null
    _avg: SprintAvgAggregateOutputType | null
    _sum: SprintSumAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  export type SprintAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type SprintSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type SprintMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    status: $Enums.SprintStatus | null
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SprintMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    status: $Enums.SprintStatus | null
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SprintCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    status: number
    dateStart: number
    dateEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SprintAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type SprintSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type SprintMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    status?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SprintMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    status?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SprintCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    status?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprint to aggregate.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sprints
    **/
    _count?: true | SprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SprintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SprintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SprintMaxAggregateInputType
  }

  export type GetSprintAggregateType<T extends SprintAggregateArgs> = {
        [P in keyof T & keyof AggregateSprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSprint[P]>
      : GetScalarType<T[P], AggregateSprint[P]>
  }




  export type SprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithAggregationInput | SprintOrderByWithAggregationInput[]
    by: SprintScalarFieldEnum[] | SprintScalarFieldEnum
    having?: SprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SprintCountAggregateInputType | true
    _avg?: SprintAvgAggregateInputType
    _sum?: SprintSumAggregateInputType
    _min?: SprintMinAggregateInputType
    _max?: SprintMaxAggregateInputType
  }

  export type SprintGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    status: $Enums.SprintStatus
    dateStart: Date
    dateEnd: Date
    createdAt: Date
    updatedAt: Date
    _count: SprintCountAggregateOutputType | null
    _avg: SprintAvgAggregateOutputType | null
    _sum: SprintSumAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  type GetSprintGroupByPayload<T extends SprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SprintGroupByOutputType[P]>
            : GetScalarType<T[P], SprintGroupByOutputType[P]>
        }
      >
    >


  export type SprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Sprint$tasksArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SprintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "status" | "dateStart" | "dateEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["sprint"]>
  export type SprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Sprint$tasksArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SprintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SprintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sprint"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      status: $Enums.SprintStatus
      dateStart: Date
      dateEnd: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sprint"]>
    composites: {}
  }

  type SprintGetPayload<S extends boolean | null | undefined | SprintDefaultArgs> = $Result.GetResult<Prisma.$SprintPayload, S>

  type SprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SprintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SprintCountAggregateInputType | true
    }

  export interface SprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sprint'], meta: { name: 'Sprint' } }
    /**
     * Find zero or one Sprint that matches the filter.
     * @param {SprintFindUniqueArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SprintFindUniqueArgs>(args: SelectSubset<T, SprintFindUniqueArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sprint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SprintFindUniqueOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SprintFindUniqueOrThrowArgs>(args: SelectSubset<T, SprintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SprintFindFirstArgs>(args?: SelectSubset<T, SprintFindFirstArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SprintFindFirstOrThrowArgs>(args?: SelectSubset<T, SprintFindFirstOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sprints
     * const sprints = await prisma.sprint.findMany()
     * 
     * // Get first 10 Sprints
     * const sprints = await prisma.sprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sprintWithIdOnly = await prisma.sprint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SprintFindManyArgs>(args?: SelectSubset<T, SprintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sprint.
     * @param {SprintCreateArgs} args - Arguments to create a Sprint.
     * @example
     * // Create one Sprint
     * const Sprint = await prisma.sprint.create({
     *   data: {
     *     // ... data to create a Sprint
     *   }
     * })
     * 
     */
    create<T extends SprintCreateArgs>(args: SelectSubset<T, SprintCreateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sprints.
     * @param {SprintCreateManyArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SprintCreateManyArgs>(args?: SelectSubset<T, SprintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sprints and returns the data saved in the database.
     * @param {SprintCreateManyAndReturnArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SprintCreateManyAndReturnArgs>(args?: SelectSubset<T, SprintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sprint.
     * @param {SprintDeleteArgs} args - Arguments to delete one Sprint.
     * @example
     * // Delete one Sprint
     * const Sprint = await prisma.sprint.delete({
     *   where: {
     *     // ... filter to delete one Sprint
     *   }
     * })
     * 
     */
    delete<T extends SprintDeleteArgs>(args: SelectSubset<T, SprintDeleteArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sprint.
     * @param {SprintUpdateArgs} args - Arguments to update one Sprint.
     * @example
     * // Update one Sprint
     * const sprint = await prisma.sprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SprintUpdateArgs>(args: SelectSubset<T, SprintUpdateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sprints.
     * @param {SprintDeleteManyArgs} args - Arguments to filter Sprints to delete.
     * @example
     * // Delete a few Sprints
     * const { count } = await prisma.sprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SprintDeleteManyArgs>(args?: SelectSubset<T, SprintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SprintUpdateManyArgs>(args: SelectSubset<T, SprintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints and returns the data updated in the database.
     * @param {SprintUpdateManyAndReturnArgs} args - Arguments to update many Sprints.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SprintUpdateManyAndReturnArgs>(args: SelectSubset<T, SprintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sprint.
     * @param {SprintUpsertArgs} args - Arguments to update or create a Sprint.
     * @example
     * // Update or create a Sprint
     * const sprint = await prisma.sprint.upsert({
     *   create: {
     *     // ... data to create a Sprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sprint we want to update
     *   }
     * })
     */
    upsert<T extends SprintUpsertArgs>(args: SelectSubset<T, SprintUpsertArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintCountArgs} args - Arguments to filter Sprints to count.
     * @example
     * // Count the number of Sprints
     * const count = await prisma.sprint.count({
     *   where: {
     *     // ... the filter for the Sprints we want to count
     *   }
     * })
    **/
    count<T extends SprintCountArgs>(
      args?: Subset<T, SprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SprintAggregateArgs>(args: Subset<T, SprintAggregateArgs>): Prisma.PrismaPromise<GetSprintAggregateType<T>>

    /**
     * Group by Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SprintGroupByArgs['orderBy'] }
        : { orderBy?: SprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sprint model
   */
  readonly fields: SprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Sprint$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sprint model
   */
  interface SprintFieldRefs {
    readonly id: FieldRef<"Sprint", 'Int'>
    readonly projectId: FieldRef<"Sprint", 'Int'>
    readonly name: FieldRef<"Sprint", 'String'>
    readonly description: FieldRef<"Sprint", 'String'>
    readonly status: FieldRef<"Sprint", 'SprintStatus'>
    readonly dateStart: FieldRef<"Sprint", 'DateTime'>
    readonly dateEnd: FieldRef<"Sprint", 'DateTime'>
    readonly createdAt: FieldRef<"Sprint", 'DateTime'>
    readonly updatedAt: FieldRef<"Sprint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sprint findUnique
   */
  export type SprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findUniqueOrThrow
   */
  export type SprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findFirst
   */
  export type SprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findFirstOrThrow
   */
  export type SprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findMany
   */
  export type SprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprints to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint create
   */
  export type SprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to create a Sprint.
     */
    data: XOR<SprintCreateInput, SprintUncheckedCreateInput>
  }

  /**
   * Sprint createMany
   */
  export type SprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sprint createManyAndReturn
   */
  export type SprintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint update
   */
  export type SprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to update a Sprint.
     */
    data: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
    /**
     * Choose, which Sprint to update.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint updateMany
   */
  export type SprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
  }

  /**
   * Sprint updateManyAndReturn
   */
  export type SprintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint upsert
   */
  export type SprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The filter to search for the Sprint to update in case it exists.
     */
    where: SprintWhereUniqueInput
    /**
     * In case the Sprint found by the `where` argument doesn't exist, create a new Sprint with this data.
     */
    create: XOR<SprintCreateInput, SprintUncheckedCreateInput>
    /**
     * In case the Sprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
  }

  /**
   * Sprint delete
   */
  export type SprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter which Sprint to delete.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint deleteMany
   */
  export type SprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprints to delete
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to delete.
     */
    limit?: number
  }

  /**
   * Sprint.tasks
   */
  export type Sprint$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Sprint without action
   */
  export type SprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
  }

  export type ModuleSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    position: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    color: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    color: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    color: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
  }

  export type ModuleSumAggregateInputType = {
    id?: true
    projectId?: true
    position?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    color?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    color?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    color?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    color: string
    position: number
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Module$tasksArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "color" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Module$tasksArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      color: string
      position: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Module$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Module$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'Int'>
    readonly projectId: FieldRef<"Module", 'Int'>
    readonly name: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly color: FieldRef<"Module", 'String'>
    readonly position: FieldRef<"Module", 'Int'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.tasks
   */
  export type Module$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type MilestoneSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    dateDue: Date | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    dateDue: Date | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    dateDue: number
    isCompleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MilestoneAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type MilestoneSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type MilestoneMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    dateDue?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    dateDue?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    dateDue?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _avg?: MilestoneAvgAggregateInputType
    _sum?: MilestoneSumAggregateInputType
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    dateDue: Date | null
    isCompleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    dateDue?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Milestone$tasksArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    dateDue?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    dateDue?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    dateDue?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "dateDue" | "isCompleted" | "createdAt" | "updatedAt", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Milestone$tasksArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      dateDue: Date | null
      isCompleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Milestone$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Milestone$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'Int'>
    readonly projectId: FieldRef<"Milestone", 'Int'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly dateDue: FieldRef<"Milestone", 'DateTime'>
    readonly isCompleted: FieldRef<"Milestone", 'Boolean'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
    readonly updatedAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone.tasks
   */
  export type Milestone$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model StickyNote
   */

  export type AggregateStickyNote = {
    _count: StickyNoteCountAggregateOutputType | null
    _avg: StickyNoteAvgAggregateOutputType | null
    _sum: StickyNoteSumAggregateOutputType | null
    _min: StickyNoteMinAggregateOutputType | null
    _max: StickyNoteMaxAggregateOutputType | null
  }

  export type StickyNoteAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type StickyNoteSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type StickyNoteMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    color: $Enums.StickyNoteColor | null
    isPinned: boolean | null
    visibility: $Enums.StickyVisibility | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StickyNoteMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    color: $Enums.StickyNoteColor | null
    isPinned: boolean | null
    visibility: $Enums.StickyVisibility | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StickyNoteCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    color: number
    isPinned: number
    visibility: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StickyNoteAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type StickyNoteSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type StickyNoteMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    color?: true
    isPinned?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StickyNoteMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    color?: true
    isPinned?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StickyNoteCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    color?: true
    isPinned?: true
    visibility?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StickyNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StickyNote to aggregate.
     */
    where?: StickyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNotes to fetch.
     */
    orderBy?: StickyNoteOrderByWithRelationInput | StickyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StickyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StickyNotes
    **/
    _count?: true | StickyNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StickyNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StickyNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StickyNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StickyNoteMaxAggregateInputType
  }

  export type GetStickyNoteAggregateType<T extends StickyNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateStickyNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStickyNote[P]>
      : GetScalarType<T[P], AggregateStickyNote[P]>
  }




  export type StickyNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StickyNoteWhereInput
    orderBy?: StickyNoteOrderByWithAggregationInput | StickyNoteOrderByWithAggregationInput[]
    by: StickyNoteScalarFieldEnum[] | StickyNoteScalarFieldEnum
    having?: StickyNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StickyNoteCountAggregateInputType | true
    _avg?: StickyNoteAvgAggregateInputType
    _sum?: StickyNoteSumAggregateInputType
    _min?: StickyNoteMinAggregateInputType
    _max?: StickyNoteMaxAggregateInputType
  }

  export type StickyNoteGroupByOutputType = {
    id: number
    userId: number
    title: string | null
    content: string
    color: $Enums.StickyNoteColor
    isPinned: boolean
    visibility: $Enums.StickyVisibility
    createdAt: Date
    updatedAt: Date
    _count: StickyNoteCountAggregateOutputType | null
    _avg: StickyNoteAvgAggregateOutputType | null
    _sum: StickyNoteSumAggregateOutputType | null
    _min: StickyNoteMinAggregateOutputType | null
    _max: StickyNoteMaxAggregateOutputType | null
  }

  type GetStickyNoteGroupByPayload<T extends StickyNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StickyNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StickyNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StickyNoteGroupByOutputType[P]>
            : GetScalarType<T[P], StickyNoteGroupByOutputType[P]>
        }
      >
    >


  export type StickyNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    color?: boolean
    isPinned?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    links?: boolean | StickyNote$linksArgs<ExtArgs>
    _count?: boolean | StickyNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stickyNote"]>

  export type StickyNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    color?: boolean
    isPinned?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stickyNote"]>

  export type StickyNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    color?: boolean
    isPinned?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stickyNote"]>

  export type StickyNoteSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    color?: boolean
    isPinned?: boolean
    visibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StickyNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "color" | "isPinned" | "visibility" | "createdAt" | "updatedAt", ExtArgs["result"]["stickyNote"]>
  export type StickyNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    links?: boolean | StickyNote$linksArgs<ExtArgs>
    _count?: boolean | StickyNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StickyNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StickyNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StickyNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StickyNote"
    objects: {
      links: Prisma.$StickyNoteLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string | null
      content: string
      color: $Enums.StickyNoteColor
      isPinned: boolean
      visibility: $Enums.StickyVisibility
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stickyNote"]>
    composites: {}
  }

  type StickyNoteGetPayload<S extends boolean | null | undefined | StickyNoteDefaultArgs> = $Result.GetResult<Prisma.$StickyNotePayload, S>

  type StickyNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StickyNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StickyNoteCountAggregateInputType | true
    }

  export interface StickyNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StickyNote'], meta: { name: 'StickyNote' } }
    /**
     * Find zero or one StickyNote that matches the filter.
     * @param {StickyNoteFindUniqueArgs} args - Arguments to find a StickyNote
     * @example
     * // Get one StickyNote
     * const stickyNote = await prisma.stickyNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StickyNoteFindUniqueArgs>(args: SelectSubset<T, StickyNoteFindUniqueArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StickyNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StickyNoteFindUniqueOrThrowArgs} args - Arguments to find a StickyNote
     * @example
     * // Get one StickyNote
     * const stickyNote = await prisma.stickyNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StickyNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, StickyNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StickyNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteFindFirstArgs} args - Arguments to find a StickyNote
     * @example
     * // Get one StickyNote
     * const stickyNote = await prisma.stickyNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StickyNoteFindFirstArgs>(args?: SelectSubset<T, StickyNoteFindFirstArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StickyNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteFindFirstOrThrowArgs} args - Arguments to find a StickyNote
     * @example
     * // Get one StickyNote
     * const stickyNote = await prisma.stickyNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StickyNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, StickyNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StickyNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StickyNotes
     * const stickyNotes = await prisma.stickyNote.findMany()
     * 
     * // Get first 10 StickyNotes
     * const stickyNotes = await prisma.stickyNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stickyNoteWithIdOnly = await prisma.stickyNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StickyNoteFindManyArgs>(args?: SelectSubset<T, StickyNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StickyNote.
     * @param {StickyNoteCreateArgs} args - Arguments to create a StickyNote.
     * @example
     * // Create one StickyNote
     * const StickyNote = await prisma.stickyNote.create({
     *   data: {
     *     // ... data to create a StickyNote
     *   }
     * })
     * 
     */
    create<T extends StickyNoteCreateArgs>(args: SelectSubset<T, StickyNoteCreateArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StickyNotes.
     * @param {StickyNoteCreateManyArgs} args - Arguments to create many StickyNotes.
     * @example
     * // Create many StickyNotes
     * const stickyNote = await prisma.stickyNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StickyNoteCreateManyArgs>(args?: SelectSubset<T, StickyNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StickyNotes and returns the data saved in the database.
     * @param {StickyNoteCreateManyAndReturnArgs} args - Arguments to create many StickyNotes.
     * @example
     * // Create many StickyNotes
     * const stickyNote = await prisma.stickyNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StickyNotes and only return the `id`
     * const stickyNoteWithIdOnly = await prisma.stickyNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StickyNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, StickyNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StickyNote.
     * @param {StickyNoteDeleteArgs} args - Arguments to delete one StickyNote.
     * @example
     * // Delete one StickyNote
     * const StickyNote = await prisma.stickyNote.delete({
     *   where: {
     *     // ... filter to delete one StickyNote
     *   }
     * })
     * 
     */
    delete<T extends StickyNoteDeleteArgs>(args: SelectSubset<T, StickyNoteDeleteArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StickyNote.
     * @param {StickyNoteUpdateArgs} args - Arguments to update one StickyNote.
     * @example
     * // Update one StickyNote
     * const stickyNote = await prisma.stickyNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StickyNoteUpdateArgs>(args: SelectSubset<T, StickyNoteUpdateArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StickyNotes.
     * @param {StickyNoteDeleteManyArgs} args - Arguments to filter StickyNotes to delete.
     * @example
     * // Delete a few StickyNotes
     * const { count } = await prisma.stickyNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StickyNoteDeleteManyArgs>(args?: SelectSubset<T, StickyNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StickyNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StickyNotes
     * const stickyNote = await prisma.stickyNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StickyNoteUpdateManyArgs>(args: SelectSubset<T, StickyNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StickyNotes and returns the data updated in the database.
     * @param {StickyNoteUpdateManyAndReturnArgs} args - Arguments to update many StickyNotes.
     * @example
     * // Update many StickyNotes
     * const stickyNote = await prisma.stickyNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StickyNotes and only return the `id`
     * const stickyNoteWithIdOnly = await prisma.stickyNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StickyNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, StickyNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StickyNote.
     * @param {StickyNoteUpsertArgs} args - Arguments to update or create a StickyNote.
     * @example
     * // Update or create a StickyNote
     * const stickyNote = await prisma.stickyNote.upsert({
     *   create: {
     *     // ... data to create a StickyNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StickyNote we want to update
     *   }
     * })
     */
    upsert<T extends StickyNoteUpsertArgs>(args: SelectSubset<T, StickyNoteUpsertArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StickyNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteCountArgs} args - Arguments to filter StickyNotes to count.
     * @example
     * // Count the number of StickyNotes
     * const count = await prisma.stickyNote.count({
     *   where: {
     *     // ... the filter for the StickyNotes we want to count
     *   }
     * })
    **/
    count<T extends StickyNoteCountArgs>(
      args?: Subset<T, StickyNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StickyNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StickyNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StickyNoteAggregateArgs>(args: Subset<T, StickyNoteAggregateArgs>): Prisma.PrismaPromise<GetStickyNoteAggregateType<T>>

    /**
     * Group by StickyNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StickyNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StickyNoteGroupByArgs['orderBy'] }
        : { orderBy?: StickyNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StickyNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStickyNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StickyNote model
   */
  readonly fields: StickyNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StickyNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StickyNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    links<T extends StickyNote$linksArgs<ExtArgs> = {}>(args?: Subset<T, StickyNote$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StickyNote model
   */
  interface StickyNoteFieldRefs {
    readonly id: FieldRef<"StickyNote", 'Int'>
    readonly userId: FieldRef<"StickyNote", 'Int'>
    readonly title: FieldRef<"StickyNote", 'String'>
    readonly content: FieldRef<"StickyNote", 'String'>
    readonly color: FieldRef<"StickyNote", 'StickyNoteColor'>
    readonly isPinned: FieldRef<"StickyNote", 'Boolean'>
    readonly visibility: FieldRef<"StickyNote", 'StickyVisibility'>
    readonly createdAt: FieldRef<"StickyNote", 'DateTime'>
    readonly updatedAt: FieldRef<"StickyNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StickyNote findUnique
   */
  export type StickyNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * Filter, which StickyNote to fetch.
     */
    where: StickyNoteWhereUniqueInput
  }

  /**
   * StickyNote findUniqueOrThrow
   */
  export type StickyNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * Filter, which StickyNote to fetch.
     */
    where: StickyNoteWhereUniqueInput
  }

  /**
   * StickyNote findFirst
   */
  export type StickyNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * Filter, which StickyNote to fetch.
     */
    where?: StickyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNotes to fetch.
     */
    orderBy?: StickyNoteOrderByWithRelationInput | StickyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StickyNotes.
     */
    cursor?: StickyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StickyNotes.
     */
    distinct?: StickyNoteScalarFieldEnum | StickyNoteScalarFieldEnum[]
  }

  /**
   * StickyNote findFirstOrThrow
   */
  export type StickyNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * Filter, which StickyNote to fetch.
     */
    where?: StickyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNotes to fetch.
     */
    orderBy?: StickyNoteOrderByWithRelationInput | StickyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StickyNotes.
     */
    cursor?: StickyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StickyNotes.
     */
    distinct?: StickyNoteScalarFieldEnum | StickyNoteScalarFieldEnum[]
  }

  /**
   * StickyNote findMany
   */
  export type StickyNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * Filter, which StickyNotes to fetch.
     */
    where?: StickyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNotes to fetch.
     */
    orderBy?: StickyNoteOrderByWithRelationInput | StickyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StickyNotes.
     */
    cursor?: StickyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNotes.
     */
    skip?: number
    distinct?: StickyNoteScalarFieldEnum | StickyNoteScalarFieldEnum[]
  }

  /**
   * StickyNote create
   */
  export type StickyNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a StickyNote.
     */
    data: XOR<StickyNoteCreateInput, StickyNoteUncheckedCreateInput>
  }

  /**
   * StickyNote createMany
   */
  export type StickyNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StickyNotes.
     */
    data: StickyNoteCreateManyInput | StickyNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StickyNote createManyAndReturn
   */
  export type StickyNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * The data used to create many StickyNotes.
     */
    data: StickyNoteCreateManyInput | StickyNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StickyNote update
   */
  export type StickyNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a StickyNote.
     */
    data: XOR<StickyNoteUpdateInput, StickyNoteUncheckedUpdateInput>
    /**
     * Choose, which StickyNote to update.
     */
    where: StickyNoteWhereUniqueInput
  }

  /**
   * StickyNote updateMany
   */
  export type StickyNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StickyNotes.
     */
    data: XOR<StickyNoteUpdateManyMutationInput, StickyNoteUncheckedUpdateManyInput>
    /**
     * Filter which StickyNotes to update
     */
    where?: StickyNoteWhereInput
    /**
     * Limit how many StickyNotes to update.
     */
    limit?: number
  }

  /**
   * StickyNote updateManyAndReturn
   */
  export type StickyNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * The data used to update StickyNotes.
     */
    data: XOR<StickyNoteUpdateManyMutationInput, StickyNoteUncheckedUpdateManyInput>
    /**
     * Filter which StickyNotes to update
     */
    where?: StickyNoteWhereInput
    /**
     * Limit how many StickyNotes to update.
     */
    limit?: number
  }

  /**
   * StickyNote upsert
   */
  export type StickyNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the StickyNote to update in case it exists.
     */
    where: StickyNoteWhereUniqueInput
    /**
     * In case the StickyNote found by the `where` argument doesn't exist, create a new StickyNote with this data.
     */
    create: XOR<StickyNoteCreateInput, StickyNoteUncheckedCreateInput>
    /**
     * In case the StickyNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StickyNoteUpdateInput, StickyNoteUncheckedUpdateInput>
  }

  /**
   * StickyNote delete
   */
  export type StickyNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
    /**
     * Filter which StickyNote to delete.
     */
    where: StickyNoteWhereUniqueInput
  }

  /**
   * StickyNote deleteMany
   */
  export type StickyNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StickyNotes to delete
     */
    where?: StickyNoteWhereInput
    /**
     * Limit how many StickyNotes to delete.
     */
    limit?: number
  }

  /**
   * StickyNote.links
   */
  export type StickyNote$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    where?: StickyNoteLinkWhereInput
    orderBy?: StickyNoteLinkOrderByWithRelationInput | StickyNoteLinkOrderByWithRelationInput[]
    cursor?: StickyNoteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StickyNoteLinkScalarFieldEnum | StickyNoteLinkScalarFieldEnum[]
  }

  /**
   * StickyNote without action
   */
  export type StickyNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNote
     */
    select?: StickyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNote
     */
    omit?: StickyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteInclude<ExtArgs> | null
  }


  /**
   * Model StickyNoteLink
   */

  export type AggregateStickyNoteLink = {
    _count: StickyNoteLinkCountAggregateOutputType | null
    _avg: StickyNoteLinkAvgAggregateOutputType | null
    _sum: StickyNoteLinkSumAggregateOutputType | null
    _min: StickyNoteLinkMinAggregateOutputType | null
    _max: StickyNoteLinkMaxAggregateOutputType | null
  }

  export type StickyNoteLinkAvgAggregateOutputType = {
    id: number | null
    stickyNoteId: number | null
    entityId: number | null
  }

  export type StickyNoteLinkSumAggregateOutputType = {
    id: number | null
    stickyNoteId: number | null
    entityId: number | null
  }

  export type StickyNoteLinkMinAggregateOutputType = {
    id: number | null
    stickyNoteId: number | null
    entityType: $Enums.StickyLinkType | null
    entityId: number | null
    createdAt: Date | null
  }

  export type StickyNoteLinkMaxAggregateOutputType = {
    id: number | null
    stickyNoteId: number | null
    entityType: $Enums.StickyLinkType | null
    entityId: number | null
    createdAt: Date | null
  }

  export type StickyNoteLinkCountAggregateOutputType = {
    id: number
    stickyNoteId: number
    entityType: number
    entityId: number
    createdAt: number
    _all: number
  }


  export type StickyNoteLinkAvgAggregateInputType = {
    id?: true
    stickyNoteId?: true
    entityId?: true
  }

  export type StickyNoteLinkSumAggregateInputType = {
    id?: true
    stickyNoteId?: true
    entityId?: true
  }

  export type StickyNoteLinkMinAggregateInputType = {
    id?: true
    stickyNoteId?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type StickyNoteLinkMaxAggregateInputType = {
    id?: true
    stickyNoteId?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type StickyNoteLinkCountAggregateInputType = {
    id?: true
    stickyNoteId?: true
    entityType?: true
    entityId?: true
    createdAt?: true
    _all?: true
  }

  export type StickyNoteLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StickyNoteLink to aggregate.
     */
    where?: StickyNoteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNoteLinks to fetch.
     */
    orderBy?: StickyNoteLinkOrderByWithRelationInput | StickyNoteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StickyNoteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNoteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNoteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StickyNoteLinks
    **/
    _count?: true | StickyNoteLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StickyNoteLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StickyNoteLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StickyNoteLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StickyNoteLinkMaxAggregateInputType
  }

  export type GetStickyNoteLinkAggregateType<T extends StickyNoteLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateStickyNoteLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStickyNoteLink[P]>
      : GetScalarType<T[P], AggregateStickyNoteLink[P]>
  }




  export type StickyNoteLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StickyNoteLinkWhereInput
    orderBy?: StickyNoteLinkOrderByWithAggregationInput | StickyNoteLinkOrderByWithAggregationInput[]
    by: StickyNoteLinkScalarFieldEnum[] | StickyNoteLinkScalarFieldEnum
    having?: StickyNoteLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StickyNoteLinkCountAggregateInputType | true
    _avg?: StickyNoteLinkAvgAggregateInputType
    _sum?: StickyNoteLinkSumAggregateInputType
    _min?: StickyNoteLinkMinAggregateInputType
    _max?: StickyNoteLinkMaxAggregateInputType
  }

  export type StickyNoteLinkGroupByOutputType = {
    id: number
    stickyNoteId: number
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt: Date
    _count: StickyNoteLinkCountAggregateOutputType | null
    _avg: StickyNoteLinkAvgAggregateOutputType | null
    _sum: StickyNoteLinkSumAggregateOutputType | null
    _min: StickyNoteLinkMinAggregateOutputType | null
    _max: StickyNoteLinkMaxAggregateOutputType | null
  }

  type GetStickyNoteLinkGroupByPayload<T extends StickyNoteLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StickyNoteLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StickyNoteLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StickyNoteLinkGroupByOutputType[P]>
            : GetScalarType<T[P], StickyNoteLinkGroupByOutputType[P]>
        }
      >
    >


  export type StickyNoteLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stickyNoteId?: boolean
    entityType?: boolean
    entityId?: boolean
    createdAt?: boolean
    stickyNote?: boolean | StickyNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stickyNoteLink"]>

  export type StickyNoteLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stickyNoteId?: boolean
    entityType?: boolean
    entityId?: boolean
    createdAt?: boolean
    stickyNote?: boolean | StickyNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stickyNoteLink"]>

  export type StickyNoteLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stickyNoteId?: boolean
    entityType?: boolean
    entityId?: boolean
    createdAt?: boolean
    stickyNote?: boolean | StickyNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stickyNoteLink"]>

  export type StickyNoteLinkSelectScalar = {
    id?: boolean
    stickyNoteId?: boolean
    entityType?: boolean
    entityId?: boolean
    createdAt?: boolean
  }

  export type StickyNoteLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stickyNoteId" | "entityType" | "entityId" | "createdAt", ExtArgs["result"]["stickyNoteLink"]>
  export type StickyNoteLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stickyNote?: boolean | StickyNoteDefaultArgs<ExtArgs>
  }
  export type StickyNoteLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stickyNote?: boolean | StickyNoteDefaultArgs<ExtArgs>
  }
  export type StickyNoteLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stickyNote?: boolean | StickyNoteDefaultArgs<ExtArgs>
  }

  export type $StickyNoteLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StickyNoteLink"
    objects: {
      stickyNote: Prisma.$StickyNotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stickyNoteId: number
      entityType: $Enums.StickyLinkType
      entityId: number
      createdAt: Date
    }, ExtArgs["result"]["stickyNoteLink"]>
    composites: {}
  }

  type StickyNoteLinkGetPayload<S extends boolean | null | undefined | StickyNoteLinkDefaultArgs> = $Result.GetResult<Prisma.$StickyNoteLinkPayload, S>

  type StickyNoteLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StickyNoteLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StickyNoteLinkCountAggregateInputType | true
    }

  export interface StickyNoteLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StickyNoteLink'], meta: { name: 'StickyNoteLink' } }
    /**
     * Find zero or one StickyNoteLink that matches the filter.
     * @param {StickyNoteLinkFindUniqueArgs} args - Arguments to find a StickyNoteLink
     * @example
     * // Get one StickyNoteLink
     * const stickyNoteLink = await prisma.stickyNoteLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StickyNoteLinkFindUniqueArgs>(args: SelectSubset<T, StickyNoteLinkFindUniqueArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StickyNoteLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StickyNoteLinkFindUniqueOrThrowArgs} args - Arguments to find a StickyNoteLink
     * @example
     * // Get one StickyNoteLink
     * const stickyNoteLink = await prisma.stickyNoteLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StickyNoteLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, StickyNoteLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StickyNoteLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkFindFirstArgs} args - Arguments to find a StickyNoteLink
     * @example
     * // Get one StickyNoteLink
     * const stickyNoteLink = await prisma.stickyNoteLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StickyNoteLinkFindFirstArgs>(args?: SelectSubset<T, StickyNoteLinkFindFirstArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StickyNoteLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkFindFirstOrThrowArgs} args - Arguments to find a StickyNoteLink
     * @example
     * // Get one StickyNoteLink
     * const stickyNoteLink = await prisma.stickyNoteLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StickyNoteLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, StickyNoteLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StickyNoteLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StickyNoteLinks
     * const stickyNoteLinks = await prisma.stickyNoteLink.findMany()
     * 
     * // Get first 10 StickyNoteLinks
     * const stickyNoteLinks = await prisma.stickyNoteLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stickyNoteLinkWithIdOnly = await prisma.stickyNoteLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StickyNoteLinkFindManyArgs>(args?: SelectSubset<T, StickyNoteLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StickyNoteLink.
     * @param {StickyNoteLinkCreateArgs} args - Arguments to create a StickyNoteLink.
     * @example
     * // Create one StickyNoteLink
     * const StickyNoteLink = await prisma.stickyNoteLink.create({
     *   data: {
     *     // ... data to create a StickyNoteLink
     *   }
     * })
     * 
     */
    create<T extends StickyNoteLinkCreateArgs>(args: SelectSubset<T, StickyNoteLinkCreateArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StickyNoteLinks.
     * @param {StickyNoteLinkCreateManyArgs} args - Arguments to create many StickyNoteLinks.
     * @example
     * // Create many StickyNoteLinks
     * const stickyNoteLink = await prisma.stickyNoteLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StickyNoteLinkCreateManyArgs>(args?: SelectSubset<T, StickyNoteLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StickyNoteLinks and returns the data saved in the database.
     * @param {StickyNoteLinkCreateManyAndReturnArgs} args - Arguments to create many StickyNoteLinks.
     * @example
     * // Create many StickyNoteLinks
     * const stickyNoteLink = await prisma.stickyNoteLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StickyNoteLinks and only return the `id`
     * const stickyNoteLinkWithIdOnly = await prisma.stickyNoteLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StickyNoteLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, StickyNoteLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StickyNoteLink.
     * @param {StickyNoteLinkDeleteArgs} args - Arguments to delete one StickyNoteLink.
     * @example
     * // Delete one StickyNoteLink
     * const StickyNoteLink = await prisma.stickyNoteLink.delete({
     *   where: {
     *     // ... filter to delete one StickyNoteLink
     *   }
     * })
     * 
     */
    delete<T extends StickyNoteLinkDeleteArgs>(args: SelectSubset<T, StickyNoteLinkDeleteArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StickyNoteLink.
     * @param {StickyNoteLinkUpdateArgs} args - Arguments to update one StickyNoteLink.
     * @example
     * // Update one StickyNoteLink
     * const stickyNoteLink = await prisma.stickyNoteLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StickyNoteLinkUpdateArgs>(args: SelectSubset<T, StickyNoteLinkUpdateArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StickyNoteLinks.
     * @param {StickyNoteLinkDeleteManyArgs} args - Arguments to filter StickyNoteLinks to delete.
     * @example
     * // Delete a few StickyNoteLinks
     * const { count } = await prisma.stickyNoteLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StickyNoteLinkDeleteManyArgs>(args?: SelectSubset<T, StickyNoteLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StickyNoteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StickyNoteLinks
     * const stickyNoteLink = await prisma.stickyNoteLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StickyNoteLinkUpdateManyArgs>(args: SelectSubset<T, StickyNoteLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StickyNoteLinks and returns the data updated in the database.
     * @param {StickyNoteLinkUpdateManyAndReturnArgs} args - Arguments to update many StickyNoteLinks.
     * @example
     * // Update many StickyNoteLinks
     * const stickyNoteLink = await prisma.stickyNoteLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StickyNoteLinks and only return the `id`
     * const stickyNoteLinkWithIdOnly = await prisma.stickyNoteLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StickyNoteLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, StickyNoteLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StickyNoteLink.
     * @param {StickyNoteLinkUpsertArgs} args - Arguments to update or create a StickyNoteLink.
     * @example
     * // Update or create a StickyNoteLink
     * const stickyNoteLink = await prisma.stickyNoteLink.upsert({
     *   create: {
     *     // ... data to create a StickyNoteLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StickyNoteLink we want to update
     *   }
     * })
     */
    upsert<T extends StickyNoteLinkUpsertArgs>(args: SelectSubset<T, StickyNoteLinkUpsertArgs<ExtArgs>>): Prisma__StickyNoteLinkClient<$Result.GetResult<Prisma.$StickyNoteLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StickyNoteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkCountArgs} args - Arguments to filter StickyNoteLinks to count.
     * @example
     * // Count the number of StickyNoteLinks
     * const count = await prisma.stickyNoteLink.count({
     *   where: {
     *     // ... the filter for the StickyNoteLinks we want to count
     *   }
     * })
    **/
    count<T extends StickyNoteLinkCountArgs>(
      args?: Subset<T, StickyNoteLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StickyNoteLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StickyNoteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StickyNoteLinkAggregateArgs>(args: Subset<T, StickyNoteLinkAggregateArgs>): Prisma.PrismaPromise<GetStickyNoteLinkAggregateType<T>>

    /**
     * Group by StickyNoteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StickyNoteLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StickyNoteLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StickyNoteLinkGroupByArgs['orderBy'] }
        : { orderBy?: StickyNoteLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StickyNoteLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStickyNoteLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StickyNoteLink model
   */
  readonly fields: StickyNoteLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StickyNoteLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StickyNoteLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stickyNote<T extends StickyNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StickyNoteDefaultArgs<ExtArgs>>): Prisma__StickyNoteClient<$Result.GetResult<Prisma.$StickyNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StickyNoteLink model
   */
  interface StickyNoteLinkFieldRefs {
    readonly id: FieldRef<"StickyNoteLink", 'Int'>
    readonly stickyNoteId: FieldRef<"StickyNoteLink", 'Int'>
    readonly entityType: FieldRef<"StickyNoteLink", 'StickyLinkType'>
    readonly entityId: FieldRef<"StickyNoteLink", 'Int'>
    readonly createdAt: FieldRef<"StickyNoteLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StickyNoteLink findUnique
   */
  export type StickyNoteLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * Filter, which StickyNoteLink to fetch.
     */
    where: StickyNoteLinkWhereUniqueInput
  }

  /**
   * StickyNoteLink findUniqueOrThrow
   */
  export type StickyNoteLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * Filter, which StickyNoteLink to fetch.
     */
    where: StickyNoteLinkWhereUniqueInput
  }

  /**
   * StickyNoteLink findFirst
   */
  export type StickyNoteLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * Filter, which StickyNoteLink to fetch.
     */
    where?: StickyNoteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNoteLinks to fetch.
     */
    orderBy?: StickyNoteLinkOrderByWithRelationInput | StickyNoteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StickyNoteLinks.
     */
    cursor?: StickyNoteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNoteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNoteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StickyNoteLinks.
     */
    distinct?: StickyNoteLinkScalarFieldEnum | StickyNoteLinkScalarFieldEnum[]
  }

  /**
   * StickyNoteLink findFirstOrThrow
   */
  export type StickyNoteLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * Filter, which StickyNoteLink to fetch.
     */
    where?: StickyNoteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNoteLinks to fetch.
     */
    orderBy?: StickyNoteLinkOrderByWithRelationInput | StickyNoteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StickyNoteLinks.
     */
    cursor?: StickyNoteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNoteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNoteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StickyNoteLinks.
     */
    distinct?: StickyNoteLinkScalarFieldEnum | StickyNoteLinkScalarFieldEnum[]
  }

  /**
   * StickyNoteLink findMany
   */
  export type StickyNoteLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * Filter, which StickyNoteLinks to fetch.
     */
    where?: StickyNoteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StickyNoteLinks to fetch.
     */
    orderBy?: StickyNoteLinkOrderByWithRelationInput | StickyNoteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StickyNoteLinks.
     */
    cursor?: StickyNoteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StickyNoteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StickyNoteLinks.
     */
    skip?: number
    distinct?: StickyNoteLinkScalarFieldEnum | StickyNoteLinkScalarFieldEnum[]
  }

  /**
   * StickyNoteLink create
   */
  export type StickyNoteLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a StickyNoteLink.
     */
    data: XOR<StickyNoteLinkCreateInput, StickyNoteLinkUncheckedCreateInput>
  }

  /**
   * StickyNoteLink createMany
   */
  export type StickyNoteLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StickyNoteLinks.
     */
    data: StickyNoteLinkCreateManyInput | StickyNoteLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StickyNoteLink createManyAndReturn
   */
  export type StickyNoteLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * The data used to create many StickyNoteLinks.
     */
    data: StickyNoteLinkCreateManyInput | StickyNoteLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StickyNoteLink update
   */
  export type StickyNoteLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a StickyNoteLink.
     */
    data: XOR<StickyNoteLinkUpdateInput, StickyNoteLinkUncheckedUpdateInput>
    /**
     * Choose, which StickyNoteLink to update.
     */
    where: StickyNoteLinkWhereUniqueInput
  }

  /**
   * StickyNoteLink updateMany
   */
  export type StickyNoteLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StickyNoteLinks.
     */
    data: XOR<StickyNoteLinkUpdateManyMutationInput, StickyNoteLinkUncheckedUpdateManyInput>
    /**
     * Filter which StickyNoteLinks to update
     */
    where?: StickyNoteLinkWhereInput
    /**
     * Limit how many StickyNoteLinks to update.
     */
    limit?: number
  }

  /**
   * StickyNoteLink updateManyAndReturn
   */
  export type StickyNoteLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * The data used to update StickyNoteLinks.
     */
    data: XOR<StickyNoteLinkUpdateManyMutationInput, StickyNoteLinkUncheckedUpdateManyInput>
    /**
     * Filter which StickyNoteLinks to update
     */
    where?: StickyNoteLinkWhereInput
    /**
     * Limit how many StickyNoteLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StickyNoteLink upsert
   */
  export type StickyNoteLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the StickyNoteLink to update in case it exists.
     */
    where: StickyNoteLinkWhereUniqueInput
    /**
     * In case the StickyNoteLink found by the `where` argument doesn't exist, create a new StickyNoteLink with this data.
     */
    create: XOR<StickyNoteLinkCreateInput, StickyNoteLinkUncheckedCreateInput>
    /**
     * In case the StickyNoteLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StickyNoteLinkUpdateInput, StickyNoteLinkUncheckedUpdateInput>
  }

  /**
   * StickyNoteLink delete
   */
  export type StickyNoteLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
    /**
     * Filter which StickyNoteLink to delete.
     */
    where: StickyNoteLinkWhereUniqueInput
  }

  /**
   * StickyNoteLink deleteMany
   */
  export type StickyNoteLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StickyNoteLinks to delete
     */
    where?: StickyNoteLinkWhereInput
    /**
     * Limit how many StickyNoteLinks to delete.
     */
    limit?: number
  }

  /**
   * StickyNoteLink without action
   */
  export type StickyNoteLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StickyNoteLink
     */
    select?: StickyNoteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StickyNoteLink
     */
    omit?: StickyNoteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StickyNoteLinkInclude<ExtArgs> | null
  }


  /**
   * Model ProjectGroup
   */

  export type AggregateProjectGroup = {
    _count: ProjectGroupCountAggregateOutputType | null
    _avg: ProjectGroupAvgAggregateOutputType | null
    _sum: ProjectGroupSumAggregateOutputType | null
    _min: ProjectGroupMinAggregateOutputType | null
    _max: ProjectGroupMaxAggregateOutputType | null
  }

  export type ProjectGroupAvgAggregateOutputType = {
    id: number | null
    workspaceId: number | null
  }

  export type ProjectGroupSumAggregateOutputType = {
    id: number | null
    workspaceId: number | null
  }

  export type ProjectGroupMinAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    name: string | null
    description: string | null
    color: string | null
    status: $Enums.ProjectGroupStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectGroupMaxAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    name: string | null
    description: string | null
    color: string | null
    status: $Enums.ProjectGroupStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectGroupCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    color: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectGroupAvgAggregateInputType = {
    id?: true
    workspaceId?: true
  }

  export type ProjectGroupSumAggregateInputType = {
    id?: true
    workspaceId?: true
  }

  export type ProjectGroupMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    color?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectGroupMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    color?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectGroupCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    color?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGroup to aggregate.
     */
    where?: ProjectGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroups to fetch.
     */
    orderBy?: ProjectGroupOrderByWithRelationInput | ProjectGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectGroups
    **/
    _count?: true | ProjectGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectGroupMaxAggregateInputType
  }

  export type GetProjectGroupAggregateType<T extends ProjectGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectGroup[P]>
      : GetScalarType<T[P], AggregateProjectGroup[P]>
  }




  export type ProjectGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGroupWhereInput
    orderBy?: ProjectGroupOrderByWithAggregationInput | ProjectGroupOrderByWithAggregationInput[]
    by: ProjectGroupScalarFieldEnum[] | ProjectGroupScalarFieldEnum
    having?: ProjectGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectGroupCountAggregateInputType | true
    _avg?: ProjectGroupAvgAggregateInputType
    _sum?: ProjectGroupSumAggregateInputType
    _min?: ProjectGroupMinAggregateInputType
    _max?: ProjectGroupMaxAggregateInputType
  }

  export type ProjectGroupGroupByOutputType = {
    id: number
    workspaceId: number
    name: string
    description: string | null
    color: string
    status: $Enums.ProjectGroupStatus
    createdAt: Date
    updatedAt: Date
    _count: ProjectGroupCountAggregateOutputType | null
    _avg: ProjectGroupAvgAggregateOutputType | null
    _sum: ProjectGroupSumAggregateOutputType | null
    _min: ProjectGroupMinAggregateOutputType | null
    _max: ProjectGroupMaxAggregateOutputType | null
  }

  type GetProjectGroupGroupByPayload<T extends ProjectGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupGroupByOutputType[P]>
        }
      >
    >


  export type ProjectGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    projects?: boolean | ProjectGroup$projectsArgs<ExtArgs>
    _count?: boolean | ProjectGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGroup"]>

  export type ProjectGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGroup"]>

  export type ProjectGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGroup"]>

  export type ProjectGroupSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "color" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["projectGroup"]>
  export type ProjectGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    projects?: boolean | ProjectGroup$projectsArgs<ExtArgs>
    _count?: boolean | ProjectGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProjectGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ProjectGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectGroup"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      projects: Prisma.$ProjectGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workspaceId: number
      name: string
      description: string | null
      color: string
      status: $Enums.ProjectGroupStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectGroup"]>
    composites: {}
  }

  type ProjectGroupGetPayload<S extends boolean | null | undefined | ProjectGroupDefaultArgs> = $Result.GetResult<Prisma.$ProjectGroupPayload, S>

  type ProjectGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectGroupCountAggregateInputType | true
    }

  export interface ProjectGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectGroup'], meta: { name: 'ProjectGroup' } }
    /**
     * Find zero or one ProjectGroup that matches the filter.
     * @param {ProjectGroupFindUniqueArgs} args - Arguments to find a ProjectGroup
     * @example
     * // Get one ProjectGroup
     * const projectGroup = await prisma.projectGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectGroupFindUniqueArgs>(args: SelectSubset<T, ProjectGroupFindUniqueArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectGroupFindUniqueOrThrowArgs} args - Arguments to find a ProjectGroup
     * @example
     * // Get one ProjectGroup
     * const projectGroup = await prisma.projectGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupFindFirstArgs} args - Arguments to find a ProjectGroup
     * @example
     * // Get one ProjectGroup
     * const projectGroup = await prisma.projectGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectGroupFindFirstArgs>(args?: SelectSubset<T, ProjectGroupFindFirstArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupFindFirstOrThrowArgs} args - Arguments to find a ProjectGroup
     * @example
     * // Get one ProjectGroup
     * const projectGroup = await prisma.projectGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectGroups
     * const projectGroups = await prisma.projectGroup.findMany()
     * 
     * // Get first 10 ProjectGroups
     * const projectGroups = await prisma.projectGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectGroupWithIdOnly = await prisma.projectGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectGroupFindManyArgs>(args?: SelectSubset<T, ProjectGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectGroup.
     * @param {ProjectGroupCreateArgs} args - Arguments to create a ProjectGroup.
     * @example
     * // Create one ProjectGroup
     * const ProjectGroup = await prisma.projectGroup.create({
     *   data: {
     *     // ... data to create a ProjectGroup
     *   }
     * })
     * 
     */
    create<T extends ProjectGroupCreateArgs>(args: SelectSubset<T, ProjectGroupCreateArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectGroups.
     * @param {ProjectGroupCreateManyArgs} args - Arguments to create many ProjectGroups.
     * @example
     * // Create many ProjectGroups
     * const projectGroup = await prisma.projectGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectGroupCreateManyArgs>(args?: SelectSubset<T, ProjectGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectGroups and returns the data saved in the database.
     * @param {ProjectGroupCreateManyAndReturnArgs} args - Arguments to create many ProjectGroups.
     * @example
     * // Create many ProjectGroups
     * const projectGroup = await prisma.projectGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectGroups and only return the `id`
     * const projectGroupWithIdOnly = await prisma.projectGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectGroup.
     * @param {ProjectGroupDeleteArgs} args - Arguments to delete one ProjectGroup.
     * @example
     * // Delete one ProjectGroup
     * const ProjectGroup = await prisma.projectGroup.delete({
     *   where: {
     *     // ... filter to delete one ProjectGroup
     *   }
     * })
     * 
     */
    delete<T extends ProjectGroupDeleteArgs>(args: SelectSubset<T, ProjectGroupDeleteArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectGroup.
     * @param {ProjectGroupUpdateArgs} args - Arguments to update one ProjectGroup.
     * @example
     * // Update one ProjectGroup
     * const projectGroup = await prisma.projectGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectGroupUpdateArgs>(args: SelectSubset<T, ProjectGroupUpdateArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectGroups.
     * @param {ProjectGroupDeleteManyArgs} args - Arguments to filter ProjectGroups to delete.
     * @example
     * // Delete a few ProjectGroups
     * const { count } = await prisma.projectGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectGroupDeleteManyArgs>(args?: SelectSubset<T, ProjectGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectGroups
     * const projectGroup = await prisma.projectGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectGroupUpdateManyArgs>(args: SelectSubset<T, ProjectGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGroups and returns the data updated in the database.
     * @param {ProjectGroupUpdateManyAndReturnArgs} args - Arguments to update many ProjectGroups.
     * @example
     * // Update many ProjectGroups
     * const projectGroup = await prisma.projectGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectGroups and only return the `id`
     * const projectGroupWithIdOnly = await prisma.projectGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectGroup.
     * @param {ProjectGroupUpsertArgs} args - Arguments to update or create a ProjectGroup.
     * @example
     * // Update or create a ProjectGroup
     * const projectGroup = await prisma.projectGroup.upsert({
     *   create: {
     *     // ... data to create a ProjectGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectGroup we want to update
     *   }
     * })
     */
    upsert<T extends ProjectGroupUpsertArgs>(args: SelectSubset<T, ProjectGroupUpsertArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupCountArgs} args - Arguments to filter ProjectGroups to count.
     * @example
     * // Count the number of ProjectGroups
     * const count = await prisma.projectGroup.count({
     *   where: {
     *     // ... the filter for the ProjectGroups we want to count
     *   }
     * })
    **/
    count<T extends ProjectGroupCountArgs>(
      args?: Subset<T, ProjectGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectGroupAggregateArgs>(args: Subset<T, ProjectGroupAggregateArgs>): Prisma.PrismaPromise<GetProjectGroupAggregateType<T>>

    /**
     * Group by ProjectGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectGroup model
   */
  readonly fields: ProjectGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends ProjectGroup$projectsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectGroup$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectGroup model
   */
  interface ProjectGroupFieldRefs {
    readonly id: FieldRef<"ProjectGroup", 'Int'>
    readonly workspaceId: FieldRef<"ProjectGroup", 'Int'>
    readonly name: FieldRef<"ProjectGroup", 'String'>
    readonly description: FieldRef<"ProjectGroup", 'String'>
    readonly color: FieldRef<"ProjectGroup", 'String'>
    readonly status: FieldRef<"ProjectGroup", 'ProjectGroupStatus'>
    readonly createdAt: FieldRef<"ProjectGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectGroup findUnique
   */
  export type ProjectGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroup to fetch.
     */
    where: ProjectGroupWhereUniqueInput
  }

  /**
   * ProjectGroup findUniqueOrThrow
   */
  export type ProjectGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroup to fetch.
     */
    where: ProjectGroupWhereUniqueInput
  }

  /**
   * ProjectGroup findFirst
   */
  export type ProjectGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroup to fetch.
     */
    where?: ProjectGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroups to fetch.
     */
    orderBy?: ProjectGroupOrderByWithRelationInput | ProjectGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGroups.
     */
    cursor?: ProjectGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGroups.
     */
    distinct?: ProjectGroupScalarFieldEnum | ProjectGroupScalarFieldEnum[]
  }

  /**
   * ProjectGroup findFirstOrThrow
   */
  export type ProjectGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroup to fetch.
     */
    where?: ProjectGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroups to fetch.
     */
    orderBy?: ProjectGroupOrderByWithRelationInput | ProjectGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGroups.
     */
    cursor?: ProjectGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGroups.
     */
    distinct?: ProjectGroupScalarFieldEnum | ProjectGroupScalarFieldEnum[]
  }

  /**
   * ProjectGroup findMany
   */
  export type ProjectGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroups to fetch.
     */
    where?: ProjectGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroups to fetch.
     */
    orderBy?: ProjectGroupOrderByWithRelationInput | ProjectGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectGroups.
     */
    cursor?: ProjectGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroups.
     */
    skip?: number
    distinct?: ProjectGroupScalarFieldEnum | ProjectGroupScalarFieldEnum[]
  }

  /**
   * ProjectGroup create
   */
  export type ProjectGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectGroup.
     */
    data: XOR<ProjectGroupCreateInput, ProjectGroupUncheckedCreateInput>
  }

  /**
   * ProjectGroup createMany
   */
  export type ProjectGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectGroups.
     */
    data: ProjectGroupCreateManyInput | ProjectGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectGroup createManyAndReturn
   */
  export type ProjectGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectGroups.
     */
    data: ProjectGroupCreateManyInput | ProjectGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectGroup update
   */
  export type ProjectGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectGroup.
     */
    data: XOR<ProjectGroupUpdateInput, ProjectGroupUncheckedUpdateInput>
    /**
     * Choose, which ProjectGroup to update.
     */
    where: ProjectGroupWhereUniqueInput
  }

  /**
   * ProjectGroup updateMany
   */
  export type ProjectGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectGroups.
     */
    data: XOR<ProjectGroupUpdateManyMutationInput, ProjectGroupUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGroups to update
     */
    where?: ProjectGroupWhereInput
    /**
     * Limit how many ProjectGroups to update.
     */
    limit?: number
  }

  /**
   * ProjectGroup updateManyAndReturn
   */
  export type ProjectGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * The data used to update ProjectGroups.
     */
    data: XOR<ProjectGroupUpdateManyMutationInput, ProjectGroupUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGroups to update
     */
    where?: ProjectGroupWhereInput
    /**
     * Limit how many ProjectGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectGroup upsert
   */
  export type ProjectGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectGroup to update in case it exists.
     */
    where: ProjectGroupWhereUniqueInput
    /**
     * In case the ProjectGroup found by the `where` argument doesn't exist, create a new ProjectGroup with this data.
     */
    create: XOR<ProjectGroupCreateInput, ProjectGroupUncheckedCreateInput>
    /**
     * In case the ProjectGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectGroupUpdateInput, ProjectGroupUncheckedUpdateInput>
  }

  /**
   * ProjectGroup delete
   */
  export type ProjectGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
    /**
     * Filter which ProjectGroup to delete.
     */
    where: ProjectGroupWhereUniqueInput
  }

  /**
   * ProjectGroup deleteMany
   */
  export type ProjectGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGroups to delete
     */
    where?: ProjectGroupWhereInput
    /**
     * Limit how many ProjectGroups to delete.
     */
    limit?: number
  }

  /**
   * ProjectGroup.projects
   */
  export type ProjectGroup$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    where?: ProjectGroupMemberWhereInput
    orderBy?: ProjectGroupMemberOrderByWithRelationInput | ProjectGroupMemberOrderByWithRelationInput[]
    cursor?: ProjectGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectGroupMemberScalarFieldEnum | ProjectGroupMemberScalarFieldEnum[]
  }

  /**
   * ProjectGroup without action
   */
  export type ProjectGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroup
     */
    select?: ProjectGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroup
     */
    omit?: ProjectGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupInclude<ExtArgs> | null
  }


  /**
   * Model ProjectGroupMember
   */

  export type AggregateProjectGroupMember = {
    _count: ProjectGroupMemberCountAggregateOutputType | null
    _avg: ProjectGroupMemberAvgAggregateOutputType | null
    _sum: ProjectGroupMemberSumAggregateOutputType | null
    _min: ProjectGroupMemberMinAggregateOutputType | null
    _max: ProjectGroupMemberMaxAggregateOutputType | null
  }

  export type ProjectGroupMemberAvgAggregateOutputType = {
    id: number | null
    projectGroupId: number | null
    projectId: number | null
    position: number | null
  }

  export type ProjectGroupMemberSumAggregateOutputType = {
    id: number | null
    projectGroupId: number | null
    projectId: number | null
    position: number | null
  }

  export type ProjectGroupMemberMinAggregateOutputType = {
    id: number | null
    projectGroupId: number | null
    projectId: number | null
    position: number | null
    createdAt: Date | null
  }

  export type ProjectGroupMemberMaxAggregateOutputType = {
    id: number | null
    projectGroupId: number | null
    projectId: number | null
    position: number | null
    createdAt: Date | null
  }

  export type ProjectGroupMemberCountAggregateOutputType = {
    id: number
    projectGroupId: number
    projectId: number
    position: number
    createdAt: number
    _all: number
  }


  export type ProjectGroupMemberAvgAggregateInputType = {
    id?: true
    projectGroupId?: true
    projectId?: true
    position?: true
  }

  export type ProjectGroupMemberSumAggregateInputType = {
    id?: true
    projectGroupId?: true
    projectId?: true
    position?: true
  }

  export type ProjectGroupMemberMinAggregateInputType = {
    id?: true
    projectGroupId?: true
    projectId?: true
    position?: true
    createdAt?: true
  }

  export type ProjectGroupMemberMaxAggregateInputType = {
    id?: true
    projectGroupId?: true
    projectId?: true
    position?: true
    createdAt?: true
  }

  export type ProjectGroupMemberCountAggregateInputType = {
    id?: true
    projectGroupId?: true
    projectId?: true
    position?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGroupMember to aggregate.
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroupMembers to fetch.
     */
    orderBy?: ProjectGroupMemberOrderByWithRelationInput | ProjectGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectGroupMembers
    **/
    _count?: true | ProjectGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectGroupMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectGroupMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectGroupMemberMaxAggregateInputType
  }

  export type GetProjectGroupMemberAggregateType<T extends ProjectGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectGroupMember[P]>
      : GetScalarType<T[P], AggregateProjectGroupMember[P]>
  }




  export type ProjectGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectGroupMemberWhereInput
    orderBy?: ProjectGroupMemberOrderByWithAggregationInput | ProjectGroupMemberOrderByWithAggregationInput[]
    by: ProjectGroupMemberScalarFieldEnum[] | ProjectGroupMemberScalarFieldEnum
    having?: ProjectGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectGroupMemberCountAggregateInputType | true
    _avg?: ProjectGroupMemberAvgAggregateInputType
    _sum?: ProjectGroupMemberSumAggregateInputType
    _min?: ProjectGroupMemberMinAggregateInputType
    _max?: ProjectGroupMemberMaxAggregateInputType
  }

  export type ProjectGroupMemberGroupByOutputType = {
    id: number
    projectGroupId: number
    projectId: number
    position: number
    createdAt: Date
    _count: ProjectGroupMemberCountAggregateOutputType | null
    _avg: ProjectGroupMemberAvgAggregateOutputType | null
    _sum: ProjectGroupMemberSumAggregateOutputType | null
    _min: ProjectGroupMemberMinAggregateOutputType | null
    _max: ProjectGroupMemberMaxAggregateOutputType | null
  }

  type GetProjectGroupMemberGroupByPayload<T extends ProjectGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectGroupId?: boolean
    projectId?: boolean
    position?: boolean
    createdAt?: boolean
    projectGroup?: boolean | ProjectGroupDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGroupMember"]>

  export type ProjectGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectGroupId?: boolean
    projectId?: boolean
    position?: boolean
    createdAt?: boolean
    projectGroup?: boolean | ProjectGroupDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGroupMember"]>

  export type ProjectGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectGroupId?: boolean
    projectId?: boolean
    position?: boolean
    createdAt?: boolean
    projectGroup?: boolean | ProjectGroupDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectGroupMember"]>

  export type ProjectGroupMemberSelectScalar = {
    id?: boolean
    projectGroupId?: boolean
    projectId?: boolean
    position?: boolean
    createdAt?: boolean
  }

  export type ProjectGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectGroupId" | "projectId" | "position" | "createdAt", ExtArgs["result"]["projectGroupMember"]>
  export type ProjectGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectGroup?: boolean | ProjectGroupDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectGroup?: boolean | ProjectGroupDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectGroup?: boolean | ProjectGroupDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectGroupMember"
    objects: {
      projectGroup: Prisma.$ProjectGroupPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectGroupId: number
      projectId: number
      position: number
      createdAt: Date
    }, ExtArgs["result"]["projectGroupMember"]>
    composites: {}
  }

  type ProjectGroupMemberGetPayload<S extends boolean | null | undefined | ProjectGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectGroupMemberPayload, S>

  type ProjectGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectGroupMemberCountAggregateInputType | true
    }

  export interface ProjectGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectGroupMember'], meta: { name: 'ProjectGroupMember' } }
    /**
     * Find zero or one ProjectGroupMember that matches the filter.
     * @param {ProjectGroupMemberFindUniqueArgs} args - Arguments to find a ProjectGroupMember
     * @example
     * // Get one ProjectGroupMember
     * const projectGroupMember = await prisma.projectGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectGroupMemberFindUniqueArgs>(args: SelectSubset<T, ProjectGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectGroupMember
     * @example
     * // Get one ProjectGroupMember
     * const projectGroupMember = await prisma.projectGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberFindFirstArgs} args - Arguments to find a ProjectGroupMember
     * @example
     * // Get one ProjectGroupMember
     * const projectGroupMember = await prisma.projectGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectGroupMemberFindFirstArgs>(args?: SelectSubset<T, ProjectGroupMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectGroupMember
     * @example
     * // Get one ProjectGroupMember
     * const projectGroupMember = await prisma.projectGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectGroupMembers
     * const projectGroupMembers = await prisma.projectGroupMember.findMany()
     * 
     * // Get first 10 ProjectGroupMembers
     * const projectGroupMembers = await prisma.projectGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectGroupMemberWithIdOnly = await prisma.projectGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectGroupMemberFindManyArgs>(args?: SelectSubset<T, ProjectGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectGroupMember.
     * @param {ProjectGroupMemberCreateArgs} args - Arguments to create a ProjectGroupMember.
     * @example
     * // Create one ProjectGroupMember
     * const ProjectGroupMember = await prisma.projectGroupMember.create({
     *   data: {
     *     // ... data to create a ProjectGroupMember
     *   }
     * })
     * 
     */
    create<T extends ProjectGroupMemberCreateArgs>(args: SelectSubset<T, ProjectGroupMemberCreateArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectGroupMembers.
     * @param {ProjectGroupMemberCreateManyArgs} args - Arguments to create many ProjectGroupMembers.
     * @example
     * // Create many ProjectGroupMembers
     * const projectGroupMember = await prisma.projectGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectGroupMemberCreateManyArgs>(args?: SelectSubset<T, ProjectGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectGroupMembers and returns the data saved in the database.
     * @param {ProjectGroupMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectGroupMembers.
     * @example
     * // Create many ProjectGroupMembers
     * const projectGroupMember = await prisma.projectGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectGroupMembers and only return the `id`
     * const projectGroupMemberWithIdOnly = await prisma.projectGroupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectGroupMember.
     * @param {ProjectGroupMemberDeleteArgs} args - Arguments to delete one ProjectGroupMember.
     * @example
     * // Delete one ProjectGroupMember
     * const ProjectGroupMember = await prisma.projectGroupMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectGroupMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectGroupMemberDeleteArgs>(args: SelectSubset<T, ProjectGroupMemberDeleteArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectGroupMember.
     * @param {ProjectGroupMemberUpdateArgs} args - Arguments to update one ProjectGroupMember.
     * @example
     * // Update one ProjectGroupMember
     * const projectGroupMember = await prisma.projectGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectGroupMemberUpdateArgs>(args: SelectSubset<T, ProjectGroupMemberUpdateArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectGroupMembers.
     * @param {ProjectGroupMemberDeleteManyArgs} args - Arguments to filter ProjectGroupMembers to delete.
     * @example
     * // Delete a few ProjectGroupMembers
     * const { count } = await prisma.projectGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectGroupMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectGroupMembers
     * const projectGroupMember = await prisma.projectGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectGroupMemberUpdateManyArgs>(args: SelectSubset<T, ProjectGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectGroupMembers and returns the data updated in the database.
     * @param {ProjectGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectGroupMembers.
     * @example
     * // Update many ProjectGroupMembers
     * const projectGroupMember = await prisma.projectGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectGroupMembers and only return the `id`
     * const projectGroupMemberWithIdOnly = await prisma.projectGroupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectGroupMember.
     * @param {ProjectGroupMemberUpsertArgs} args - Arguments to update or create a ProjectGroupMember.
     * @example
     * // Update or create a ProjectGroupMember
     * const projectGroupMember = await prisma.projectGroupMember.upsert({
     *   create: {
     *     // ... data to create a ProjectGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectGroupMemberUpsertArgs>(args: SelectSubset<T, ProjectGroupMemberUpsertArgs<ExtArgs>>): Prisma__ProjectGroupMemberClient<$Result.GetResult<Prisma.$ProjectGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberCountArgs} args - Arguments to filter ProjectGroupMembers to count.
     * @example
     * // Count the number of ProjectGroupMembers
     * const count = await prisma.projectGroupMember.count({
     *   where: {
     *     // ... the filter for the ProjectGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectGroupMemberCountArgs>(
      args?: Subset<T, ProjectGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectGroupMemberAggregateArgs>(args: Subset<T, ProjectGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectGroupMemberAggregateType<T>>

    /**
     * Group by ProjectGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectGroupMember model
   */
  readonly fields: ProjectGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectGroup<T extends ProjectGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectGroupDefaultArgs<ExtArgs>>): Prisma__ProjectGroupClient<$Result.GetResult<Prisma.$ProjectGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectGroupMember model
   */
  interface ProjectGroupMemberFieldRefs {
    readonly id: FieldRef<"ProjectGroupMember", 'Int'>
    readonly projectGroupId: FieldRef<"ProjectGroupMember", 'Int'>
    readonly projectId: FieldRef<"ProjectGroupMember", 'Int'>
    readonly position: FieldRef<"ProjectGroupMember", 'Int'>
    readonly createdAt: FieldRef<"ProjectGroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectGroupMember findUnique
   */
  export type ProjectGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroupMember to fetch.
     */
    where: ProjectGroupMemberWhereUniqueInput
  }

  /**
   * ProjectGroupMember findUniqueOrThrow
   */
  export type ProjectGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroupMember to fetch.
     */
    where: ProjectGroupMemberWhereUniqueInput
  }

  /**
   * ProjectGroupMember findFirst
   */
  export type ProjectGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroupMember to fetch.
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroupMembers to fetch.
     */
    orderBy?: ProjectGroupMemberOrderByWithRelationInput | ProjectGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGroupMembers.
     */
    cursor?: ProjectGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGroupMembers.
     */
    distinct?: ProjectGroupMemberScalarFieldEnum | ProjectGroupMemberScalarFieldEnum[]
  }

  /**
   * ProjectGroupMember findFirstOrThrow
   */
  export type ProjectGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroupMember to fetch.
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroupMembers to fetch.
     */
    orderBy?: ProjectGroupMemberOrderByWithRelationInput | ProjectGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectGroupMembers.
     */
    cursor?: ProjectGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectGroupMembers.
     */
    distinct?: ProjectGroupMemberScalarFieldEnum | ProjectGroupMemberScalarFieldEnum[]
  }

  /**
   * ProjectGroupMember findMany
   */
  export type ProjectGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectGroupMembers to fetch.
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectGroupMembers to fetch.
     */
    orderBy?: ProjectGroupMemberOrderByWithRelationInput | ProjectGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectGroupMembers.
     */
    cursor?: ProjectGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectGroupMembers.
     */
    skip?: number
    distinct?: ProjectGroupMemberScalarFieldEnum | ProjectGroupMemberScalarFieldEnum[]
  }

  /**
   * ProjectGroupMember create
   */
  export type ProjectGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectGroupMember.
     */
    data: XOR<ProjectGroupMemberCreateInput, ProjectGroupMemberUncheckedCreateInput>
  }

  /**
   * ProjectGroupMember createMany
   */
  export type ProjectGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectGroupMembers.
     */
    data: ProjectGroupMemberCreateManyInput | ProjectGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectGroupMember createManyAndReturn
   */
  export type ProjectGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectGroupMembers.
     */
    data: ProjectGroupMemberCreateManyInput | ProjectGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectGroupMember update
   */
  export type ProjectGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectGroupMember.
     */
    data: XOR<ProjectGroupMemberUpdateInput, ProjectGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectGroupMember to update.
     */
    where: ProjectGroupMemberWhereUniqueInput
  }

  /**
   * ProjectGroupMember updateMany
   */
  export type ProjectGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectGroupMembers.
     */
    data: XOR<ProjectGroupMemberUpdateManyMutationInput, ProjectGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGroupMembers to update
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * Limit how many ProjectGroupMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectGroupMember updateManyAndReturn
   */
  export type ProjectGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectGroupMembers.
     */
    data: XOR<ProjectGroupMemberUpdateManyMutationInput, ProjectGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectGroupMembers to update
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * Limit how many ProjectGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectGroupMember upsert
   */
  export type ProjectGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectGroupMember to update in case it exists.
     */
    where: ProjectGroupMemberWhereUniqueInput
    /**
     * In case the ProjectGroupMember found by the `where` argument doesn't exist, create a new ProjectGroupMember with this data.
     */
    create: XOR<ProjectGroupMemberCreateInput, ProjectGroupMemberUncheckedCreateInput>
    /**
     * In case the ProjectGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectGroupMemberUpdateInput, ProjectGroupMemberUncheckedUpdateInput>
  }

  /**
   * ProjectGroupMember delete
   */
  export type ProjectGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectGroupMember to delete.
     */
    where: ProjectGroupMemberWhereUniqueInput
  }

  /**
   * ProjectGroupMember deleteMany
   */
  export type ProjectGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectGroupMembers to delete
     */
    where?: ProjectGroupMemberWhereInput
    /**
     * Limit how many ProjectGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectGroupMember without action
   */
  export type ProjectGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectGroupMember
     */
    select?: ProjectGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectGroupMember
     */
    omit?: ProjectGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model TaskSession
   */

  export type AggregateTaskSession = {
    _count: TaskSessionCountAggregateOutputType | null
    _avg: TaskSessionAvgAggregateOutputType | null
    _sum: TaskSessionSumAggregateOutputType | null
    _min: TaskSessionMinAggregateOutputType | null
    _max: TaskSessionMaxAggregateOutputType | null
  }

  export type TaskSessionAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskSessionSumAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskSessionMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    sessionId: string | null
    linkType: $Enums.TaskSessionType | null
    notes: string | null
    createdAt: Date | null
  }

  export type TaskSessionMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    sessionId: string | null
    linkType: $Enums.TaskSessionType | null
    notes: string | null
    createdAt: Date | null
  }

  export type TaskSessionCountAggregateOutputType = {
    id: number
    taskId: number
    sessionId: number
    linkType: number
    notes: number
    createdAt: number
    _all: number
  }


  export type TaskSessionAvgAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskSessionSumAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskSessionMinAggregateInputType = {
    id?: true
    taskId?: true
    sessionId?: true
    linkType?: true
    notes?: true
    createdAt?: true
  }

  export type TaskSessionMaxAggregateInputType = {
    id?: true
    taskId?: true
    sessionId?: true
    linkType?: true
    notes?: true
    createdAt?: true
  }

  export type TaskSessionCountAggregateInputType = {
    id?: true
    taskId?: true
    sessionId?: true
    linkType?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type TaskSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskSession to aggregate.
     */
    where?: TaskSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskSessions to fetch.
     */
    orderBy?: TaskSessionOrderByWithRelationInput | TaskSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskSessions
    **/
    _count?: true | TaskSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskSessionMaxAggregateInputType
  }

  export type GetTaskSessionAggregateType<T extends TaskSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskSession[P]>
      : GetScalarType<T[P], AggregateTaskSession[P]>
  }




  export type TaskSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskSessionWhereInput
    orderBy?: TaskSessionOrderByWithAggregationInput | TaskSessionOrderByWithAggregationInput[]
    by: TaskSessionScalarFieldEnum[] | TaskSessionScalarFieldEnum
    having?: TaskSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskSessionCountAggregateInputType | true
    _avg?: TaskSessionAvgAggregateInputType
    _sum?: TaskSessionSumAggregateInputType
    _min?: TaskSessionMinAggregateInputType
    _max?: TaskSessionMaxAggregateInputType
  }

  export type TaskSessionGroupByOutputType = {
    id: number
    taskId: number
    sessionId: string
    linkType: $Enums.TaskSessionType
    notes: string | null
    createdAt: Date
    _count: TaskSessionCountAggregateOutputType | null
    _avg: TaskSessionAvgAggregateOutputType | null
    _sum: TaskSessionSumAggregateOutputType | null
    _min: TaskSessionMinAggregateOutputType | null
    _max: TaskSessionMaxAggregateOutputType | null
  }

  type GetTaskSessionGroupByPayload<T extends TaskSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TaskSessionGroupByOutputType[P]>
        }
      >
    >


  export type TaskSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    sessionId?: boolean
    linkType?: boolean
    notes?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskSession"]>

  export type TaskSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    sessionId?: boolean
    linkType?: boolean
    notes?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskSession"]>

  export type TaskSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    sessionId?: boolean
    linkType?: boolean
    notes?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskSession"]>

  export type TaskSessionSelectScalar = {
    id?: boolean
    taskId?: boolean
    sessionId?: boolean
    linkType?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type TaskSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "sessionId" | "linkType" | "notes" | "createdAt", ExtArgs["result"]["taskSession"]>
  export type TaskSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskSession"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      sessionId: string
      linkType: $Enums.TaskSessionType
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["taskSession"]>
    composites: {}
  }

  type TaskSessionGetPayload<S extends boolean | null | undefined | TaskSessionDefaultArgs> = $Result.GetResult<Prisma.$TaskSessionPayload, S>

  type TaskSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskSessionCountAggregateInputType | true
    }

  export interface TaskSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskSession'], meta: { name: 'TaskSession' } }
    /**
     * Find zero or one TaskSession that matches the filter.
     * @param {TaskSessionFindUniqueArgs} args - Arguments to find a TaskSession
     * @example
     * // Get one TaskSession
     * const taskSession = await prisma.taskSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskSessionFindUniqueArgs>(args: SelectSubset<T, TaskSessionFindUniqueArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskSessionFindUniqueOrThrowArgs} args - Arguments to find a TaskSession
     * @example
     * // Get one TaskSession
     * const taskSession = await prisma.taskSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionFindFirstArgs} args - Arguments to find a TaskSession
     * @example
     * // Get one TaskSession
     * const taskSession = await prisma.taskSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskSessionFindFirstArgs>(args?: SelectSubset<T, TaskSessionFindFirstArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionFindFirstOrThrowArgs} args - Arguments to find a TaskSession
     * @example
     * // Get one TaskSession
     * const taskSession = await prisma.taskSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskSessions
     * const taskSessions = await prisma.taskSession.findMany()
     * 
     * // Get first 10 TaskSessions
     * const taskSessions = await prisma.taskSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskSessionWithIdOnly = await prisma.taskSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskSessionFindManyArgs>(args?: SelectSubset<T, TaskSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskSession.
     * @param {TaskSessionCreateArgs} args - Arguments to create a TaskSession.
     * @example
     * // Create one TaskSession
     * const TaskSession = await prisma.taskSession.create({
     *   data: {
     *     // ... data to create a TaskSession
     *   }
     * })
     * 
     */
    create<T extends TaskSessionCreateArgs>(args: SelectSubset<T, TaskSessionCreateArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskSessions.
     * @param {TaskSessionCreateManyArgs} args - Arguments to create many TaskSessions.
     * @example
     * // Create many TaskSessions
     * const taskSession = await prisma.taskSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskSessionCreateManyArgs>(args?: SelectSubset<T, TaskSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskSessions and returns the data saved in the database.
     * @param {TaskSessionCreateManyAndReturnArgs} args - Arguments to create many TaskSessions.
     * @example
     * // Create many TaskSessions
     * const taskSession = await prisma.taskSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskSessions and only return the `id`
     * const taskSessionWithIdOnly = await prisma.taskSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskSession.
     * @param {TaskSessionDeleteArgs} args - Arguments to delete one TaskSession.
     * @example
     * // Delete one TaskSession
     * const TaskSession = await prisma.taskSession.delete({
     *   where: {
     *     // ... filter to delete one TaskSession
     *   }
     * })
     * 
     */
    delete<T extends TaskSessionDeleteArgs>(args: SelectSubset<T, TaskSessionDeleteArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskSession.
     * @param {TaskSessionUpdateArgs} args - Arguments to update one TaskSession.
     * @example
     * // Update one TaskSession
     * const taskSession = await prisma.taskSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskSessionUpdateArgs>(args: SelectSubset<T, TaskSessionUpdateArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskSessions.
     * @param {TaskSessionDeleteManyArgs} args - Arguments to filter TaskSessions to delete.
     * @example
     * // Delete a few TaskSessions
     * const { count } = await prisma.taskSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskSessionDeleteManyArgs>(args?: SelectSubset<T, TaskSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskSessions
     * const taskSession = await prisma.taskSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskSessionUpdateManyArgs>(args: SelectSubset<T, TaskSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskSessions and returns the data updated in the database.
     * @param {TaskSessionUpdateManyAndReturnArgs} args - Arguments to update many TaskSessions.
     * @example
     * // Update many TaskSessions
     * const taskSession = await prisma.taskSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskSessions and only return the `id`
     * const taskSessionWithIdOnly = await prisma.taskSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskSession.
     * @param {TaskSessionUpsertArgs} args - Arguments to update or create a TaskSession.
     * @example
     * // Update or create a TaskSession
     * const taskSession = await prisma.taskSession.upsert({
     *   create: {
     *     // ... data to create a TaskSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskSession we want to update
     *   }
     * })
     */
    upsert<T extends TaskSessionUpsertArgs>(args: SelectSubset<T, TaskSessionUpsertArgs<ExtArgs>>): Prisma__TaskSessionClient<$Result.GetResult<Prisma.$TaskSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionCountArgs} args - Arguments to filter TaskSessions to count.
     * @example
     * // Count the number of TaskSessions
     * const count = await prisma.taskSession.count({
     *   where: {
     *     // ... the filter for the TaskSessions we want to count
     *   }
     * })
    **/
    count<T extends TaskSessionCountArgs>(
      args?: Subset<T, TaskSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskSessionAggregateArgs>(args: Subset<T, TaskSessionAggregateArgs>): Prisma.PrismaPromise<GetTaskSessionAggregateType<T>>

    /**
     * Group by TaskSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskSessionGroupByArgs['orderBy'] }
        : { orderBy?: TaskSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskSession model
   */
  readonly fields: TaskSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskSession model
   */
  interface TaskSessionFieldRefs {
    readonly id: FieldRef<"TaskSession", 'Int'>
    readonly taskId: FieldRef<"TaskSession", 'Int'>
    readonly sessionId: FieldRef<"TaskSession", 'String'>
    readonly linkType: FieldRef<"TaskSession", 'TaskSessionType'>
    readonly notes: FieldRef<"TaskSession", 'String'>
    readonly createdAt: FieldRef<"TaskSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskSession findUnique
   */
  export type TaskSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * Filter, which TaskSession to fetch.
     */
    where: TaskSessionWhereUniqueInput
  }

  /**
   * TaskSession findUniqueOrThrow
   */
  export type TaskSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * Filter, which TaskSession to fetch.
     */
    where: TaskSessionWhereUniqueInput
  }

  /**
   * TaskSession findFirst
   */
  export type TaskSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * Filter, which TaskSession to fetch.
     */
    where?: TaskSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskSessions to fetch.
     */
    orderBy?: TaskSessionOrderByWithRelationInput | TaskSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskSessions.
     */
    cursor?: TaskSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskSessions.
     */
    distinct?: TaskSessionScalarFieldEnum | TaskSessionScalarFieldEnum[]
  }

  /**
   * TaskSession findFirstOrThrow
   */
  export type TaskSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * Filter, which TaskSession to fetch.
     */
    where?: TaskSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskSessions to fetch.
     */
    orderBy?: TaskSessionOrderByWithRelationInput | TaskSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskSessions.
     */
    cursor?: TaskSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskSessions.
     */
    distinct?: TaskSessionScalarFieldEnum | TaskSessionScalarFieldEnum[]
  }

  /**
   * TaskSession findMany
   */
  export type TaskSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * Filter, which TaskSessions to fetch.
     */
    where?: TaskSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskSessions to fetch.
     */
    orderBy?: TaskSessionOrderByWithRelationInput | TaskSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskSessions.
     */
    cursor?: TaskSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskSessions.
     */
    skip?: number
    distinct?: TaskSessionScalarFieldEnum | TaskSessionScalarFieldEnum[]
  }

  /**
   * TaskSession create
   */
  export type TaskSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskSession.
     */
    data: XOR<TaskSessionCreateInput, TaskSessionUncheckedCreateInput>
  }

  /**
   * TaskSession createMany
   */
  export type TaskSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskSessions.
     */
    data: TaskSessionCreateManyInput | TaskSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskSession createManyAndReturn
   */
  export type TaskSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * The data used to create many TaskSessions.
     */
    data: TaskSessionCreateManyInput | TaskSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskSession update
   */
  export type TaskSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskSession.
     */
    data: XOR<TaskSessionUpdateInput, TaskSessionUncheckedUpdateInput>
    /**
     * Choose, which TaskSession to update.
     */
    where: TaskSessionWhereUniqueInput
  }

  /**
   * TaskSession updateMany
   */
  export type TaskSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskSessions.
     */
    data: XOR<TaskSessionUpdateManyMutationInput, TaskSessionUncheckedUpdateManyInput>
    /**
     * Filter which TaskSessions to update
     */
    where?: TaskSessionWhereInput
    /**
     * Limit how many TaskSessions to update.
     */
    limit?: number
  }

  /**
   * TaskSession updateManyAndReturn
   */
  export type TaskSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * The data used to update TaskSessions.
     */
    data: XOR<TaskSessionUpdateManyMutationInput, TaskSessionUncheckedUpdateManyInput>
    /**
     * Filter which TaskSessions to update
     */
    where?: TaskSessionWhereInput
    /**
     * Limit how many TaskSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskSession upsert
   */
  export type TaskSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskSession to update in case it exists.
     */
    where: TaskSessionWhereUniqueInput
    /**
     * In case the TaskSession found by the `where` argument doesn't exist, create a new TaskSession with this data.
     */
    create: XOR<TaskSessionCreateInput, TaskSessionUncheckedCreateInput>
    /**
     * In case the TaskSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskSessionUpdateInput, TaskSessionUncheckedUpdateInput>
  }

  /**
   * TaskSession delete
   */
  export type TaskSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
    /**
     * Filter which TaskSession to delete.
     */
    where: TaskSessionWhereUniqueInput
  }

  /**
   * TaskSession deleteMany
   */
  export type TaskSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskSessions to delete
     */
    where?: TaskSessionWhereInput
    /**
     * Limit how many TaskSessions to delete.
     */
    limit?: number
  }

  /**
   * TaskSession without action
   */
  export type TaskSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskSession
     */
    select?: TaskSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskSession
     */
    omit?: TaskSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskSessionInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    amount: Decimal | null
  }

  export type BudgetSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    amount: Decimal | null
  }

  export type BudgetMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    amount: Decimal | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    amount: Decimal | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    amount: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
  }

  export type BudgetSumAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    amount?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    amount?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    amount?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: number
    projectId: number
    name: string
    amount: Decimal
    currency: string
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    lines?: boolean | Budget$linesArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    amount?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "amount" | "currency" | "createdAt" | "updatedAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    lines?: boolean | Budget$linesArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      lines: Prisma.$BudgetLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      amount: Prisma.Decimal
      currency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends Budget$linesArgs<ExtArgs> = {}>(args?: Subset<T, Budget$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'Int'>
    readonly projectId: FieldRef<"Budget", 'Int'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly amount: FieldRef<"Budget", 'Decimal'>
    readonly currency: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget.lines
   */
  export type Budget$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    where?: BudgetLineWhereInput
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    cursor?: BudgetLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetLine
   */

  export type AggregateBudgetLine = {
    _count: BudgetLineCountAggregateOutputType | null
    _avg: BudgetLineAvgAggregateOutputType | null
    _sum: BudgetLineSumAggregateOutputType | null
    _min: BudgetLineMinAggregateOutputType | null
    _max: BudgetLineMaxAggregateOutputType | null
  }

  export type BudgetLineAvgAggregateOutputType = {
    id: number | null
    budgetId: number | null
    amount: Decimal | null
    taskId: number | null
  }

  export type BudgetLineSumAggregateOutputType = {
    id: number | null
    budgetId: number | null
    amount: Decimal | null
    taskId: number | null
  }

  export type BudgetLineMinAggregateOutputType = {
    id: number | null
    budgetId: number | null
    description: string | null
    amount: Decimal | null
    lineType: $Enums.BudgetLineType | null
    taskId: number | null
    createdAt: Date | null
  }

  export type BudgetLineMaxAggregateOutputType = {
    id: number | null
    budgetId: number | null
    description: string | null
    amount: Decimal | null
    lineType: $Enums.BudgetLineType | null
    taskId: number | null
    createdAt: Date | null
  }

  export type BudgetLineCountAggregateOutputType = {
    id: number
    budgetId: number
    description: number
    amount: number
    lineType: number
    taskId: number
    createdAt: number
    _all: number
  }


  export type BudgetLineAvgAggregateInputType = {
    id?: true
    budgetId?: true
    amount?: true
    taskId?: true
  }

  export type BudgetLineSumAggregateInputType = {
    id?: true
    budgetId?: true
    amount?: true
    taskId?: true
  }

  export type BudgetLineMinAggregateInputType = {
    id?: true
    budgetId?: true
    description?: true
    amount?: true
    lineType?: true
    taskId?: true
    createdAt?: true
  }

  export type BudgetLineMaxAggregateInputType = {
    id?: true
    budgetId?: true
    description?: true
    amount?: true
    lineType?: true
    taskId?: true
    createdAt?: true
  }

  export type BudgetLineCountAggregateInputType = {
    id?: true
    budgetId?: true
    description?: true
    amount?: true
    lineType?: true
    taskId?: true
    createdAt?: true
    _all?: true
  }

  export type BudgetLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetLine to aggregate.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetLines
    **/
    _count?: true | BudgetLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetLineMaxAggregateInputType
  }

  export type GetBudgetLineAggregateType<T extends BudgetLineAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetLine[P]>
      : GetScalarType<T[P], AggregateBudgetLine[P]>
  }




  export type BudgetLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineWhereInput
    orderBy?: BudgetLineOrderByWithAggregationInput | BudgetLineOrderByWithAggregationInput[]
    by: BudgetLineScalarFieldEnum[] | BudgetLineScalarFieldEnum
    having?: BudgetLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetLineCountAggregateInputType | true
    _avg?: BudgetLineAvgAggregateInputType
    _sum?: BudgetLineSumAggregateInputType
    _min?: BudgetLineMinAggregateInputType
    _max?: BudgetLineMaxAggregateInputType
  }

  export type BudgetLineGroupByOutputType = {
    id: number
    budgetId: number
    description: string
    amount: Decimal
    lineType: $Enums.BudgetLineType
    taskId: number | null
    createdAt: Date
    _count: BudgetLineCountAggregateOutputType | null
    _avg: BudgetLineAvgAggregateOutputType | null
    _sum: BudgetLineSumAggregateOutputType | null
    _min: BudgetLineMinAggregateOutputType | null
    _max: BudgetLineMaxAggregateOutputType | null
  }

  type GetBudgetLineGroupByPayload<T extends BudgetLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetLineGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetLineGroupByOutputType[P]>
        }
      >
    >


  export type BudgetLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    description?: boolean
    amount?: boolean
    lineType?: boolean
    taskId?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLine"]>

  export type BudgetLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    description?: boolean
    amount?: boolean
    lineType?: boolean
    taskId?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLine"]>

  export type BudgetLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    description?: boolean
    amount?: boolean
    lineType?: boolean
    taskId?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLine"]>

  export type BudgetLineSelectScalar = {
    id?: boolean
    budgetId?: boolean
    description?: boolean
    amount?: boolean
    lineType?: boolean
    taskId?: boolean
    createdAt?: boolean
  }

  export type BudgetLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budgetId" | "description" | "amount" | "lineType" | "taskId" | "createdAt", ExtArgs["result"]["budgetLine"]>
  export type BudgetLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }

  export type $BudgetLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetLine"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      budgetId: number
      description: string
      amount: Prisma.Decimal
      lineType: $Enums.BudgetLineType
      taskId: number | null
      createdAt: Date
    }, ExtArgs["result"]["budgetLine"]>
    composites: {}
  }

  type BudgetLineGetPayload<S extends boolean | null | undefined | BudgetLineDefaultArgs> = $Result.GetResult<Prisma.$BudgetLinePayload, S>

  type BudgetLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetLineCountAggregateInputType | true
    }

  export interface BudgetLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetLine'], meta: { name: 'BudgetLine' } }
    /**
     * Find zero or one BudgetLine that matches the filter.
     * @param {BudgetLineFindUniqueArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetLineFindUniqueArgs>(args: SelectSubset<T, BudgetLineFindUniqueArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetLineFindUniqueOrThrowArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetLineFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineFindFirstArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetLineFindFirstArgs>(args?: SelectSubset<T, BudgetLineFindFirstArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineFindFirstOrThrowArgs} args - Arguments to find a BudgetLine
     * @example
     * // Get one BudgetLine
     * const budgetLine = await prisma.budgetLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetLineFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetLines
     * const budgetLines = await prisma.budgetLine.findMany()
     * 
     * // Get first 10 BudgetLines
     * const budgetLines = await prisma.budgetLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetLineWithIdOnly = await prisma.budgetLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetLineFindManyArgs>(args?: SelectSubset<T, BudgetLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetLine.
     * @param {BudgetLineCreateArgs} args - Arguments to create a BudgetLine.
     * @example
     * // Create one BudgetLine
     * const BudgetLine = await prisma.budgetLine.create({
     *   data: {
     *     // ... data to create a BudgetLine
     *   }
     * })
     * 
     */
    create<T extends BudgetLineCreateArgs>(args: SelectSubset<T, BudgetLineCreateArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetLines.
     * @param {BudgetLineCreateManyArgs} args - Arguments to create many BudgetLines.
     * @example
     * // Create many BudgetLines
     * const budgetLine = await prisma.budgetLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetLineCreateManyArgs>(args?: SelectSubset<T, BudgetLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetLines and returns the data saved in the database.
     * @param {BudgetLineCreateManyAndReturnArgs} args - Arguments to create many BudgetLines.
     * @example
     * // Create many BudgetLines
     * const budgetLine = await prisma.budgetLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetLines and only return the `id`
     * const budgetLineWithIdOnly = await prisma.budgetLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetLineCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetLine.
     * @param {BudgetLineDeleteArgs} args - Arguments to delete one BudgetLine.
     * @example
     * // Delete one BudgetLine
     * const BudgetLine = await prisma.budgetLine.delete({
     *   where: {
     *     // ... filter to delete one BudgetLine
     *   }
     * })
     * 
     */
    delete<T extends BudgetLineDeleteArgs>(args: SelectSubset<T, BudgetLineDeleteArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetLine.
     * @param {BudgetLineUpdateArgs} args - Arguments to update one BudgetLine.
     * @example
     * // Update one BudgetLine
     * const budgetLine = await prisma.budgetLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetLineUpdateArgs>(args: SelectSubset<T, BudgetLineUpdateArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetLines.
     * @param {BudgetLineDeleteManyArgs} args - Arguments to filter BudgetLines to delete.
     * @example
     * // Delete a few BudgetLines
     * const { count } = await prisma.budgetLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetLineDeleteManyArgs>(args?: SelectSubset<T, BudgetLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetLines
     * const budgetLine = await prisma.budgetLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetLineUpdateManyArgs>(args: SelectSubset<T, BudgetLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetLines and returns the data updated in the database.
     * @param {BudgetLineUpdateManyAndReturnArgs} args - Arguments to update many BudgetLines.
     * @example
     * // Update many BudgetLines
     * const budgetLine = await prisma.budgetLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetLines and only return the `id`
     * const budgetLineWithIdOnly = await prisma.budgetLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetLineUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetLine.
     * @param {BudgetLineUpsertArgs} args - Arguments to update or create a BudgetLine.
     * @example
     * // Update or create a BudgetLine
     * const budgetLine = await prisma.budgetLine.upsert({
     *   create: {
     *     // ... data to create a BudgetLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetLine we want to update
     *   }
     * })
     */
    upsert<T extends BudgetLineUpsertArgs>(args: SelectSubset<T, BudgetLineUpsertArgs<ExtArgs>>): Prisma__BudgetLineClient<$Result.GetResult<Prisma.$BudgetLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineCountArgs} args - Arguments to filter BudgetLines to count.
     * @example
     * // Count the number of BudgetLines
     * const count = await prisma.budgetLine.count({
     *   where: {
     *     // ... the filter for the BudgetLines we want to count
     *   }
     * })
    **/
    count<T extends BudgetLineCountArgs>(
      args?: Subset<T, BudgetLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetLineAggregateArgs>(args: Subset<T, BudgetLineAggregateArgs>): Prisma.PrismaPromise<GetBudgetLineAggregateType<T>>

    /**
     * Group by BudgetLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetLineGroupByArgs['orderBy'] }
        : { orderBy?: BudgetLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetLine model
   */
  readonly fields: BudgetLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetLine model
   */
  interface BudgetLineFieldRefs {
    readonly id: FieldRef<"BudgetLine", 'Int'>
    readonly budgetId: FieldRef<"BudgetLine", 'Int'>
    readonly description: FieldRef<"BudgetLine", 'String'>
    readonly amount: FieldRef<"BudgetLine", 'Decimal'>
    readonly lineType: FieldRef<"BudgetLine", 'BudgetLineType'>
    readonly taskId: FieldRef<"BudgetLine", 'Int'>
    readonly createdAt: FieldRef<"BudgetLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudgetLine findUnique
   */
  export type BudgetLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine findUniqueOrThrow
   */
  export type BudgetLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine findFirst
   */
  export type BudgetLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetLines.
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetLines.
     */
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetLine findFirstOrThrow
   */
  export type BudgetLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLine to fetch.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetLines.
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetLines.
     */
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetLine findMany
   */
  export type BudgetLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLines to fetch.
     */
    where?: BudgetLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLines to fetch.
     */
    orderBy?: BudgetLineOrderByWithRelationInput | BudgetLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetLines.
     */
    cursor?: BudgetLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLines.
     */
    skip?: number
    distinct?: BudgetLineScalarFieldEnum | BudgetLineScalarFieldEnum[]
  }

  /**
   * BudgetLine create
   */
  export type BudgetLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetLine.
     */
    data: XOR<BudgetLineCreateInput, BudgetLineUncheckedCreateInput>
  }

  /**
   * BudgetLine createMany
   */
  export type BudgetLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetLines.
     */
    data: BudgetLineCreateManyInput | BudgetLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetLine createManyAndReturn
   */
  export type BudgetLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetLines.
     */
    data: BudgetLineCreateManyInput | BudgetLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetLine update
   */
  export type BudgetLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetLine.
     */
    data: XOR<BudgetLineUpdateInput, BudgetLineUncheckedUpdateInput>
    /**
     * Choose, which BudgetLine to update.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine updateMany
   */
  export type BudgetLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetLines.
     */
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyInput>
    /**
     * Filter which BudgetLines to update
     */
    where?: BudgetLineWhereInput
    /**
     * Limit how many BudgetLines to update.
     */
    limit?: number
  }

  /**
   * BudgetLine updateManyAndReturn
   */
  export type BudgetLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * The data used to update BudgetLines.
     */
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyInput>
    /**
     * Filter which BudgetLines to update
     */
    where?: BudgetLineWhereInput
    /**
     * Limit how many BudgetLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetLine upsert
   */
  export type BudgetLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetLine to update in case it exists.
     */
    where: BudgetLineWhereUniqueInput
    /**
     * In case the BudgetLine found by the `where` argument doesn't exist, create a new BudgetLine with this data.
     */
    create: XOR<BudgetLineCreateInput, BudgetLineUncheckedCreateInput>
    /**
     * In case the BudgetLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetLineUpdateInput, BudgetLineUncheckedUpdateInput>
  }

  /**
   * BudgetLine delete
   */
  export type BudgetLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
    /**
     * Filter which BudgetLine to delete.
     */
    where: BudgetLineWhereUniqueInput
  }

  /**
   * BudgetLine deleteMany
   */
  export type BudgetLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetLines to delete
     */
    where?: BudgetLineWhereInput
    /**
     * Limit how many BudgetLines to delete.
     */
    limit?: number
  }

  /**
   * BudgetLine without action
   */
  export type BudgetLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLine
     */
    select?: BudgetLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLine
     */
    omit?: BudgetLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineInclude<ExtArgs> | null
  }


  /**
   * Model WikiPage
   */

  export type AggregateWikiPage = {
    _count: WikiPageCountAggregateOutputType | null
    _avg: WikiPageAvgAggregateOutputType | null
    _sum: WikiPageSumAggregateOutputType | null
    _min: WikiPageMinAggregateOutputType | null
    _max: WikiPageMaxAggregateOutputType | null
  }

  export type WikiPageAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    creatorId: number | null
    modifierId: number | null
  }

  export type WikiPageSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    creatorId: number | null
    modifierId: number | null
  }

  export type WikiPageMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    title: string | null
    content: string | null
    creatorId: number | null
    modifierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WikiPageMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    title: string | null
    content: string | null
    creatorId: number | null
    modifierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WikiPageCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    content: number
    creatorId: number
    modifierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WikiPageAvgAggregateInputType = {
    id?: true
    projectId?: true
    creatorId?: true
    modifierId?: true
  }

  export type WikiPageSumAggregateInputType = {
    id?: true
    projectId?: true
    creatorId?: true
    modifierId?: true
  }

  export type WikiPageMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    creatorId?: true
    modifierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WikiPageMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    creatorId?: true
    modifierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WikiPageCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    creatorId?: true
    modifierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WikiPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WikiPage to aggregate.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WikiPages
    **/
    _count?: true | WikiPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WikiPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WikiPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WikiPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WikiPageMaxAggregateInputType
  }

  export type GetWikiPageAggregateType<T extends WikiPageAggregateArgs> = {
        [P in keyof T & keyof AggregateWikiPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWikiPage[P]>
      : GetScalarType<T[P], AggregateWikiPage[P]>
  }




  export type WikiPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WikiPageWhereInput
    orderBy?: WikiPageOrderByWithAggregationInput | WikiPageOrderByWithAggregationInput[]
    by: WikiPageScalarFieldEnum[] | WikiPageScalarFieldEnum
    having?: WikiPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WikiPageCountAggregateInputType | true
    _avg?: WikiPageAvgAggregateInputType
    _sum?: WikiPageSumAggregateInputType
    _min?: WikiPageMinAggregateInputType
    _max?: WikiPageMaxAggregateInputType
  }

  export type WikiPageGroupByOutputType = {
    id: number
    projectId: number
    title: string
    content: string
    creatorId: number | null
    modifierId: number | null
    createdAt: Date
    updatedAt: Date
    _count: WikiPageCountAggregateOutputType | null
    _avg: WikiPageAvgAggregateOutputType | null
    _sum: WikiPageSumAggregateOutputType | null
    _min: WikiPageMinAggregateOutputType | null
    _max: WikiPageMaxAggregateOutputType | null
  }

  type GetWikiPageGroupByPayload<T extends WikiPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WikiPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WikiPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WikiPageGroupByOutputType[P]>
            : GetScalarType<T[P], WikiPageGroupByOutputType[P]>
        }
      >
    >


  export type WikiPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    creatorId?: boolean
    modifierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    creatorId?: boolean
    modifierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    creatorId?: boolean
    modifierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    creatorId?: boolean
    modifierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WikiPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "content" | "creatorId" | "modifierId" | "createdAt" | "updatedAt", ExtArgs["result"]["wikiPage"]>
  export type WikiPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WikiPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WikiPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $WikiPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WikiPage"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      title: string
      content: string
      creatorId: number | null
      modifierId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wikiPage"]>
    composites: {}
  }

  type WikiPageGetPayload<S extends boolean | null | undefined | WikiPageDefaultArgs> = $Result.GetResult<Prisma.$WikiPagePayload, S>

  type WikiPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WikiPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WikiPageCountAggregateInputType | true
    }

  export interface WikiPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WikiPage'], meta: { name: 'WikiPage' } }
    /**
     * Find zero or one WikiPage that matches the filter.
     * @param {WikiPageFindUniqueArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WikiPageFindUniqueArgs>(args: SelectSubset<T, WikiPageFindUniqueArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WikiPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WikiPageFindUniqueOrThrowArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WikiPageFindUniqueOrThrowArgs>(args: SelectSubset<T, WikiPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WikiPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindFirstArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WikiPageFindFirstArgs>(args?: SelectSubset<T, WikiPageFindFirstArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WikiPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindFirstOrThrowArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WikiPageFindFirstOrThrowArgs>(args?: SelectSubset<T, WikiPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WikiPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WikiPages
     * const wikiPages = await prisma.wikiPage.findMany()
     * 
     * // Get first 10 WikiPages
     * const wikiPages = await prisma.wikiPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WikiPageFindManyArgs>(args?: SelectSubset<T, WikiPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WikiPage.
     * @param {WikiPageCreateArgs} args - Arguments to create a WikiPage.
     * @example
     * // Create one WikiPage
     * const WikiPage = await prisma.wikiPage.create({
     *   data: {
     *     // ... data to create a WikiPage
     *   }
     * })
     * 
     */
    create<T extends WikiPageCreateArgs>(args: SelectSubset<T, WikiPageCreateArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WikiPages.
     * @param {WikiPageCreateManyArgs} args - Arguments to create many WikiPages.
     * @example
     * // Create many WikiPages
     * const wikiPage = await prisma.wikiPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WikiPageCreateManyArgs>(args?: SelectSubset<T, WikiPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WikiPages and returns the data saved in the database.
     * @param {WikiPageCreateManyAndReturnArgs} args - Arguments to create many WikiPages.
     * @example
     * // Create many WikiPages
     * const wikiPage = await prisma.wikiPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WikiPages and only return the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WikiPageCreateManyAndReturnArgs>(args?: SelectSubset<T, WikiPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WikiPage.
     * @param {WikiPageDeleteArgs} args - Arguments to delete one WikiPage.
     * @example
     * // Delete one WikiPage
     * const WikiPage = await prisma.wikiPage.delete({
     *   where: {
     *     // ... filter to delete one WikiPage
     *   }
     * })
     * 
     */
    delete<T extends WikiPageDeleteArgs>(args: SelectSubset<T, WikiPageDeleteArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WikiPage.
     * @param {WikiPageUpdateArgs} args - Arguments to update one WikiPage.
     * @example
     * // Update one WikiPage
     * const wikiPage = await prisma.wikiPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WikiPageUpdateArgs>(args: SelectSubset<T, WikiPageUpdateArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WikiPages.
     * @param {WikiPageDeleteManyArgs} args - Arguments to filter WikiPages to delete.
     * @example
     * // Delete a few WikiPages
     * const { count } = await prisma.wikiPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WikiPageDeleteManyArgs>(args?: SelectSubset<T, WikiPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WikiPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WikiPages
     * const wikiPage = await prisma.wikiPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WikiPageUpdateManyArgs>(args: SelectSubset<T, WikiPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WikiPages and returns the data updated in the database.
     * @param {WikiPageUpdateManyAndReturnArgs} args - Arguments to update many WikiPages.
     * @example
     * // Update many WikiPages
     * const wikiPage = await prisma.wikiPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WikiPages and only return the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WikiPageUpdateManyAndReturnArgs>(args: SelectSubset<T, WikiPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WikiPage.
     * @param {WikiPageUpsertArgs} args - Arguments to update or create a WikiPage.
     * @example
     * // Update or create a WikiPage
     * const wikiPage = await prisma.wikiPage.upsert({
     *   create: {
     *     // ... data to create a WikiPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WikiPage we want to update
     *   }
     * })
     */
    upsert<T extends WikiPageUpsertArgs>(args: SelectSubset<T, WikiPageUpsertArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WikiPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageCountArgs} args - Arguments to filter WikiPages to count.
     * @example
     * // Count the number of WikiPages
     * const count = await prisma.wikiPage.count({
     *   where: {
     *     // ... the filter for the WikiPages we want to count
     *   }
     * })
    **/
    count<T extends WikiPageCountArgs>(
      args?: Subset<T, WikiPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WikiPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WikiPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WikiPageAggregateArgs>(args: Subset<T, WikiPageAggregateArgs>): Prisma.PrismaPromise<GetWikiPageAggregateType<T>>

    /**
     * Group by WikiPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WikiPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WikiPageGroupByArgs['orderBy'] }
        : { orderBy?: WikiPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WikiPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWikiPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WikiPage model
   */
  readonly fields: WikiPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WikiPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WikiPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WikiPage model
   */
  interface WikiPageFieldRefs {
    readonly id: FieldRef<"WikiPage", 'Int'>
    readonly projectId: FieldRef<"WikiPage", 'Int'>
    readonly title: FieldRef<"WikiPage", 'String'>
    readonly content: FieldRef<"WikiPage", 'String'>
    readonly creatorId: FieldRef<"WikiPage", 'Int'>
    readonly modifierId: FieldRef<"WikiPage", 'Int'>
    readonly createdAt: FieldRef<"WikiPage", 'DateTime'>
    readonly updatedAt: FieldRef<"WikiPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WikiPage findUnique
   */
  export type WikiPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage findUniqueOrThrow
   */
  export type WikiPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage findFirst
   */
  export type WikiPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WikiPages.
     */
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage findFirstOrThrow
   */
  export type WikiPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WikiPages.
     */
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage findMany
   */
  export type WikiPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter, which WikiPages to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage create
   */
  export type WikiPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * The data needed to create a WikiPage.
     */
    data: XOR<WikiPageCreateInput, WikiPageUncheckedCreateInput>
  }

  /**
   * WikiPage createMany
   */
  export type WikiPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WikiPages.
     */
    data: WikiPageCreateManyInput | WikiPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WikiPage createManyAndReturn
   */
  export type WikiPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data used to create many WikiPages.
     */
    data: WikiPageCreateManyInput | WikiPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WikiPage update
   */
  export type WikiPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * The data needed to update a WikiPage.
     */
    data: XOR<WikiPageUpdateInput, WikiPageUncheckedUpdateInput>
    /**
     * Choose, which WikiPage to update.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage updateMany
   */
  export type WikiPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WikiPages.
     */
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyInput>
    /**
     * Filter which WikiPages to update
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to update.
     */
    limit?: number
  }

  /**
   * WikiPage updateManyAndReturn
   */
  export type WikiPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data used to update WikiPages.
     */
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyInput>
    /**
     * Filter which WikiPages to update
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WikiPage upsert
   */
  export type WikiPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * The filter to search for the WikiPage to update in case it exists.
     */
    where: WikiPageWhereUniqueInput
    /**
     * In case the WikiPage found by the `where` argument doesn't exist, create a new WikiPage with this data.
     */
    create: XOR<WikiPageCreateInput, WikiPageUncheckedCreateInput>
    /**
     * In case the WikiPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WikiPageUpdateInput, WikiPageUncheckedUpdateInput>
  }

  /**
   * WikiPage delete
   */
  export type WikiPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
    /**
     * Filter which WikiPage to delete.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage deleteMany
   */
  export type WikiPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WikiPages to delete
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to delete.
     */
    limit?: number
  }

  /**
   * WikiPage without action
   */
  export type WikiPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WikiPageInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    rateLimit: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    id: number | null
    userId: number | null
    rateLimit: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    keyPrefix: string | null
    keyHash: string | null
    rateLimit: number | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    keyPrefix: string | null
    keyHash: string | null
    rateLimit: number | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    keyPrefix: number
    keyHash: number
    permissions: number
    rateLimit: number
    lastUsedAt: number
    expiresAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    id?: true
    userId?: true
    rateLimit?: true
  }

  export type ApiKeySumAggregateInputType = {
    id?: true
    userId?: true
    rateLimit?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    keyPrefix?: true
    keyHash?: true
    rateLimit?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    keyPrefix?: true
    keyHash?: true
    rateLimit?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    keyPrefix?: true
    keyHash?: true
    permissions?: true
    rateLimit?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: number
    userId: number
    name: string
    keyPrefix: string
    keyHash: string
    permissions: JsonValue
    rateLimit: number
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    keyPrefix?: boolean
    keyHash?: boolean
    permissions?: boolean
    rateLimit?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    keyPrefix?: boolean
    keyHash?: boolean
    permissions?: boolean
    rateLimit?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    keyPrefix?: boolean
    keyHash?: boolean
    permissions?: boolean
    rateLimit?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    keyPrefix?: boolean
    keyHash?: boolean
    permissions?: boolean
    rateLimit?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "keyPrefix" | "keyHash" | "permissions" | "rateLimit" | "lastUsedAt" | "expiresAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      keyPrefix: string
      keyHash: string
      permissions: Prisma.JsonValue
      rateLimit: number
      lastUsedAt: Date | null
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'Int'>
    readonly userId: FieldRef<"ApiKey", 'Int'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly keyPrefix: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly permissions: FieldRef<"ApiKey", 'Json'>
    readonly rateLimit: FieldRef<"ApiKey", 'Int'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    failureCount: number | null
  }

  export type WebhookSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    failureCount: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    lastSuccess: Date | null
    lastFailure: Date | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    lastSuccess: Date | null
    lastFailure: Date | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    url: number
    secret: number
    events: number
    isActive: number
    lastSuccess: number
    lastFailure: number
    failureCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    id?: true
    projectId?: true
    failureCount?: true
  }

  export type WebhookSumAggregateInputType = {
    id?: true
    projectId?: true
    failureCount?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    lastSuccess?: true
    lastFailure?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    lastSuccess?: true
    lastFailure?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    url?: true
    secret?: true
    events?: true
    isActive?: true
    lastSuccess?: true
    lastFailure?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: number
    projectId: number
    name: string
    url: string
    secret: string
    events: JsonValue
    isActive: boolean
    lastSuccess: Date | null
    lastFailure: Date | null
    failureCount: number
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    lastSuccess?: boolean
    lastFailure?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "url" | "secret" | "events" | "isActive" | "lastSuccess" | "lastFailure" | "failureCount" | "createdAt" | "updatedAt", ExtArgs["result"]["webhook"]>
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      url: string
      secret: string
      events: Prisma.JsonValue
      isActive: boolean
      lastSuccess: Date | null
      lastFailure: Date | null
      failureCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends Webhook$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'Int'>
    readonly projectId: FieldRef<"Webhook", 'Int'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'Json'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly lastSuccess: FieldRef<"Webhook", 'DateTime'>
    readonly lastFailure: FieldRef<"Webhook", 'DateTime'>
    readonly failureCount: FieldRef<"Webhook", 'Int'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook.deliveries
   */
  export type Webhook$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    id: number | null
    webhookId: number | null
    statusCode: number | null
    duration: number | null
    attempts: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    id: number | null
    webhookId: number | null
    statusCode: number | null
    duration: number | null
    attempts: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: number | null
    webhookId: number | null
    event: string | null
    statusCode: number | null
    response: string | null
    duration: number | null
    success: boolean | null
    attempts: number | null
    deliveredAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: number | null
    webhookId: number | null
    event: string | null
    statusCode: number | null
    response: string | null
    duration: number | null
    success: boolean | null
    attempts: number | null
    deliveredAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    webhookId: number
    event: number
    payload: number
    statusCode: number
    response: number
    duration: number
    success: number
    attempts: number
    deliveredAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    id?: true
    webhookId?: true
    statusCode?: true
    duration?: true
    attempts?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    id?: true
    webhookId?: true
    statusCode?: true
    duration?: true
    attempts?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    statusCode?: true
    response?: true
    duration?: true
    success?: true
    attempts?: true
    deliveredAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    statusCode?: true
    response?: true
    duration?: true
    success?: true
    attempts?: true
    deliveredAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    payload?: true
    statusCode?: true
    response?: true
    duration?: true
    success?: true
    attempts?: true
    deliveredAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: number
    webhookId: number
    event: string
    payload: JsonValue
    statusCode: number | null
    response: string | null
    duration: number | null
    success: boolean
    attempts: number
    deliveredAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    statusCode?: boolean
    response?: boolean
    duration?: boolean
    success?: boolean
    attempts?: boolean
    deliveredAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    statusCode?: boolean
    response?: boolean
    duration?: boolean
    success?: boolean
    attempts?: boolean
    deliveredAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    statusCode?: boolean
    response?: boolean
    duration?: boolean
    success?: boolean
    attempts?: boolean
    deliveredAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    statusCode?: boolean
    response?: boolean
    duration?: boolean
    success?: boolean
    attempts?: boolean
    deliveredAt?: boolean
  }

  export type WebhookDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "webhookId" | "event" | "payload" | "statusCode" | "response" | "duration" | "success" | "attempts" | "deliveredAt", ExtArgs["result"]["webhookDelivery"]>
  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      webhookId: number
      event: string
      payload: Prisma.JsonValue
      statusCode: number | null
      response: string | null
      duration: number | null
      success: boolean
      attempts: number
      deliveredAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries and returns the data updated in the database.
     * @param {WebhookDeliveryUpdateManyAndReturnArgs} args - Arguments to update many WebhookDeliveries.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'Int'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'Int'>
    readonly event: FieldRef<"WebhookDelivery", 'String'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly statusCode: FieldRef<"WebhookDelivery", 'Int'>
    readonly response: FieldRef<"WebhookDelivery", 'String'>
    readonly duration: FieldRef<"WebhookDelivery", 'Int'>
    readonly success: FieldRef<"WebhookDelivery", 'Boolean'>
    readonly attempts: FieldRef<"WebhookDelivery", 'Int'>
    readonly deliveredAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
  }

  /**
   * WebhookDelivery updateManyAndReturn
   */
  export type WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to delete.
     */
    limit?: number
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    content: number
    data: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    data?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    type: string
    title: string
    content: string | null
    data: JsonValue
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    data?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "content" | "data" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      title: string
      content: string | null
      data: Prisma.JsonValue
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    entityId: number | null
  }

  export type ActivitySumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    entityId: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    eventType: string | null
    entityType: string | null
    entityId: number | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    eventType: string | null
    entityType: string | null
    entityId: number | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    eventType: number
    entityType: number
    entityId: number
    changes: number
    createdAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    entityId?: true
  }

  export type ActivitySumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    entityId?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    eventType?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    eventType?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    eventType?: true
    entityType?: true
    entityId?: true
    changes?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: number
    projectId: number
    userId: number | null
    eventType: string
    entityType: string
    entityId: number
    changes: JsonValue
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "eventType" | "entityType" | "entityId" | "changes" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | Activity$userArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number | null
      eventType: string
      entityType: string
      entityId: number
      changes: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Activity$userArgs<ExtArgs> = {}>(args?: Subset<T, Activity$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'Int'>
    readonly projectId: FieldRef<"Activity", 'Int'>
    readonly userId: FieldRef<"Activity", 'Int'>
    readonly eventType: FieldRef<"Activity", 'String'>
    readonly entityType: FieldRef<"Activity", 'String'>
    readonly entityId: FieldRef<"Activity", 'Int'>
    readonly changes: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.user
   */
  export type Activity$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    ip: string | null
    userAgent: string | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    ip: string | null
    userAgent: string | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ip: number
    userAgent: number
    isUsed: number
    createdAt: number
    _all: number
  }


  export type PasswordResetAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ip?: true
    userAgent?: true
    isUsed?: true
    createdAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ip?: true
    userAgent?: true
    isUsed?: true
    createdAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ip?: true
    userAgent?: true
    isUsed?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _avg?: PasswordResetAvgAggregateInputType
    _sum?: PasswordResetSumAggregateInputType
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    ip: string
    userAgent: string
    isUsed: boolean
    createdAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ip?: boolean
    userAgent?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ip?: boolean
    userAgent?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ip?: boolean
    userAgent?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ip?: boolean
    userAgent?: boolean
    isUsed?: boolean
    createdAt?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ip" | "userAgent" | "isUsed" | "createdAt", ExtArgs["result"]["passwordReset"]>
  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      ip: string
      userAgent: string
      isUsed: boolean
      createdAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {PasswordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'Int'>
    readonly userId: FieldRef<"PasswordReset", 'Int'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly ip: FieldRef<"PasswordReset", 'String'>
    readonly userAgent: FieldRef<"PasswordReset", 'String'>
    readonly isUsed: FieldRef<"PasswordReset", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset updateManyAndReturn
   */
  export type PasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model LastLogin
   */

  export type AggregateLastLogin = {
    _count: LastLoginCountAggregateOutputType | null
    _avg: LastLoginAvgAggregateOutputType | null
    _sum: LastLoginSumAggregateOutputType | null
    _min: LastLoginMinAggregateOutputType | null
    _max: LastLoginMaxAggregateOutputType | null
  }

  export type LastLoginAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LastLoginSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LastLoginMinAggregateOutputType = {
    id: number | null
    userId: number | null
    authType: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type LastLoginMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    authType: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type LastLoginCountAggregateOutputType = {
    id: number
    userId: number
    authType: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type LastLoginAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LastLoginSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LastLoginMinAggregateInputType = {
    id?: true
    userId?: true
    authType?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type LastLoginMaxAggregateInputType = {
    id?: true
    userId?: true
    authType?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type LastLoginCountAggregateInputType = {
    id?: true
    userId?: true
    authType?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type LastLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LastLogin to aggregate.
     */
    where?: LastLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastLogins to fetch.
     */
    orderBy?: LastLoginOrderByWithRelationInput | LastLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LastLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LastLogins
    **/
    _count?: true | LastLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LastLoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LastLoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LastLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LastLoginMaxAggregateInputType
  }

  export type GetLastLoginAggregateType<T extends LastLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateLastLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLastLogin[P]>
      : GetScalarType<T[P], AggregateLastLogin[P]>
  }




  export type LastLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastLoginWhereInput
    orderBy?: LastLoginOrderByWithAggregationInput | LastLoginOrderByWithAggregationInput[]
    by: LastLoginScalarFieldEnum[] | LastLoginScalarFieldEnum
    having?: LastLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LastLoginCountAggregateInputType | true
    _avg?: LastLoginAvgAggregateInputType
    _sum?: LastLoginSumAggregateInputType
    _min?: LastLoginMinAggregateInputType
    _max?: LastLoginMaxAggregateInputType
  }

  export type LastLoginGroupByOutputType = {
    id: number
    userId: number
    authType: string
    ip: string
    userAgent: string
    createdAt: Date
    _count: LastLoginCountAggregateOutputType | null
    _avg: LastLoginAvgAggregateOutputType | null
    _sum: LastLoginSumAggregateOutputType | null
    _min: LastLoginMinAggregateOutputType | null
    _max: LastLoginMaxAggregateOutputType | null
  }

  type GetLastLoginGroupByPayload<T extends LastLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LastLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LastLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LastLoginGroupByOutputType[P]>
            : GetScalarType<T[P], LastLoginGroupByOutputType[P]>
        }
      >
    >


  export type LastLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    authType?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lastLogin"]>

  export type LastLoginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    authType?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lastLogin"]>

  export type LastLoginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    authType?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lastLogin"]>

  export type LastLoginSelectScalar = {
    id?: boolean
    userId?: boolean
    authType?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type LastLoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "authType" | "ip" | "userAgent" | "createdAt", ExtArgs["result"]["lastLogin"]>
  export type LastLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LastLoginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LastLoginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LastLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LastLogin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      authType: string
      ip: string
      userAgent: string
      createdAt: Date
    }, ExtArgs["result"]["lastLogin"]>
    composites: {}
  }

  type LastLoginGetPayload<S extends boolean | null | undefined | LastLoginDefaultArgs> = $Result.GetResult<Prisma.$LastLoginPayload, S>

  type LastLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LastLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LastLoginCountAggregateInputType | true
    }

  export interface LastLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LastLogin'], meta: { name: 'LastLogin' } }
    /**
     * Find zero or one LastLogin that matches the filter.
     * @param {LastLoginFindUniqueArgs} args - Arguments to find a LastLogin
     * @example
     * // Get one LastLogin
     * const lastLogin = await prisma.lastLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LastLoginFindUniqueArgs>(args: SelectSubset<T, LastLoginFindUniqueArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LastLogin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LastLoginFindUniqueOrThrowArgs} args - Arguments to find a LastLogin
     * @example
     * // Get one LastLogin
     * const lastLogin = await prisma.lastLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LastLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, LastLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LastLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginFindFirstArgs} args - Arguments to find a LastLogin
     * @example
     * // Get one LastLogin
     * const lastLogin = await prisma.lastLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LastLoginFindFirstArgs>(args?: SelectSubset<T, LastLoginFindFirstArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LastLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginFindFirstOrThrowArgs} args - Arguments to find a LastLogin
     * @example
     * // Get one LastLogin
     * const lastLogin = await prisma.lastLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LastLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, LastLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LastLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LastLogins
     * const lastLogins = await prisma.lastLogin.findMany()
     * 
     * // Get first 10 LastLogins
     * const lastLogins = await prisma.lastLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lastLoginWithIdOnly = await prisma.lastLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LastLoginFindManyArgs>(args?: SelectSubset<T, LastLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LastLogin.
     * @param {LastLoginCreateArgs} args - Arguments to create a LastLogin.
     * @example
     * // Create one LastLogin
     * const LastLogin = await prisma.lastLogin.create({
     *   data: {
     *     // ... data to create a LastLogin
     *   }
     * })
     * 
     */
    create<T extends LastLoginCreateArgs>(args: SelectSubset<T, LastLoginCreateArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LastLogins.
     * @param {LastLoginCreateManyArgs} args - Arguments to create many LastLogins.
     * @example
     * // Create many LastLogins
     * const lastLogin = await prisma.lastLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LastLoginCreateManyArgs>(args?: SelectSubset<T, LastLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LastLogins and returns the data saved in the database.
     * @param {LastLoginCreateManyAndReturnArgs} args - Arguments to create many LastLogins.
     * @example
     * // Create many LastLogins
     * const lastLogin = await prisma.lastLogin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LastLogins and only return the `id`
     * const lastLoginWithIdOnly = await prisma.lastLogin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LastLoginCreateManyAndReturnArgs>(args?: SelectSubset<T, LastLoginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LastLogin.
     * @param {LastLoginDeleteArgs} args - Arguments to delete one LastLogin.
     * @example
     * // Delete one LastLogin
     * const LastLogin = await prisma.lastLogin.delete({
     *   where: {
     *     // ... filter to delete one LastLogin
     *   }
     * })
     * 
     */
    delete<T extends LastLoginDeleteArgs>(args: SelectSubset<T, LastLoginDeleteArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LastLogin.
     * @param {LastLoginUpdateArgs} args - Arguments to update one LastLogin.
     * @example
     * // Update one LastLogin
     * const lastLogin = await prisma.lastLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LastLoginUpdateArgs>(args: SelectSubset<T, LastLoginUpdateArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LastLogins.
     * @param {LastLoginDeleteManyArgs} args - Arguments to filter LastLogins to delete.
     * @example
     * // Delete a few LastLogins
     * const { count } = await prisma.lastLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LastLoginDeleteManyArgs>(args?: SelectSubset<T, LastLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LastLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LastLogins
     * const lastLogin = await prisma.lastLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LastLoginUpdateManyArgs>(args: SelectSubset<T, LastLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LastLogins and returns the data updated in the database.
     * @param {LastLoginUpdateManyAndReturnArgs} args - Arguments to update many LastLogins.
     * @example
     * // Update many LastLogins
     * const lastLogin = await prisma.lastLogin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LastLogins and only return the `id`
     * const lastLoginWithIdOnly = await prisma.lastLogin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LastLoginUpdateManyAndReturnArgs>(args: SelectSubset<T, LastLoginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LastLogin.
     * @param {LastLoginUpsertArgs} args - Arguments to update or create a LastLogin.
     * @example
     * // Update or create a LastLogin
     * const lastLogin = await prisma.lastLogin.upsert({
     *   create: {
     *     // ... data to create a LastLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LastLogin we want to update
     *   }
     * })
     */
    upsert<T extends LastLoginUpsertArgs>(args: SelectSubset<T, LastLoginUpsertArgs<ExtArgs>>): Prisma__LastLoginClient<$Result.GetResult<Prisma.$LastLoginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LastLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginCountArgs} args - Arguments to filter LastLogins to count.
     * @example
     * // Count the number of LastLogins
     * const count = await prisma.lastLogin.count({
     *   where: {
     *     // ... the filter for the LastLogins we want to count
     *   }
     * })
    **/
    count<T extends LastLoginCountArgs>(
      args?: Subset<T, LastLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LastLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LastLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LastLoginAggregateArgs>(args: Subset<T, LastLoginAggregateArgs>): Prisma.PrismaPromise<GetLastLoginAggregateType<T>>

    /**
     * Group by LastLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LastLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LastLoginGroupByArgs['orderBy'] }
        : { orderBy?: LastLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LastLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLastLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LastLogin model
   */
  readonly fields: LastLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LastLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LastLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LastLogin model
   */
  interface LastLoginFieldRefs {
    readonly id: FieldRef<"LastLogin", 'Int'>
    readonly userId: FieldRef<"LastLogin", 'Int'>
    readonly authType: FieldRef<"LastLogin", 'String'>
    readonly ip: FieldRef<"LastLogin", 'String'>
    readonly userAgent: FieldRef<"LastLogin", 'String'>
    readonly createdAt: FieldRef<"LastLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LastLogin findUnique
   */
  export type LastLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * Filter, which LastLogin to fetch.
     */
    where: LastLoginWhereUniqueInput
  }

  /**
   * LastLogin findUniqueOrThrow
   */
  export type LastLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * Filter, which LastLogin to fetch.
     */
    where: LastLoginWhereUniqueInput
  }

  /**
   * LastLogin findFirst
   */
  export type LastLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * Filter, which LastLogin to fetch.
     */
    where?: LastLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastLogins to fetch.
     */
    orderBy?: LastLoginOrderByWithRelationInput | LastLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LastLogins.
     */
    cursor?: LastLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LastLogins.
     */
    distinct?: LastLoginScalarFieldEnum | LastLoginScalarFieldEnum[]
  }

  /**
   * LastLogin findFirstOrThrow
   */
  export type LastLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * Filter, which LastLogin to fetch.
     */
    where?: LastLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastLogins to fetch.
     */
    orderBy?: LastLoginOrderByWithRelationInput | LastLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LastLogins.
     */
    cursor?: LastLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LastLogins.
     */
    distinct?: LastLoginScalarFieldEnum | LastLoginScalarFieldEnum[]
  }

  /**
   * LastLogin findMany
   */
  export type LastLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * Filter, which LastLogins to fetch.
     */
    where?: LastLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastLogins to fetch.
     */
    orderBy?: LastLoginOrderByWithRelationInput | LastLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LastLogins.
     */
    cursor?: LastLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastLogins.
     */
    skip?: number
    distinct?: LastLoginScalarFieldEnum | LastLoginScalarFieldEnum[]
  }

  /**
   * LastLogin create
   */
  export type LastLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a LastLogin.
     */
    data: XOR<LastLoginCreateInput, LastLoginUncheckedCreateInput>
  }

  /**
   * LastLogin createMany
   */
  export type LastLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LastLogins.
     */
    data: LastLoginCreateManyInput | LastLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LastLogin createManyAndReturn
   */
  export type LastLoginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * The data used to create many LastLogins.
     */
    data: LastLoginCreateManyInput | LastLoginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LastLogin update
   */
  export type LastLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a LastLogin.
     */
    data: XOR<LastLoginUpdateInput, LastLoginUncheckedUpdateInput>
    /**
     * Choose, which LastLogin to update.
     */
    where: LastLoginWhereUniqueInput
  }

  /**
   * LastLogin updateMany
   */
  export type LastLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LastLogins.
     */
    data: XOR<LastLoginUpdateManyMutationInput, LastLoginUncheckedUpdateManyInput>
    /**
     * Filter which LastLogins to update
     */
    where?: LastLoginWhereInput
    /**
     * Limit how many LastLogins to update.
     */
    limit?: number
  }

  /**
   * LastLogin updateManyAndReturn
   */
  export type LastLoginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * The data used to update LastLogins.
     */
    data: XOR<LastLoginUpdateManyMutationInput, LastLoginUncheckedUpdateManyInput>
    /**
     * Filter which LastLogins to update
     */
    where?: LastLoginWhereInput
    /**
     * Limit how many LastLogins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LastLogin upsert
   */
  export type LastLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the LastLogin to update in case it exists.
     */
    where: LastLoginWhereUniqueInput
    /**
     * In case the LastLogin found by the `where` argument doesn't exist, create a new LastLogin with this data.
     */
    create: XOR<LastLoginCreateInput, LastLoginUncheckedCreateInput>
    /**
     * In case the LastLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LastLoginUpdateInput, LastLoginUncheckedUpdateInput>
  }

  /**
   * LastLogin delete
   */
  export type LastLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
    /**
     * Filter which LastLogin to delete.
     */
    where: LastLoginWhereUniqueInput
  }

  /**
   * LastLogin deleteMany
   */
  export type LastLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LastLogins to delete
     */
    where?: LastLoginWhereInput
    /**
     * Limit how many LastLogins to delete.
     */
    limit?: number
  }

  /**
   * LastLogin without action
   */
  export type LastLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastLogin
     */
    select?: LastLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastLogin
     */
    omit?: LastLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastLoginInclude<ExtArgs> | null
  }


  /**
   * Model UserMetadata
   */

  export type AggregateUserMetadata = {
    _count: UserMetadataCountAggregateOutputType | null
    _avg: UserMetadataAvgAggregateOutputType | null
    _sum: UserMetadataSumAggregateOutputType | null
    _min: UserMetadataMinAggregateOutputType | null
    _max: UserMetadataMaxAggregateOutputType | null
  }

  export type UserMetadataAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserMetadataSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserMetadataMinAggregateOutputType = {
    id: number | null
    userId: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMetadataMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMetadataCountAggregateOutputType = {
    id: number
    userId: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMetadataAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserMetadataSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserMetadataMinAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMetadataMaxAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMetadataCountAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMetadata to aggregate.
     */
    where?: UserMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetadata to fetch.
     */
    orderBy?: UserMetadataOrderByWithRelationInput | UserMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMetadata
    **/
    _count?: true | UserMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMetadataMaxAggregateInputType
  }

  export type GetUserMetadataAggregateType<T extends UserMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMetadata[P]>
      : GetScalarType<T[P], AggregateUserMetadata[P]>
  }




  export type UserMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMetadataWhereInput
    orderBy?: UserMetadataOrderByWithAggregationInput | UserMetadataOrderByWithAggregationInput[]
    by: UserMetadataScalarFieldEnum[] | UserMetadataScalarFieldEnum
    having?: UserMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMetadataCountAggregateInputType | true
    _avg?: UserMetadataAvgAggregateInputType
    _sum?: UserMetadataSumAggregateInputType
    _min?: UserMetadataMinAggregateInputType
    _max?: UserMetadataMaxAggregateInputType
  }

  export type UserMetadataGroupByOutputType = {
    id: number
    userId: number
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: UserMetadataCountAggregateOutputType | null
    _avg: UserMetadataAvgAggregateOutputType | null
    _sum: UserMetadataSumAggregateOutputType | null
    _min: UserMetadataMinAggregateOutputType | null
    _max: UserMetadataMaxAggregateOutputType | null
  }

  type GetUserMetadataGroupByPayload<T extends UserMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], UserMetadataGroupByOutputType[P]>
        }
      >
    >


  export type UserMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMetadata"]>

  export type UserMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMetadata"]>

  export type UserMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMetadata"]>

  export type UserMetadataSelectScalar = {
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["userMetadata"]>
  export type UserMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMetadata"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userMetadata"]>
    composites: {}
  }

  type UserMetadataGetPayload<S extends boolean | null | undefined | UserMetadataDefaultArgs> = $Result.GetResult<Prisma.$UserMetadataPayload, S>

  type UserMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMetadataCountAggregateInputType | true
    }

  export interface UserMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMetadata'], meta: { name: 'UserMetadata' } }
    /**
     * Find zero or one UserMetadata that matches the filter.
     * @param {UserMetadataFindUniqueArgs} args - Arguments to find a UserMetadata
     * @example
     * // Get one UserMetadata
     * const userMetadata = await prisma.userMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMetadataFindUniqueArgs>(args: SelectSubset<T, UserMetadataFindUniqueArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMetadataFindUniqueOrThrowArgs} args - Arguments to find a UserMetadata
     * @example
     * // Get one UserMetadata
     * const userMetadata = await prisma.userMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataFindFirstArgs} args - Arguments to find a UserMetadata
     * @example
     * // Get one UserMetadata
     * const userMetadata = await prisma.userMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMetadataFindFirstArgs>(args?: SelectSubset<T, UserMetadataFindFirstArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataFindFirstOrThrowArgs} args - Arguments to find a UserMetadata
     * @example
     * // Get one UserMetadata
     * const userMetadata = await prisma.userMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMetadata
     * const userMetadata = await prisma.userMetadata.findMany()
     * 
     * // Get first 10 UserMetadata
     * const userMetadata = await prisma.userMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMetadataWithIdOnly = await prisma.userMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMetadataFindManyArgs>(args?: SelectSubset<T, UserMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserMetadata.
     * @param {UserMetadataCreateArgs} args - Arguments to create a UserMetadata.
     * @example
     * // Create one UserMetadata
     * const UserMetadata = await prisma.userMetadata.create({
     *   data: {
     *     // ... data to create a UserMetadata
     *   }
     * })
     * 
     */
    create<T extends UserMetadataCreateArgs>(args: SelectSubset<T, UserMetadataCreateArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserMetadata.
     * @param {UserMetadataCreateManyArgs} args - Arguments to create many UserMetadata.
     * @example
     * // Create many UserMetadata
     * const userMetadata = await prisma.userMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMetadataCreateManyArgs>(args?: SelectSubset<T, UserMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMetadata and returns the data saved in the database.
     * @param {UserMetadataCreateManyAndReturnArgs} args - Arguments to create many UserMetadata.
     * @example
     * // Create many UserMetadata
     * const userMetadata = await prisma.userMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMetadata and only return the `id`
     * const userMetadataWithIdOnly = await prisma.userMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserMetadata.
     * @param {UserMetadataDeleteArgs} args - Arguments to delete one UserMetadata.
     * @example
     * // Delete one UserMetadata
     * const UserMetadata = await prisma.userMetadata.delete({
     *   where: {
     *     // ... filter to delete one UserMetadata
     *   }
     * })
     * 
     */
    delete<T extends UserMetadataDeleteArgs>(args: SelectSubset<T, UserMetadataDeleteArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserMetadata.
     * @param {UserMetadataUpdateArgs} args - Arguments to update one UserMetadata.
     * @example
     * // Update one UserMetadata
     * const userMetadata = await prisma.userMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMetadataUpdateArgs>(args: SelectSubset<T, UserMetadataUpdateArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserMetadata.
     * @param {UserMetadataDeleteManyArgs} args - Arguments to filter UserMetadata to delete.
     * @example
     * // Delete a few UserMetadata
     * const { count } = await prisma.userMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMetadataDeleteManyArgs>(args?: SelectSubset<T, UserMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMetadata
     * const userMetadata = await prisma.userMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMetadataUpdateManyArgs>(args: SelectSubset<T, UserMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMetadata and returns the data updated in the database.
     * @param {UserMetadataUpdateManyAndReturnArgs} args - Arguments to update many UserMetadata.
     * @example
     * // Update many UserMetadata
     * const userMetadata = await prisma.userMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserMetadata and only return the `id`
     * const userMetadataWithIdOnly = await prisma.userMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, UserMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserMetadata.
     * @param {UserMetadataUpsertArgs} args - Arguments to update or create a UserMetadata.
     * @example
     * // Update or create a UserMetadata
     * const userMetadata = await prisma.userMetadata.upsert({
     *   create: {
     *     // ... data to create a UserMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMetadata we want to update
     *   }
     * })
     */
    upsert<T extends UserMetadataUpsertArgs>(args: SelectSubset<T, UserMetadataUpsertArgs<ExtArgs>>): Prisma__UserMetadataClient<$Result.GetResult<Prisma.$UserMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataCountArgs} args - Arguments to filter UserMetadata to count.
     * @example
     * // Count the number of UserMetadata
     * const count = await prisma.userMetadata.count({
     *   where: {
     *     // ... the filter for the UserMetadata we want to count
     *   }
     * })
    **/
    count<T extends UserMetadataCountArgs>(
      args?: Subset<T, UserMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMetadataAggregateArgs>(args: Subset<T, UserMetadataAggregateArgs>): Prisma.PrismaPromise<GetUserMetadataAggregateType<T>>

    /**
     * Group by UserMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMetadataGroupByArgs['orderBy'] }
        : { orderBy?: UserMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMetadata model
   */
  readonly fields: UserMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMetadata model
   */
  interface UserMetadataFieldRefs {
    readonly id: FieldRef<"UserMetadata", 'Int'>
    readonly userId: FieldRef<"UserMetadata", 'Int'>
    readonly key: FieldRef<"UserMetadata", 'String'>
    readonly value: FieldRef<"UserMetadata", 'String'>
    readonly createdAt: FieldRef<"UserMetadata", 'DateTime'>
    readonly updatedAt: FieldRef<"UserMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMetadata findUnique
   */
  export type UserMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * Filter, which UserMetadata to fetch.
     */
    where: UserMetadataWhereUniqueInput
  }

  /**
   * UserMetadata findUniqueOrThrow
   */
  export type UserMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * Filter, which UserMetadata to fetch.
     */
    where: UserMetadataWhereUniqueInput
  }

  /**
   * UserMetadata findFirst
   */
  export type UserMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * Filter, which UserMetadata to fetch.
     */
    where?: UserMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetadata to fetch.
     */
    orderBy?: UserMetadataOrderByWithRelationInput | UserMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMetadata.
     */
    cursor?: UserMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMetadata.
     */
    distinct?: UserMetadataScalarFieldEnum | UserMetadataScalarFieldEnum[]
  }

  /**
   * UserMetadata findFirstOrThrow
   */
  export type UserMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * Filter, which UserMetadata to fetch.
     */
    where?: UserMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetadata to fetch.
     */
    orderBy?: UserMetadataOrderByWithRelationInput | UserMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMetadata.
     */
    cursor?: UserMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMetadata.
     */
    distinct?: UserMetadataScalarFieldEnum | UserMetadataScalarFieldEnum[]
  }

  /**
   * UserMetadata findMany
   */
  export type UserMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * Filter, which UserMetadata to fetch.
     */
    where?: UserMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetadata to fetch.
     */
    orderBy?: UserMetadataOrderByWithRelationInput | UserMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMetadata.
     */
    cursor?: UserMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetadata.
     */
    skip?: number
    distinct?: UserMetadataScalarFieldEnum | UserMetadataScalarFieldEnum[]
  }

  /**
   * UserMetadata create
   */
  export type UserMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMetadata.
     */
    data: XOR<UserMetadataCreateInput, UserMetadataUncheckedCreateInput>
  }

  /**
   * UserMetadata createMany
   */
  export type UserMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMetadata.
     */
    data: UserMetadataCreateManyInput | UserMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMetadata createManyAndReturn
   */
  export type UserMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many UserMetadata.
     */
    data: UserMetadataCreateManyInput | UserMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMetadata update
   */
  export type UserMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMetadata.
     */
    data: XOR<UserMetadataUpdateInput, UserMetadataUncheckedUpdateInput>
    /**
     * Choose, which UserMetadata to update.
     */
    where: UserMetadataWhereUniqueInput
  }

  /**
   * UserMetadata updateMany
   */
  export type UserMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMetadata.
     */
    data: XOR<UserMetadataUpdateManyMutationInput, UserMetadataUncheckedUpdateManyInput>
    /**
     * Filter which UserMetadata to update
     */
    where?: UserMetadataWhereInput
    /**
     * Limit how many UserMetadata to update.
     */
    limit?: number
  }

  /**
   * UserMetadata updateManyAndReturn
   */
  export type UserMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * The data used to update UserMetadata.
     */
    data: XOR<UserMetadataUpdateManyMutationInput, UserMetadataUncheckedUpdateManyInput>
    /**
     * Filter which UserMetadata to update
     */
    where?: UserMetadataWhereInput
    /**
     * Limit how many UserMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMetadata upsert
   */
  export type UserMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMetadata to update in case it exists.
     */
    where: UserMetadataWhereUniqueInput
    /**
     * In case the UserMetadata found by the `where` argument doesn't exist, create a new UserMetadata with this data.
     */
    create: XOR<UserMetadataCreateInput, UserMetadataUncheckedCreateInput>
    /**
     * In case the UserMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMetadataUpdateInput, UserMetadataUncheckedUpdateInput>
  }

  /**
   * UserMetadata delete
   */
  export type UserMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
    /**
     * Filter which UserMetadata to delete.
     */
    where: UserMetadataWhereUniqueInput
  }

  /**
   * UserMetadata deleteMany
   */
  export type UserMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMetadata to delete
     */
    where?: UserMetadataWhereInput
    /**
     * Limit how many UserMetadata to delete.
     */
    limit?: number
  }

  /**
   * UserMetadata without action
   */
  export type UserMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetadata
     */
    select?: UserMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMetadata
     */
    omit?: UserMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetadataInclude<ExtArgs> | null
  }


  /**
   * Model UserNotificationSetting
   */

  export type AggregateUserNotificationSetting = {
    _count: UserNotificationSettingCountAggregateOutputType | null
    _avg: UserNotificationSettingAvgAggregateOutputType | null
    _sum: UserNotificationSettingSumAggregateOutputType | null
    _min: UserNotificationSettingMinAggregateOutputType | null
    _max: UserNotificationSettingMaxAggregateOutputType | null
  }

  export type UserNotificationSettingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNotificationSettingSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNotificationSettingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    notificationType: string | null
    isEnabled: boolean | null
  }

  export type UserNotificationSettingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    notificationType: string | null
    isEnabled: boolean | null
  }

  export type UserNotificationSettingCountAggregateOutputType = {
    id: number
    userId: number
    notificationType: number
    isEnabled: number
    _all: number
  }


  export type UserNotificationSettingAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNotificationSettingSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNotificationSettingMinAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    isEnabled?: true
  }

  export type UserNotificationSettingMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    isEnabled?: true
  }

  export type UserNotificationSettingCountAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    isEnabled?: true
    _all?: true
  }

  export type UserNotificationSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationSetting to aggregate.
     */
    where?: UserNotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingOrderByWithRelationInput | UserNotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotificationSettings
    **/
    _count?: true | UserNotificationSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNotificationSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNotificationSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationSettingMaxAggregateInputType
  }

  export type GetUserNotificationSettingAggregateType<T extends UserNotificationSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotificationSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotificationSetting[P]>
      : GetScalarType<T[P], AggregateUserNotificationSetting[P]>
  }




  export type UserNotificationSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationSettingWhereInput
    orderBy?: UserNotificationSettingOrderByWithAggregationInput | UserNotificationSettingOrderByWithAggregationInput[]
    by: UserNotificationSettingScalarFieldEnum[] | UserNotificationSettingScalarFieldEnum
    having?: UserNotificationSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationSettingCountAggregateInputType | true
    _avg?: UserNotificationSettingAvgAggregateInputType
    _sum?: UserNotificationSettingSumAggregateInputType
    _min?: UserNotificationSettingMinAggregateInputType
    _max?: UserNotificationSettingMaxAggregateInputType
  }

  export type UserNotificationSettingGroupByOutputType = {
    id: number
    userId: number
    notificationType: string
    isEnabled: boolean
    _count: UserNotificationSettingCountAggregateOutputType | null
    _avg: UserNotificationSettingAvgAggregateOutputType | null
    _sum: UserNotificationSettingSumAggregateOutputType | null
    _min: UserNotificationSettingMinAggregateOutputType | null
    _max: UserNotificationSettingMaxAggregateOutputType | null
  }

  type GetUserNotificationSettingGroupByPayload<T extends UserNotificationSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserNotificationSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    isEnabled?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotificationSetting"]>

  export type UserNotificationSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    isEnabled?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotificationSetting"]>

  export type UserNotificationSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    isEnabled?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotificationSetting"]>

  export type UserNotificationSettingSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    isEnabled?: boolean
  }

  export type UserNotificationSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "notificationType" | "isEnabled", ExtArgs["result"]["userNotificationSetting"]>
  export type UserNotificationSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNotificationSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNotificationSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserNotificationSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotificationSetting"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      notificationType: string
      isEnabled: boolean
    }, ExtArgs["result"]["userNotificationSetting"]>
    composites: {}
  }

  type UserNotificationSettingGetPayload<S extends boolean | null | undefined | UserNotificationSettingDefaultArgs> = $Result.GetResult<Prisma.$UserNotificationSettingPayload, S>

  type UserNotificationSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserNotificationSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNotificationSettingCountAggregateInputType | true
    }

  export interface UserNotificationSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotificationSetting'], meta: { name: 'UserNotificationSetting' } }
    /**
     * Find zero or one UserNotificationSetting that matches the filter.
     * @param {UserNotificationSettingFindUniqueArgs} args - Arguments to find a UserNotificationSetting
     * @example
     * // Get one UserNotificationSetting
     * const userNotificationSetting = await prisma.userNotificationSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationSettingFindUniqueArgs>(args: SelectSubset<T, UserNotificationSettingFindUniqueArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNotificationSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNotificationSettingFindUniqueOrThrowArgs} args - Arguments to find a UserNotificationSetting
     * @example
     * // Get one UserNotificationSetting
     * const userNotificationSetting = await prisma.userNotificationSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotificationSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotificationSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingFindFirstArgs} args - Arguments to find a UserNotificationSetting
     * @example
     * // Get one UserNotificationSetting
     * const userNotificationSetting = await prisma.userNotificationSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationSettingFindFirstArgs>(args?: SelectSubset<T, UserNotificationSettingFindFirstArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotificationSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingFindFirstOrThrowArgs} args - Arguments to find a UserNotificationSetting
     * @example
     * // Get one UserNotificationSetting
     * const userNotificationSetting = await prisma.userNotificationSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotificationSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSetting.findMany()
     * 
     * // Get first 10 UserNotificationSettings
     * const userNotificationSettings = await prisma.userNotificationSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationSettingWithIdOnly = await prisma.userNotificationSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotificationSettingFindManyArgs>(args?: SelectSubset<T, UserNotificationSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNotificationSetting.
     * @param {UserNotificationSettingCreateArgs} args - Arguments to create a UserNotificationSetting.
     * @example
     * // Create one UserNotificationSetting
     * const UserNotificationSetting = await prisma.userNotificationSetting.create({
     *   data: {
     *     // ... data to create a UserNotificationSetting
     *   }
     * })
     * 
     */
    create<T extends UserNotificationSettingCreateArgs>(args: SelectSubset<T, UserNotificationSettingCreateArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNotificationSettings.
     * @param {UserNotificationSettingCreateManyArgs} args - Arguments to create many UserNotificationSettings.
     * @example
     * // Create many UserNotificationSettings
     * const userNotificationSetting = await prisma.userNotificationSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotificationSettingCreateManyArgs>(args?: SelectSubset<T, UserNotificationSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotificationSettings and returns the data saved in the database.
     * @param {UserNotificationSettingCreateManyAndReturnArgs} args - Arguments to create many UserNotificationSettings.
     * @example
     * // Create many UserNotificationSettings
     * const userNotificationSetting = await prisma.userNotificationSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotificationSettings and only return the `id`
     * const userNotificationSettingWithIdOnly = await prisma.userNotificationSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNotificationSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNotificationSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserNotificationSetting.
     * @param {UserNotificationSettingDeleteArgs} args - Arguments to delete one UserNotificationSetting.
     * @example
     * // Delete one UserNotificationSetting
     * const UserNotificationSetting = await prisma.userNotificationSetting.delete({
     *   where: {
     *     // ... filter to delete one UserNotificationSetting
     *   }
     * })
     * 
     */
    delete<T extends UserNotificationSettingDeleteArgs>(args: SelectSubset<T, UserNotificationSettingDeleteArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNotificationSetting.
     * @param {UserNotificationSettingUpdateArgs} args - Arguments to update one UserNotificationSetting.
     * @example
     * // Update one UserNotificationSetting
     * const userNotificationSetting = await prisma.userNotificationSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotificationSettingUpdateArgs>(args: SelectSubset<T, UserNotificationSettingUpdateArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNotificationSettings.
     * @param {UserNotificationSettingDeleteManyArgs} args - Arguments to filter UserNotificationSettings to delete.
     * @example
     * // Delete a few UserNotificationSettings
     * const { count } = await prisma.userNotificationSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotificationSettingDeleteManyArgs>(args?: SelectSubset<T, UserNotificationSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotificationSettings
     * const userNotificationSetting = await prisma.userNotificationSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotificationSettingUpdateManyArgs>(args: SelectSubset<T, UserNotificationSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotificationSettings and returns the data updated in the database.
     * @param {UserNotificationSettingUpdateManyAndReturnArgs} args - Arguments to update many UserNotificationSettings.
     * @example
     * // Update many UserNotificationSettings
     * const userNotificationSetting = await prisma.userNotificationSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserNotificationSettings and only return the `id`
     * const userNotificationSettingWithIdOnly = await prisma.userNotificationSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserNotificationSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserNotificationSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserNotificationSetting.
     * @param {UserNotificationSettingUpsertArgs} args - Arguments to update or create a UserNotificationSetting.
     * @example
     * // Update or create a UserNotificationSetting
     * const userNotificationSetting = await prisma.userNotificationSetting.upsert({
     *   create: {
     *     // ... data to create a UserNotificationSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotificationSetting we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationSettingUpsertArgs>(args: SelectSubset<T, UserNotificationSettingUpsertArgs<ExtArgs>>): Prisma__UserNotificationSettingClient<$Result.GetResult<Prisma.$UserNotificationSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingCountArgs} args - Arguments to filter UserNotificationSettings to count.
     * @example
     * // Count the number of UserNotificationSettings
     * const count = await prisma.userNotificationSetting.count({
     *   where: {
     *     // ... the filter for the UserNotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends UserNotificationSettingCountArgs>(
      args?: Subset<T, UserNotificationSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotificationSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationSettingAggregateArgs>(args: Subset<T, UserNotificationSettingAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationSettingAggregateType<T>>

    /**
     * Group by UserNotificationSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotificationSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotificationSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotificationSetting model
   */
  readonly fields: UserNotificationSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotificationSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotificationSetting model
   */
  interface UserNotificationSettingFieldRefs {
    readonly id: FieldRef<"UserNotificationSetting", 'Int'>
    readonly userId: FieldRef<"UserNotificationSetting", 'Int'>
    readonly notificationType: FieldRef<"UserNotificationSetting", 'String'>
    readonly isEnabled: FieldRef<"UserNotificationSetting", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserNotificationSetting findUnique
   */
  export type UserNotificationSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSetting to fetch.
     */
    where: UserNotificationSettingWhereUniqueInput
  }

  /**
   * UserNotificationSetting findUniqueOrThrow
   */
  export type UserNotificationSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSetting to fetch.
     */
    where: UserNotificationSettingWhereUniqueInput
  }

  /**
   * UserNotificationSetting findFirst
   */
  export type UserNotificationSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSetting to fetch.
     */
    where?: UserNotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingOrderByWithRelationInput | UserNotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationSettings.
     */
    cursor?: UserNotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationSettings.
     */
    distinct?: UserNotificationSettingScalarFieldEnum | UserNotificationSettingScalarFieldEnum[]
  }

  /**
   * UserNotificationSetting findFirstOrThrow
   */
  export type UserNotificationSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSetting to fetch.
     */
    where?: UserNotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingOrderByWithRelationInput | UserNotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationSettings.
     */
    cursor?: UserNotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationSettings.
     */
    distinct?: UserNotificationSettingScalarFieldEnum | UserNotificationSettingScalarFieldEnum[]
  }

  /**
   * UserNotificationSetting findMany
   */
  export type UserNotificationSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserNotificationSettings to fetch.
     */
    where?: UserNotificationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationSettings to fetch.
     */
    orderBy?: UserNotificationSettingOrderByWithRelationInput | UserNotificationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotificationSettings.
     */
    cursor?: UserNotificationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationSettings.
     */
    skip?: number
    distinct?: UserNotificationSettingScalarFieldEnum | UserNotificationSettingScalarFieldEnum[]
  }

  /**
   * UserNotificationSetting create
   */
  export type UserNotificationSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNotificationSetting.
     */
    data: XOR<UserNotificationSettingCreateInput, UserNotificationSettingUncheckedCreateInput>
  }

  /**
   * UserNotificationSetting createMany
   */
  export type UserNotificationSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotificationSettings.
     */
    data: UserNotificationSettingCreateManyInput | UserNotificationSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotificationSetting createManyAndReturn
   */
  export type UserNotificationSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * The data used to create many UserNotificationSettings.
     */
    data: UserNotificationSettingCreateManyInput | UserNotificationSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNotificationSetting update
   */
  export type UserNotificationSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNotificationSetting.
     */
    data: XOR<UserNotificationSettingUpdateInput, UserNotificationSettingUncheckedUpdateInput>
    /**
     * Choose, which UserNotificationSetting to update.
     */
    where: UserNotificationSettingWhereUniqueInput
  }

  /**
   * UserNotificationSetting updateMany
   */
  export type UserNotificationSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotificationSettings.
     */
    data: XOR<UserNotificationSettingUpdateManyMutationInput, UserNotificationSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserNotificationSettings to update
     */
    where?: UserNotificationSettingWhereInput
    /**
     * Limit how many UserNotificationSettings to update.
     */
    limit?: number
  }

  /**
   * UserNotificationSetting updateManyAndReturn
   */
  export type UserNotificationSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * The data used to update UserNotificationSettings.
     */
    data: XOR<UserNotificationSettingUpdateManyMutationInput, UserNotificationSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserNotificationSettings to update
     */
    where?: UserNotificationSettingWhereInput
    /**
     * Limit how many UserNotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNotificationSetting upsert
   */
  export type UserNotificationSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNotificationSetting to update in case it exists.
     */
    where: UserNotificationSettingWhereUniqueInput
    /**
     * In case the UserNotificationSetting found by the `where` argument doesn't exist, create a new UserNotificationSetting with this data.
     */
    create: XOR<UserNotificationSettingCreateInput, UserNotificationSettingUncheckedCreateInput>
    /**
     * In case the UserNotificationSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotificationSettingUpdateInput, UserNotificationSettingUncheckedUpdateInput>
  }

  /**
   * UserNotificationSetting delete
   */
  export type UserNotificationSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
    /**
     * Filter which UserNotificationSetting to delete.
     */
    where: UserNotificationSettingWhereUniqueInput
  }

  /**
   * UserNotificationSetting deleteMany
   */
  export type UserNotificationSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationSettings to delete
     */
    where?: UserNotificationSettingWhereInput
    /**
     * Limit how many UserNotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * UserNotificationSetting without action
   */
  export type UserNotificationSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationSetting
     */
    select?: UserNotificationSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNotificationSetting
     */
    omit?: UserNotificationSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationSettingInclude<ExtArgs> | null
  }


  /**
   * Model UserAvatar
   */

  export type AggregateUserAvatar = {
    _count: UserAvatarCountAggregateOutputType | null
    _avg: UserAvatarAvgAggregateOutputType | null
    _sum: UserAvatarSumAggregateOutputType | null
    _min: UserAvatarMinAggregateOutputType | null
    _max: UserAvatarMaxAggregateOutputType | null
  }

  export type UserAvatarAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    size: number | null
  }

  export type UserAvatarSumAggregateOutputType = {
    id: number | null
    userId: number | null
    size: number | null
  }

  export type UserAvatarMinAggregateOutputType = {
    id: number | null
    userId: number | null
    data: Bytes | null
    mimeType: string | null
    size: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAvatarMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    data: Bytes | null
    mimeType: string | null
    size: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAvatarCountAggregateOutputType = {
    id: number
    userId: number
    data: number
    mimeType: number
    size: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvatarAvgAggregateInputType = {
    id?: true
    userId?: true
    size?: true
  }

  export type UserAvatarSumAggregateInputType = {
    id?: true
    userId?: true
    size?: true
  }

  export type UserAvatarMinAggregateInputType = {
    id?: true
    userId?: true
    data?: true
    mimeType?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAvatarMaxAggregateInputType = {
    id?: true
    userId?: true
    data?: true
    mimeType?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAvatarCountAggregateInputType = {
    id?: true
    userId?: true
    data?: true
    mimeType?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAvatarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAvatar to aggregate.
     */
    where?: UserAvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvatars to fetch.
     */
    orderBy?: UserAvatarOrderByWithRelationInput | UserAvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAvatars
    **/
    _count?: true | UserAvatarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvatarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAvatarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAvatarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAvatarMaxAggregateInputType
  }

  export type GetUserAvatarAggregateType<T extends UserAvatarAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAvatar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAvatar[P]>
      : GetScalarType<T[P], AggregateUserAvatar[P]>
  }




  export type UserAvatarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAvatarWhereInput
    orderBy?: UserAvatarOrderByWithAggregationInput | UserAvatarOrderByWithAggregationInput[]
    by: UserAvatarScalarFieldEnum[] | UserAvatarScalarFieldEnum
    having?: UserAvatarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAvatarCountAggregateInputType | true
    _avg?: UserAvatarAvgAggregateInputType
    _sum?: UserAvatarSumAggregateInputType
    _min?: UserAvatarMinAggregateInputType
    _max?: UserAvatarMaxAggregateInputType
  }

  export type UserAvatarGroupByOutputType = {
    id: number
    userId: number
    data: Bytes
    mimeType: string
    size: number
    createdAt: Date
    updatedAt: Date
    _count: UserAvatarCountAggregateOutputType | null
    _avg: UserAvatarAvgAggregateOutputType | null
    _sum: UserAvatarSumAggregateOutputType | null
    _min: UserAvatarMinAggregateOutputType | null
    _max: UserAvatarMaxAggregateOutputType | null
  }

  type GetUserAvatarGroupByPayload<T extends UserAvatarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAvatarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAvatarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAvatarGroupByOutputType[P]>
            : GetScalarType<T[P], UserAvatarGroupByOutputType[P]>
        }
      >
    >


  export type UserAvatarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAvatar"]>

  export type UserAvatarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAvatar"]>

  export type UserAvatarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAvatar"]>

  export type UserAvatarSelectScalar = {
    id?: boolean
    userId?: boolean
    data?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAvatarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "data" | "mimeType" | "size" | "createdAt" | "updatedAt", ExtArgs["result"]["userAvatar"]>
  export type UserAvatarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAvatarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAvatarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAvatarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAvatar"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      data: Prisma.Bytes
      mimeType: string
      size: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAvatar"]>
    composites: {}
  }

  type UserAvatarGetPayload<S extends boolean | null | undefined | UserAvatarDefaultArgs> = $Result.GetResult<Prisma.$UserAvatarPayload, S>

  type UserAvatarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAvatarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAvatarCountAggregateInputType | true
    }

  export interface UserAvatarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAvatar'], meta: { name: 'UserAvatar' } }
    /**
     * Find zero or one UserAvatar that matches the filter.
     * @param {UserAvatarFindUniqueArgs} args - Arguments to find a UserAvatar
     * @example
     * // Get one UserAvatar
     * const userAvatar = await prisma.userAvatar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAvatarFindUniqueArgs>(args: SelectSubset<T, UserAvatarFindUniqueArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAvatar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAvatarFindUniqueOrThrowArgs} args - Arguments to find a UserAvatar
     * @example
     * // Get one UserAvatar
     * const userAvatar = await prisma.userAvatar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAvatarFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAvatarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAvatar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarFindFirstArgs} args - Arguments to find a UserAvatar
     * @example
     * // Get one UserAvatar
     * const userAvatar = await prisma.userAvatar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAvatarFindFirstArgs>(args?: SelectSubset<T, UserAvatarFindFirstArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAvatar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarFindFirstOrThrowArgs} args - Arguments to find a UserAvatar
     * @example
     * // Get one UserAvatar
     * const userAvatar = await prisma.userAvatar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAvatarFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAvatarFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAvatars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAvatars
     * const userAvatars = await prisma.userAvatar.findMany()
     * 
     * // Get first 10 UserAvatars
     * const userAvatars = await prisma.userAvatar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAvatarWithIdOnly = await prisma.userAvatar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAvatarFindManyArgs>(args?: SelectSubset<T, UserAvatarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAvatar.
     * @param {UserAvatarCreateArgs} args - Arguments to create a UserAvatar.
     * @example
     * // Create one UserAvatar
     * const UserAvatar = await prisma.userAvatar.create({
     *   data: {
     *     // ... data to create a UserAvatar
     *   }
     * })
     * 
     */
    create<T extends UserAvatarCreateArgs>(args: SelectSubset<T, UserAvatarCreateArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAvatars.
     * @param {UserAvatarCreateManyArgs} args - Arguments to create many UserAvatars.
     * @example
     * // Create many UserAvatars
     * const userAvatar = await prisma.userAvatar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAvatarCreateManyArgs>(args?: SelectSubset<T, UserAvatarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAvatars and returns the data saved in the database.
     * @param {UserAvatarCreateManyAndReturnArgs} args - Arguments to create many UserAvatars.
     * @example
     * // Create many UserAvatars
     * const userAvatar = await prisma.userAvatar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAvatars and only return the `id`
     * const userAvatarWithIdOnly = await prisma.userAvatar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAvatarCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAvatarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAvatar.
     * @param {UserAvatarDeleteArgs} args - Arguments to delete one UserAvatar.
     * @example
     * // Delete one UserAvatar
     * const UserAvatar = await prisma.userAvatar.delete({
     *   where: {
     *     // ... filter to delete one UserAvatar
     *   }
     * })
     * 
     */
    delete<T extends UserAvatarDeleteArgs>(args: SelectSubset<T, UserAvatarDeleteArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAvatar.
     * @param {UserAvatarUpdateArgs} args - Arguments to update one UserAvatar.
     * @example
     * // Update one UserAvatar
     * const userAvatar = await prisma.userAvatar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAvatarUpdateArgs>(args: SelectSubset<T, UserAvatarUpdateArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAvatars.
     * @param {UserAvatarDeleteManyArgs} args - Arguments to filter UserAvatars to delete.
     * @example
     * // Delete a few UserAvatars
     * const { count } = await prisma.userAvatar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAvatarDeleteManyArgs>(args?: SelectSubset<T, UserAvatarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAvatars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAvatars
     * const userAvatar = await prisma.userAvatar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAvatarUpdateManyArgs>(args: SelectSubset<T, UserAvatarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAvatars and returns the data updated in the database.
     * @param {UserAvatarUpdateManyAndReturnArgs} args - Arguments to update many UserAvatars.
     * @example
     * // Update many UserAvatars
     * const userAvatar = await prisma.userAvatar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAvatars and only return the `id`
     * const userAvatarWithIdOnly = await prisma.userAvatar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAvatarUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAvatarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAvatar.
     * @param {UserAvatarUpsertArgs} args - Arguments to update or create a UserAvatar.
     * @example
     * // Update or create a UserAvatar
     * const userAvatar = await prisma.userAvatar.upsert({
     *   create: {
     *     // ... data to create a UserAvatar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAvatar we want to update
     *   }
     * })
     */
    upsert<T extends UserAvatarUpsertArgs>(args: SelectSubset<T, UserAvatarUpsertArgs<ExtArgs>>): Prisma__UserAvatarClient<$Result.GetResult<Prisma.$UserAvatarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAvatars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarCountArgs} args - Arguments to filter UserAvatars to count.
     * @example
     * // Count the number of UserAvatars
     * const count = await prisma.userAvatar.count({
     *   where: {
     *     // ... the filter for the UserAvatars we want to count
     *   }
     * })
    **/
    count<T extends UserAvatarCountArgs>(
      args?: Subset<T, UserAvatarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAvatarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAvatar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAvatarAggregateArgs>(args: Subset<T, UserAvatarAggregateArgs>): Prisma.PrismaPromise<GetUserAvatarAggregateType<T>>

    /**
     * Group by UserAvatar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAvatarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAvatarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAvatarGroupByArgs['orderBy'] }
        : { orderBy?: UserAvatarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAvatarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAvatarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAvatar model
   */
  readonly fields: UserAvatarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAvatar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAvatarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAvatar model
   */
  interface UserAvatarFieldRefs {
    readonly id: FieldRef<"UserAvatar", 'Int'>
    readonly userId: FieldRef<"UserAvatar", 'Int'>
    readonly data: FieldRef<"UserAvatar", 'Bytes'>
    readonly mimeType: FieldRef<"UserAvatar", 'String'>
    readonly size: FieldRef<"UserAvatar", 'Int'>
    readonly createdAt: FieldRef<"UserAvatar", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAvatar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAvatar findUnique
   */
  export type UserAvatarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * Filter, which UserAvatar to fetch.
     */
    where: UserAvatarWhereUniqueInput
  }

  /**
   * UserAvatar findUniqueOrThrow
   */
  export type UserAvatarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * Filter, which UserAvatar to fetch.
     */
    where: UserAvatarWhereUniqueInput
  }

  /**
   * UserAvatar findFirst
   */
  export type UserAvatarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * Filter, which UserAvatar to fetch.
     */
    where?: UserAvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvatars to fetch.
     */
    orderBy?: UserAvatarOrderByWithRelationInput | UserAvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAvatars.
     */
    cursor?: UserAvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAvatars.
     */
    distinct?: UserAvatarScalarFieldEnum | UserAvatarScalarFieldEnum[]
  }

  /**
   * UserAvatar findFirstOrThrow
   */
  export type UserAvatarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * Filter, which UserAvatar to fetch.
     */
    where?: UserAvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvatars to fetch.
     */
    orderBy?: UserAvatarOrderByWithRelationInput | UserAvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAvatars.
     */
    cursor?: UserAvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAvatars.
     */
    distinct?: UserAvatarScalarFieldEnum | UserAvatarScalarFieldEnum[]
  }

  /**
   * UserAvatar findMany
   */
  export type UserAvatarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * Filter, which UserAvatars to fetch.
     */
    where?: UserAvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAvatars to fetch.
     */
    orderBy?: UserAvatarOrderByWithRelationInput | UserAvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAvatars.
     */
    cursor?: UserAvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAvatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAvatars.
     */
    skip?: number
    distinct?: UserAvatarScalarFieldEnum | UserAvatarScalarFieldEnum[]
  }

  /**
   * UserAvatar create
   */
  export type UserAvatarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAvatar.
     */
    data: XOR<UserAvatarCreateInput, UserAvatarUncheckedCreateInput>
  }

  /**
   * UserAvatar createMany
   */
  export type UserAvatarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAvatars.
     */
    data: UserAvatarCreateManyInput | UserAvatarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAvatar createManyAndReturn
   */
  export type UserAvatarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * The data used to create many UserAvatars.
     */
    data: UserAvatarCreateManyInput | UserAvatarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAvatar update
   */
  export type UserAvatarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAvatar.
     */
    data: XOR<UserAvatarUpdateInput, UserAvatarUncheckedUpdateInput>
    /**
     * Choose, which UserAvatar to update.
     */
    where: UserAvatarWhereUniqueInput
  }

  /**
   * UserAvatar updateMany
   */
  export type UserAvatarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAvatars.
     */
    data: XOR<UserAvatarUpdateManyMutationInput, UserAvatarUncheckedUpdateManyInput>
    /**
     * Filter which UserAvatars to update
     */
    where?: UserAvatarWhereInput
    /**
     * Limit how many UserAvatars to update.
     */
    limit?: number
  }

  /**
   * UserAvatar updateManyAndReturn
   */
  export type UserAvatarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * The data used to update UserAvatars.
     */
    data: XOR<UserAvatarUpdateManyMutationInput, UserAvatarUncheckedUpdateManyInput>
    /**
     * Filter which UserAvatars to update
     */
    where?: UserAvatarWhereInput
    /**
     * Limit how many UserAvatars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAvatar upsert
   */
  export type UserAvatarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAvatar to update in case it exists.
     */
    where: UserAvatarWhereUniqueInput
    /**
     * In case the UserAvatar found by the `where` argument doesn't exist, create a new UserAvatar with this data.
     */
    create: XOR<UserAvatarCreateInput, UserAvatarUncheckedCreateInput>
    /**
     * In case the UserAvatar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAvatarUpdateInput, UserAvatarUncheckedUpdateInput>
  }

  /**
   * UserAvatar delete
   */
  export type UserAvatarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
    /**
     * Filter which UserAvatar to delete.
     */
    where: UserAvatarWhereUniqueInput
  }

  /**
   * UserAvatar deleteMany
   */
  export type UserAvatarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAvatars to delete
     */
    where?: UserAvatarWhereInput
    /**
     * Limit how many UserAvatars to delete.
     */
    limit?: number
  }

  /**
   * UserAvatar without action
   */
  export type UserAvatarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAvatar
     */
    select?: UserAvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAvatar
     */
    omit?: UserAvatarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAvatarInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    projectId: number | null
    parentGroupId: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
    workspaceId: number | null
    projectId: number | null
    parentGroupId: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    objectGuid: string | null
    name: string | null
    displayName: string | null
    distinguishedName: string | null
    description: string | null
    type: $Enums.GroupType | null
    scope: $Enums.GroupScope | null
    workspaceId: number | null
    projectId: number | null
    parentGroupId: number | null
    externalId: string | null
    source: $Enums.GroupSource | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isSecurityGroup: boolean | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    objectGuid: string | null
    name: string | null
    displayName: string | null
    distinguishedName: string | null
    description: string | null
    type: $Enums.GroupType | null
    scope: $Enums.GroupScope | null
    workspaceId: number | null
    projectId: number | null
    parentGroupId: number | null
    externalId: string | null
    source: $Enums.GroupSource | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isSecurityGroup: boolean | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    objectGuid: number
    name: number
    displayName: number
    distinguishedName: number
    description: number
    type: number
    scope: number
    workspaceId: number
    projectId: number
    parentGroupId: number
    externalId: number
    source: number
    isSystem: number
    isActive: number
    createdAt: number
    updatedAt: number
    isSecurityGroup: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
    workspaceId?: true
    projectId?: true
    parentGroupId?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
    workspaceId?: true
    projectId?: true
    parentGroupId?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    objectGuid?: true
    name?: true
    displayName?: true
    distinguishedName?: true
    description?: true
    type?: true
    scope?: true
    workspaceId?: true
    projectId?: true
    parentGroupId?: true
    externalId?: true
    source?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isSecurityGroup?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    objectGuid?: true
    name?: true
    displayName?: true
    distinguishedName?: true
    description?: true
    type?: true
    scope?: true
    workspaceId?: true
    projectId?: true
    parentGroupId?: true
    externalId?: true
    source?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isSecurityGroup?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    objectGuid?: true
    name?: true
    displayName?: true
    distinguishedName?: true
    description?: true
    type?: true
    scope?: true
    workspaceId?: true
    projectId?: true
    parentGroupId?: true
    externalId?: true
    source?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isSecurityGroup?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    objectGuid: string
    name: string
    displayName: string
    distinguishedName: string | null
    description: string | null
    type: $Enums.GroupType
    scope: $Enums.GroupScope
    workspaceId: number | null
    projectId: number | null
    parentGroupId: number | null
    externalId: string | null
    source: $Enums.GroupSource
    isSystem: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    isSecurityGroup: boolean
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    objectGuid?: boolean
    name?: boolean
    displayName?: boolean
    distinguishedName?: boolean
    description?: boolean
    type?: boolean
    scope?: boolean
    workspaceId?: boolean
    projectId?: boolean
    parentGroupId?: boolean
    externalId?: boolean
    source?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSecurityGroup?: boolean
    parentGroup?: boolean | Group$parentGroupArgs<ExtArgs>
    childGroups?: boolean | Group$childGroupsArgs<ExtArgs>
    workspace?: boolean | Group$workspaceArgs<ExtArgs>
    project?: boolean | Group$projectArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    permissions?: boolean | Group$permissionsArgs<ExtArgs>
    roleAssignments?: boolean | Group$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    objectGuid?: boolean
    name?: boolean
    displayName?: boolean
    distinguishedName?: boolean
    description?: boolean
    type?: boolean
    scope?: boolean
    workspaceId?: boolean
    projectId?: boolean
    parentGroupId?: boolean
    externalId?: boolean
    source?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSecurityGroup?: boolean
    parentGroup?: boolean | Group$parentGroupArgs<ExtArgs>
    workspace?: boolean | Group$workspaceArgs<ExtArgs>
    project?: boolean | Group$projectArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    objectGuid?: boolean
    name?: boolean
    displayName?: boolean
    distinguishedName?: boolean
    description?: boolean
    type?: boolean
    scope?: boolean
    workspaceId?: boolean
    projectId?: boolean
    parentGroupId?: boolean
    externalId?: boolean
    source?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSecurityGroup?: boolean
    parentGroup?: boolean | Group$parentGroupArgs<ExtArgs>
    workspace?: boolean | Group$workspaceArgs<ExtArgs>
    project?: boolean | Group$projectArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    objectGuid?: boolean
    name?: boolean
    displayName?: boolean
    distinguishedName?: boolean
    description?: boolean
    type?: boolean
    scope?: boolean
    workspaceId?: boolean
    projectId?: boolean
    parentGroupId?: boolean
    externalId?: boolean
    source?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSecurityGroup?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "objectGuid" | "name" | "displayName" | "distinguishedName" | "description" | "type" | "scope" | "workspaceId" | "projectId" | "parentGroupId" | "externalId" | "source" | "isSystem" | "isActive" | "createdAt" | "updatedAt" | "isSecurityGroup", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentGroup?: boolean | Group$parentGroupArgs<ExtArgs>
    childGroups?: boolean | Group$childGroupsArgs<ExtArgs>
    workspace?: boolean | Group$workspaceArgs<ExtArgs>
    project?: boolean | Group$projectArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    permissions?: boolean | Group$permissionsArgs<ExtArgs>
    roleAssignments?: boolean | Group$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentGroup?: boolean | Group$parentGroupArgs<ExtArgs>
    workspace?: boolean | Group$workspaceArgs<ExtArgs>
    project?: boolean | Group$projectArgs<ExtArgs>
  }
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentGroup?: boolean | Group$parentGroupArgs<ExtArgs>
    workspace?: boolean | Group$workspaceArgs<ExtArgs>
    project?: boolean | Group$projectArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      parentGroup: Prisma.$GroupPayload<ExtArgs> | null
      childGroups: Prisma.$GroupPayload<ExtArgs>[]
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      permissions: Prisma.$GroupPermissionPayload<ExtArgs>[]
      roleAssignments: Prisma.$RoleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      objectGuid: string
      name: string
      displayName: string
      distinguishedName: string | null
      description: string | null
      type: $Enums.GroupType
      scope: $Enums.GroupScope
      workspaceId: number | null
      projectId: number | null
      parentGroupId: number | null
      externalId: string | null
      source: $Enums.GroupSource
      isSystem: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      isSecurityGroup: boolean
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentGroup<T extends Group$parentGroupArgs<ExtArgs> = {}>(args?: Subset<T, Group$parentGroupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childGroups<T extends Group$childGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Group$childGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspace<T extends Group$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, Group$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Group$projectArgs<ExtArgs> = {}>(args?: Subset<T, Group$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Group$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Group$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roleAssignments<T extends Group$roleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Group$roleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly objectGuid: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly displayName: FieldRef<"Group", 'String'>
    readonly distinguishedName: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly type: FieldRef<"Group", 'GroupType'>
    readonly scope: FieldRef<"Group", 'GroupScope'>
    readonly workspaceId: FieldRef<"Group", 'Int'>
    readonly projectId: FieldRef<"Group", 'Int'>
    readonly parentGroupId: FieldRef<"Group", 'Int'>
    readonly externalId: FieldRef<"Group", 'String'>
    readonly source: FieldRef<"Group", 'GroupSource'>
    readonly isSystem: FieldRef<"Group", 'Boolean'>
    readonly isActive: FieldRef<"Group", 'Boolean'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
    readonly isSecurityGroup: FieldRef<"Group", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.parentGroup
   */
  export type Group$parentGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }

  /**
   * Group.childGroups
   */
  export type Group$childGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group.workspace
   */
  export type Group$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * Group.project
   */
  export type Group$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.permissions
   */
  export type Group$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    where?: GroupPermissionWhereInput
    orderBy?: GroupPermissionOrderByWithRelationInput | GroupPermissionOrderByWithRelationInput[]
    cursor?: GroupPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupPermissionScalarFieldEnum | GroupPermissionScalarFieldEnum[]
  }

  /**
   * Group.roleAssignments
   */
  export type Group$roleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    cursor?: RoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _avg: GroupMemberAvgAggregateOutputType | null
    _sum: GroupMemberSumAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    addedById: number | null
  }

  export type GroupMemberSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    addedById: number | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    memberType: $Enums.MemberType | null
    expiresAt: Date | null
    addedAt: Date | null
    addedById: number | null
    externalSync: boolean | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    userId: number | null
    memberType: $Enums.MemberType | null
    expiresAt: Date | null
    addedAt: Date | null
    addedById: number | null
    externalSync: boolean | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    memberType: number
    expiresAt: number
    addedAt: number
    addedById: number
    externalSync: number
    _all: number
  }


  export type GroupMemberAvgAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    addedById?: true
  }

  export type GroupMemberSumAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    addedById?: true
  }

  export type GroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    memberType?: true
    expiresAt?: true
    addedAt?: true
    addedById?: true
    externalSync?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    memberType?: true
    expiresAt?: true
    addedAt?: true
    addedById?: true
    externalSync?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    memberType?: true
    expiresAt?: true
    addedAt?: true
    addedById?: true
    externalSync?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _avg?: GroupMemberAvgAggregateInputType
    _sum?: GroupMemberSumAggregateInputType
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: number
    groupId: number
    userId: number
    memberType: $Enums.MemberType
    expiresAt: Date | null
    addedAt: Date
    addedById: number | null
    externalSync: boolean
    _count: GroupMemberCountAggregateOutputType | null
    _avg: GroupMemberAvgAggregateOutputType | null
    _sum: GroupMemberSumAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    memberType?: boolean
    expiresAt?: boolean
    addedAt?: boolean
    addedById?: boolean
    externalSync?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | GroupMember$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    memberType?: boolean
    expiresAt?: boolean
    addedAt?: boolean
    addedById?: boolean
    externalSync?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | GroupMember$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    memberType?: boolean
    expiresAt?: boolean
    addedAt?: boolean
    addedById?: boolean
    externalSync?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | GroupMember$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    memberType?: boolean
    expiresAt?: boolean
    addedAt?: boolean
    addedById?: boolean
    externalSync?: boolean
  }

  export type GroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "memberType" | "expiresAt" | "addedAt" | "addedById" | "externalSync", ExtArgs["result"]["groupMember"]>
  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | GroupMember$addedByArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | GroupMember$addedByArgs<ExtArgs>
  }
  export type GroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | GroupMember$addedByArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      addedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      userId: number
      memberType: $Enums.MemberType
      expiresAt: Date | null
      addedAt: Date
      addedById: number | null
      externalSync: boolean
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMemberUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addedBy<T extends GroupMember$addedByArgs<ExtArgs> = {}>(args?: Subset<T, GroupMember$addedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'Int'>
    readonly groupId: FieldRef<"GroupMember", 'Int'>
    readonly userId: FieldRef<"GroupMember", 'Int'>
    readonly memberType: FieldRef<"GroupMember", 'MemberType'>
    readonly expiresAt: FieldRef<"GroupMember", 'DateTime'>
    readonly addedAt: FieldRef<"GroupMember", 'DateTime'>
    readonly addedById: FieldRef<"GroupMember", 'Int'>
    readonly externalSync: FieldRef<"GroupMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMember updateManyAndReturn
   */
  export type GroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMember.addedBy
   */
  export type GroupMember$addedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    sortOrder: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    sortOrder: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    parentId: number | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    displayName: string | null
    description: string | null
    category: string | null
    parentId: number | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    category: number
    parentId: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
    parentId?: true
    sortOrder?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
    parentId?: true
    sortOrder?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    parentId?: true
    sortOrder?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    parentId?: true
    sortOrder?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    category?: true
    parentId?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    name: string
    displayName: string
    description: string | null
    category: string
    parentId: number | null
    sortOrder: number
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    parentId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    parent?: boolean | Permission$parentArgs<ExtArgs>
    children?: boolean | Permission$childrenArgs<ExtArgs>
    groupPermissions?: boolean | Permission$groupPermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    parentId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    parent?: boolean | Permission$parentArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    parentId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    parent?: boolean | Permission$parentArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    category?: boolean
    parentId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "description" | "category" | "parentId" | "sortOrder" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Permission$parentArgs<ExtArgs>
    children?: boolean | Permission$childrenArgs<ExtArgs>
    groupPermissions?: boolean | Permission$groupPermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Permission$parentArgs<ExtArgs>
  }
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Permission$parentArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      parent: Prisma.$PermissionPayload<ExtArgs> | null
      children: Prisma.$PermissionPayload<ExtArgs>[]
      groupPermissions: Prisma.$GroupPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      displayName: string
      description: string | null
      category: string
      parentId: number | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Permission$parentArgs<ExtArgs> = {}>(args?: Subset<T, Permission$parentArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Permission$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Permission$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupPermissions<T extends Permission$groupPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$groupPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly displayName: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly parentId: FieldRef<"Permission", 'Int'>
    readonly sortOrder: FieldRef<"Permission", 'Int'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.parent
   */
  export type Permission$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
  }

  /**
   * Permission.children
   */
  export type Permission$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission.groupPermissions
   */
  export type Permission$groupPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    where?: GroupPermissionWhereInput
    orderBy?: GroupPermissionOrderByWithRelationInput | GroupPermissionOrderByWithRelationInput[]
    cursor?: GroupPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupPermissionScalarFieldEnum | GroupPermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model GroupPermission
   */

  export type AggregateGroupPermission = {
    _count: GroupPermissionCountAggregateOutputType | null
    _avg: GroupPermissionAvgAggregateOutputType | null
    _sum: GroupPermissionSumAggregateOutputType | null
    _min: GroupPermissionMinAggregateOutputType | null
    _max: GroupPermissionMaxAggregateOutputType | null
  }

  export type GroupPermissionAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    permissionId: number | null
    workspaceId: number | null
    projectId: number | null
    createdById: number | null
  }

  export type GroupPermissionSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    permissionId: number | null
    workspaceId: number | null
    projectId: number | null
    createdById: number | null
  }

  export type GroupPermissionMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    permissionId: number | null
    accessType: $Enums.AccessType | null
    workspaceId: number | null
    projectId: number | null
    inherited: boolean | null
    createdAt: Date | null
    createdById: number | null
  }

  export type GroupPermissionMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    permissionId: number | null
    accessType: $Enums.AccessType | null
    workspaceId: number | null
    projectId: number | null
    inherited: boolean | null
    createdAt: Date | null
    createdById: number | null
  }

  export type GroupPermissionCountAggregateOutputType = {
    id: number
    groupId: number
    permissionId: number
    accessType: number
    workspaceId: number
    projectId: number
    inherited: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type GroupPermissionAvgAggregateInputType = {
    id?: true
    groupId?: true
    permissionId?: true
    workspaceId?: true
    projectId?: true
    createdById?: true
  }

  export type GroupPermissionSumAggregateInputType = {
    id?: true
    groupId?: true
    permissionId?: true
    workspaceId?: true
    projectId?: true
    createdById?: true
  }

  export type GroupPermissionMinAggregateInputType = {
    id?: true
    groupId?: true
    permissionId?: true
    accessType?: true
    workspaceId?: true
    projectId?: true
    inherited?: true
    createdAt?: true
    createdById?: true
  }

  export type GroupPermissionMaxAggregateInputType = {
    id?: true
    groupId?: true
    permissionId?: true
    accessType?: true
    workspaceId?: true
    projectId?: true
    inherited?: true
    createdAt?: true
    createdById?: true
  }

  export type GroupPermissionCountAggregateInputType = {
    id?: true
    groupId?: true
    permissionId?: true
    accessType?: true
    workspaceId?: true
    projectId?: true
    inherited?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type GroupPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupPermission to aggregate.
     */
    where?: GroupPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPermissions to fetch.
     */
    orderBy?: GroupPermissionOrderByWithRelationInput | GroupPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupPermissions
    **/
    _count?: true | GroupPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupPermissionMaxAggregateInputType
  }

  export type GetGroupPermissionAggregateType<T extends GroupPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupPermission[P]>
      : GetScalarType<T[P], AggregateGroupPermission[P]>
  }




  export type GroupPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupPermissionWhereInput
    orderBy?: GroupPermissionOrderByWithAggregationInput | GroupPermissionOrderByWithAggregationInput[]
    by: GroupPermissionScalarFieldEnum[] | GroupPermissionScalarFieldEnum
    having?: GroupPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupPermissionCountAggregateInputType | true
    _avg?: GroupPermissionAvgAggregateInputType
    _sum?: GroupPermissionSumAggregateInputType
    _min?: GroupPermissionMinAggregateInputType
    _max?: GroupPermissionMaxAggregateInputType
  }

  export type GroupPermissionGroupByOutputType = {
    id: number
    groupId: number
    permissionId: number
    accessType: $Enums.AccessType
    workspaceId: number | null
    projectId: number | null
    inherited: boolean
    createdAt: Date
    createdById: number | null
    _count: GroupPermissionCountAggregateOutputType | null
    _avg: GroupPermissionAvgAggregateOutputType | null
    _sum: GroupPermissionSumAggregateOutputType | null
    _min: GroupPermissionMinAggregateOutputType | null
    _max: GroupPermissionMaxAggregateOutputType | null
  }

  type GetGroupPermissionGroupByPayload<T extends GroupPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], GroupPermissionGroupByOutputType[P]>
        }
      >
    >


  export type GroupPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    permissionId?: boolean
    accessType?: boolean
    workspaceId?: boolean
    projectId?: boolean
    inherited?: boolean
    createdAt?: boolean
    createdById?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupPermission"]>

  export type GroupPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    permissionId?: boolean
    accessType?: boolean
    workspaceId?: boolean
    projectId?: boolean
    inherited?: boolean
    createdAt?: boolean
    createdById?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupPermission"]>

  export type GroupPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    permissionId?: boolean
    accessType?: boolean
    workspaceId?: boolean
    projectId?: boolean
    inherited?: boolean
    createdAt?: boolean
    createdById?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupPermission"]>

  export type GroupPermissionSelectScalar = {
    id?: boolean
    groupId?: boolean
    permissionId?: boolean
    accessType?: boolean
    workspaceId?: boolean
    projectId?: boolean
    inherited?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type GroupPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "permissionId" | "accessType" | "workspaceId" | "projectId" | "inherited" | "createdAt" | "createdById", ExtArgs["result"]["groupPermission"]>
  export type GroupPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type GroupPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type GroupPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $GroupPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupPermission"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      permissionId: number
      accessType: $Enums.AccessType
      workspaceId: number | null
      projectId: number | null
      inherited: boolean
      createdAt: Date
      createdById: number | null
    }, ExtArgs["result"]["groupPermission"]>
    composites: {}
  }

  type GroupPermissionGetPayload<S extends boolean | null | undefined | GroupPermissionDefaultArgs> = $Result.GetResult<Prisma.$GroupPermissionPayload, S>

  type GroupPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupPermissionCountAggregateInputType | true
    }

  export interface GroupPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupPermission'], meta: { name: 'GroupPermission' } }
    /**
     * Find zero or one GroupPermission that matches the filter.
     * @param {GroupPermissionFindUniqueArgs} args - Arguments to find a GroupPermission
     * @example
     * // Get one GroupPermission
     * const groupPermission = await prisma.groupPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupPermissionFindUniqueArgs>(args: SelectSubset<T, GroupPermissionFindUniqueArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupPermissionFindUniqueOrThrowArgs} args - Arguments to find a GroupPermission
     * @example
     * // Get one GroupPermission
     * const groupPermission = await prisma.groupPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionFindFirstArgs} args - Arguments to find a GroupPermission
     * @example
     * // Get one GroupPermission
     * const groupPermission = await prisma.groupPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupPermissionFindFirstArgs>(args?: SelectSubset<T, GroupPermissionFindFirstArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionFindFirstOrThrowArgs} args - Arguments to find a GroupPermission
     * @example
     * // Get one GroupPermission
     * const groupPermission = await prisma.groupPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupPermissions
     * const groupPermissions = await prisma.groupPermission.findMany()
     * 
     * // Get first 10 GroupPermissions
     * const groupPermissions = await prisma.groupPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupPermissionWithIdOnly = await prisma.groupPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupPermissionFindManyArgs>(args?: SelectSubset<T, GroupPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupPermission.
     * @param {GroupPermissionCreateArgs} args - Arguments to create a GroupPermission.
     * @example
     * // Create one GroupPermission
     * const GroupPermission = await prisma.groupPermission.create({
     *   data: {
     *     // ... data to create a GroupPermission
     *   }
     * })
     * 
     */
    create<T extends GroupPermissionCreateArgs>(args: SelectSubset<T, GroupPermissionCreateArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupPermissions.
     * @param {GroupPermissionCreateManyArgs} args - Arguments to create many GroupPermissions.
     * @example
     * // Create many GroupPermissions
     * const groupPermission = await prisma.groupPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupPermissionCreateManyArgs>(args?: SelectSubset<T, GroupPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupPermissions and returns the data saved in the database.
     * @param {GroupPermissionCreateManyAndReturnArgs} args - Arguments to create many GroupPermissions.
     * @example
     * // Create many GroupPermissions
     * const groupPermission = await prisma.groupPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupPermissions and only return the `id`
     * const groupPermissionWithIdOnly = await prisma.groupPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupPermission.
     * @param {GroupPermissionDeleteArgs} args - Arguments to delete one GroupPermission.
     * @example
     * // Delete one GroupPermission
     * const GroupPermission = await prisma.groupPermission.delete({
     *   where: {
     *     // ... filter to delete one GroupPermission
     *   }
     * })
     * 
     */
    delete<T extends GroupPermissionDeleteArgs>(args: SelectSubset<T, GroupPermissionDeleteArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupPermission.
     * @param {GroupPermissionUpdateArgs} args - Arguments to update one GroupPermission.
     * @example
     * // Update one GroupPermission
     * const groupPermission = await prisma.groupPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupPermissionUpdateArgs>(args: SelectSubset<T, GroupPermissionUpdateArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupPermissions.
     * @param {GroupPermissionDeleteManyArgs} args - Arguments to filter GroupPermissions to delete.
     * @example
     * // Delete a few GroupPermissions
     * const { count } = await prisma.groupPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupPermissionDeleteManyArgs>(args?: SelectSubset<T, GroupPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupPermissions
     * const groupPermission = await prisma.groupPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupPermissionUpdateManyArgs>(args: SelectSubset<T, GroupPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupPermissions and returns the data updated in the database.
     * @param {GroupPermissionUpdateManyAndReturnArgs} args - Arguments to update many GroupPermissions.
     * @example
     * // Update many GroupPermissions
     * const groupPermission = await prisma.groupPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupPermissions and only return the `id`
     * const groupPermissionWithIdOnly = await prisma.groupPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupPermission.
     * @param {GroupPermissionUpsertArgs} args - Arguments to update or create a GroupPermission.
     * @example
     * // Update or create a GroupPermission
     * const groupPermission = await prisma.groupPermission.upsert({
     *   create: {
     *     // ... data to create a GroupPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupPermission we want to update
     *   }
     * })
     */
    upsert<T extends GroupPermissionUpsertArgs>(args: SelectSubset<T, GroupPermissionUpsertArgs<ExtArgs>>): Prisma__GroupPermissionClient<$Result.GetResult<Prisma.$GroupPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionCountArgs} args - Arguments to filter GroupPermissions to count.
     * @example
     * // Count the number of GroupPermissions
     * const count = await prisma.groupPermission.count({
     *   where: {
     *     // ... the filter for the GroupPermissions we want to count
     *   }
     * })
    **/
    count<T extends GroupPermissionCountArgs>(
      args?: Subset<T, GroupPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupPermissionAggregateArgs>(args: Subset<T, GroupPermissionAggregateArgs>): Prisma.PrismaPromise<GetGroupPermissionAggregateType<T>>

    /**
     * Group by GroupPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupPermissionGroupByArgs['orderBy'] }
        : { orderBy?: GroupPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupPermission model
   */
  readonly fields: GroupPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupPermission model
   */
  interface GroupPermissionFieldRefs {
    readonly id: FieldRef<"GroupPermission", 'Int'>
    readonly groupId: FieldRef<"GroupPermission", 'Int'>
    readonly permissionId: FieldRef<"GroupPermission", 'Int'>
    readonly accessType: FieldRef<"GroupPermission", 'AccessType'>
    readonly workspaceId: FieldRef<"GroupPermission", 'Int'>
    readonly projectId: FieldRef<"GroupPermission", 'Int'>
    readonly inherited: FieldRef<"GroupPermission", 'Boolean'>
    readonly createdAt: FieldRef<"GroupPermission", 'DateTime'>
    readonly createdById: FieldRef<"GroupPermission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GroupPermission findUnique
   */
  export type GroupPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * Filter, which GroupPermission to fetch.
     */
    where: GroupPermissionWhereUniqueInput
  }

  /**
   * GroupPermission findUniqueOrThrow
   */
  export type GroupPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * Filter, which GroupPermission to fetch.
     */
    where: GroupPermissionWhereUniqueInput
  }

  /**
   * GroupPermission findFirst
   */
  export type GroupPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * Filter, which GroupPermission to fetch.
     */
    where?: GroupPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPermissions to fetch.
     */
    orderBy?: GroupPermissionOrderByWithRelationInput | GroupPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupPermissions.
     */
    cursor?: GroupPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupPermissions.
     */
    distinct?: GroupPermissionScalarFieldEnum | GroupPermissionScalarFieldEnum[]
  }

  /**
   * GroupPermission findFirstOrThrow
   */
  export type GroupPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * Filter, which GroupPermission to fetch.
     */
    where?: GroupPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPermissions to fetch.
     */
    orderBy?: GroupPermissionOrderByWithRelationInput | GroupPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupPermissions.
     */
    cursor?: GroupPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupPermissions.
     */
    distinct?: GroupPermissionScalarFieldEnum | GroupPermissionScalarFieldEnum[]
  }

  /**
   * GroupPermission findMany
   */
  export type GroupPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * Filter, which GroupPermissions to fetch.
     */
    where?: GroupPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPermissions to fetch.
     */
    orderBy?: GroupPermissionOrderByWithRelationInput | GroupPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupPermissions.
     */
    cursor?: GroupPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPermissions.
     */
    skip?: number
    distinct?: GroupPermissionScalarFieldEnum | GroupPermissionScalarFieldEnum[]
  }

  /**
   * GroupPermission create
   */
  export type GroupPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupPermission.
     */
    data: XOR<GroupPermissionCreateInput, GroupPermissionUncheckedCreateInput>
  }

  /**
   * GroupPermission createMany
   */
  export type GroupPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupPermissions.
     */
    data: GroupPermissionCreateManyInput | GroupPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupPermission createManyAndReturn
   */
  export type GroupPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many GroupPermissions.
     */
    data: GroupPermissionCreateManyInput | GroupPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupPermission update
   */
  export type GroupPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupPermission.
     */
    data: XOR<GroupPermissionUpdateInput, GroupPermissionUncheckedUpdateInput>
    /**
     * Choose, which GroupPermission to update.
     */
    where: GroupPermissionWhereUniqueInput
  }

  /**
   * GroupPermission updateMany
   */
  export type GroupPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupPermissions.
     */
    data: XOR<GroupPermissionUpdateManyMutationInput, GroupPermissionUncheckedUpdateManyInput>
    /**
     * Filter which GroupPermissions to update
     */
    where?: GroupPermissionWhereInput
    /**
     * Limit how many GroupPermissions to update.
     */
    limit?: number
  }

  /**
   * GroupPermission updateManyAndReturn
   */
  export type GroupPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * The data used to update GroupPermissions.
     */
    data: XOR<GroupPermissionUpdateManyMutationInput, GroupPermissionUncheckedUpdateManyInput>
    /**
     * Filter which GroupPermissions to update
     */
    where?: GroupPermissionWhereInput
    /**
     * Limit how many GroupPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupPermission upsert
   */
  export type GroupPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupPermission to update in case it exists.
     */
    where: GroupPermissionWhereUniqueInput
    /**
     * In case the GroupPermission found by the `where` argument doesn't exist, create a new GroupPermission with this data.
     */
    create: XOR<GroupPermissionCreateInput, GroupPermissionUncheckedCreateInput>
    /**
     * In case the GroupPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupPermissionUpdateInput, GroupPermissionUncheckedUpdateInput>
  }

  /**
   * GroupPermission delete
   */
  export type GroupPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
    /**
     * Filter which GroupPermission to delete.
     */
    where: GroupPermissionWhereUniqueInput
  }

  /**
   * GroupPermission deleteMany
   */
  export type GroupPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupPermissions to delete
     */
    where?: GroupPermissionWhereInput
    /**
     * Limit how many GroupPermissions to delete.
     */
    limit?: number
  }

  /**
   * GroupPermission without action
   */
  export type GroupPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupPermission
     */
    select?: GroupPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupPermission
     */
    omit?: GroupPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupPermissionInclude<ExtArgs> | null
  }


  /**
   * Model RoleAssignment
   */

  export type AggregateRoleAssignment = {
    _count: RoleAssignmentCountAggregateOutputType | null
    _avg: RoleAssignmentAvgAggregateOutputType | null
    _sum: RoleAssignmentSumAggregateOutputType | null
    _min: RoleAssignmentMinAggregateOutputType | null
    _max: RoleAssignmentMaxAggregateOutputType | null
  }

  export type RoleAssignmentAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    workspaceId: number | null
    projectId: number | null
    createdById: number | null
  }

  export type RoleAssignmentSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    workspaceId: number | null
    projectId: number | null
    createdById: number | null
  }

  export type RoleAssignmentMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    workspaceId: number | null
    projectId: number | null
    role: $Enums.AssignmentRole | null
    inheritToChildren: boolean | null
    createdAt: Date | null
    createdById: number | null
  }

  export type RoleAssignmentMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    workspaceId: number | null
    projectId: number | null
    role: $Enums.AssignmentRole | null
    inheritToChildren: boolean | null
    createdAt: Date | null
    createdById: number | null
  }

  export type RoleAssignmentCountAggregateOutputType = {
    id: number
    groupId: number
    workspaceId: number
    projectId: number
    role: number
    inheritToChildren: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type RoleAssignmentAvgAggregateInputType = {
    id?: true
    groupId?: true
    workspaceId?: true
    projectId?: true
    createdById?: true
  }

  export type RoleAssignmentSumAggregateInputType = {
    id?: true
    groupId?: true
    workspaceId?: true
    projectId?: true
    createdById?: true
  }

  export type RoleAssignmentMinAggregateInputType = {
    id?: true
    groupId?: true
    workspaceId?: true
    projectId?: true
    role?: true
    inheritToChildren?: true
    createdAt?: true
    createdById?: true
  }

  export type RoleAssignmentMaxAggregateInputType = {
    id?: true
    groupId?: true
    workspaceId?: true
    projectId?: true
    role?: true
    inheritToChildren?: true
    createdAt?: true
    createdById?: true
  }

  export type RoleAssignmentCountAggregateInputType = {
    id?: true
    groupId?: true
    workspaceId?: true
    projectId?: true
    role?: true
    inheritToChildren?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type RoleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleAssignment to aggregate.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleAssignments
    **/
    _count?: true | RoleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleAssignmentMaxAggregateInputType
  }

  export type GetRoleAssignmentAggregateType<T extends RoleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleAssignment[P]>
      : GetScalarType<T[P], AggregateRoleAssignment[P]>
  }




  export type RoleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleAssignmentWhereInput
    orderBy?: RoleAssignmentOrderByWithAggregationInput | RoleAssignmentOrderByWithAggregationInput[]
    by: RoleAssignmentScalarFieldEnum[] | RoleAssignmentScalarFieldEnum
    having?: RoleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleAssignmentCountAggregateInputType | true
    _avg?: RoleAssignmentAvgAggregateInputType
    _sum?: RoleAssignmentSumAggregateInputType
    _min?: RoleAssignmentMinAggregateInputType
    _max?: RoleAssignmentMaxAggregateInputType
  }

  export type RoleAssignmentGroupByOutputType = {
    id: number
    groupId: number
    workspaceId: number | null
    projectId: number | null
    role: $Enums.AssignmentRole
    inheritToChildren: boolean
    createdAt: Date
    createdById: number | null
    _count: RoleAssignmentCountAggregateOutputType | null
    _avg: RoleAssignmentAvgAggregateOutputType | null
    _sum: RoleAssignmentSumAggregateOutputType | null
    _min: RoleAssignmentMinAggregateOutputType | null
    _max: RoleAssignmentMaxAggregateOutputType | null
  }

  type GetRoleAssignmentGroupByPayload<T extends RoleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], RoleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type RoleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    workspaceId?: boolean
    projectId?: boolean
    role?: boolean
    inheritToChildren?: boolean
    createdAt?: boolean
    createdById?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    workspace?: boolean | RoleAssignment$workspaceArgs<ExtArgs>
    project?: boolean | RoleAssignment$projectArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssignment"]>

  export type RoleAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    workspaceId?: boolean
    projectId?: boolean
    role?: boolean
    inheritToChildren?: boolean
    createdAt?: boolean
    createdById?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    workspace?: boolean | RoleAssignment$workspaceArgs<ExtArgs>
    project?: boolean | RoleAssignment$projectArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssignment"]>

  export type RoleAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    workspaceId?: boolean
    projectId?: boolean
    role?: boolean
    inheritToChildren?: boolean
    createdAt?: boolean
    createdById?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    workspace?: boolean | RoleAssignment$workspaceArgs<ExtArgs>
    project?: boolean | RoleAssignment$projectArgs<ExtArgs>
  }, ExtArgs["result"]["roleAssignment"]>

  export type RoleAssignmentSelectScalar = {
    id?: boolean
    groupId?: boolean
    workspaceId?: boolean
    projectId?: boolean
    role?: boolean
    inheritToChildren?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type RoleAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "workspaceId" | "projectId" | "role" | "inheritToChildren" | "createdAt" | "createdById", ExtArgs["result"]["roleAssignment"]>
  export type RoleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    workspace?: boolean | RoleAssignment$workspaceArgs<ExtArgs>
    project?: boolean | RoleAssignment$projectArgs<ExtArgs>
  }
  export type RoleAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    workspace?: boolean | RoleAssignment$workspaceArgs<ExtArgs>
    project?: boolean | RoleAssignment$projectArgs<ExtArgs>
  }
  export type RoleAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    workspace?: boolean | RoleAssignment$workspaceArgs<ExtArgs>
    project?: boolean | RoleAssignment$projectArgs<ExtArgs>
  }

  export type $RoleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleAssignment"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      workspaceId: number | null
      projectId: number | null
      role: $Enums.AssignmentRole
      inheritToChildren: boolean
      createdAt: Date
      createdById: number | null
    }, ExtArgs["result"]["roleAssignment"]>
    composites: {}
  }

  type RoleAssignmentGetPayload<S extends boolean | null | undefined | RoleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$RoleAssignmentPayload, S>

  type RoleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleAssignmentCountAggregateInputType | true
    }

  export interface RoleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleAssignment'], meta: { name: 'RoleAssignment' } }
    /**
     * Find zero or one RoleAssignment that matches the filter.
     * @param {RoleAssignmentFindUniqueArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleAssignmentFindUniqueArgs>(args: SelectSubset<T, RoleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentFindFirstArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleAssignmentFindFirstArgs>(args?: SelectSubset<T, RoleAssignmentFindFirstArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentFindFirstOrThrowArgs} args - Arguments to find a RoleAssignment
     * @example
     * // Get one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleAssignments
     * const roleAssignments = await prisma.roleAssignment.findMany()
     * 
     * // Get first 10 RoleAssignments
     * const roleAssignments = await prisma.roleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleAssignmentWithIdOnly = await prisma.roleAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleAssignmentFindManyArgs>(args?: SelectSubset<T, RoleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleAssignment.
     * @param {RoleAssignmentCreateArgs} args - Arguments to create a RoleAssignment.
     * @example
     * // Create one RoleAssignment
     * const RoleAssignment = await prisma.roleAssignment.create({
     *   data: {
     *     // ... data to create a RoleAssignment
     *   }
     * })
     * 
     */
    create<T extends RoleAssignmentCreateArgs>(args: SelectSubset<T, RoleAssignmentCreateArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleAssignments.
     * @param {RoleAssignmentCreateManyArgs} args - Arguments to create many RoleAssignments.
     * @example
     * // Create many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleAssignmentCreateManyArgs>(args?: SelectSubset<T, RoleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleAssignments and returns the data saved in the database.
     * @param {RoleAssignmentCreateManyAndReturnArgs} args - Arguments to create many RoleAssignments.
     * @example
     * // Create many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleAssignments and only return the `id`
     * const roleAssignmentWithIdOnly = await prisma.roleAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleAssignment.
     * @param {RoleAssignmentDeleteArgs} args - Arguments to delete one RoleAssignment.
     * @example
     * // Delete one RoleAssignment
     * const RoleAssignment = await prisma.roleAssignment.delete({
     *   where: {
     *     // ... filter to delete one RoleAssignment
     *   }
     * })
     * 
     */
    delete<T extends RoleAssignmentDeleteArgs>(args: SelectSubset<T, RoleAssignmentDeleteArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleAssignment.
     * @param {RoleAssignmentUpdateArgs} args - Arguments to update one RoleAssignment.
     * @example
     * // Update one RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleAssignmentUpdateArgs>(args: SelectSubset<T, RoleAssignmentUpdateArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleAssignments.
     * @param {RoleAssignmentDeleteManyArgs} args - Arguments to filter RoleAssignments to delete.
     * @example
     * // Delete a few RoleAssignments
     * const { count } = await prisma.roleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleAssignmentDeleteManyArgs>(args?: SelectSubset<T, RoleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleAssignmentUpdateManyArgs>(args: SelectSubset<T, RoleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleAssignments and returns the data updated in the database.
     * @param {RoleAssignmentUpdateManyAndReturnArgs} args - Arguments to update many RoleAssignments.
     * @example
     * // Update many RoleAssignments
     * const roleAssignment = await prisma.roleAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleAssignments and only return the `id`
     * const roleAssignmentWithIdOnly = await prisma.roleAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleAssignment.
     * @param {RoleAssignmentUpsertArgs} args - Arguments to update or create a RoleAssignment.
     * @example
     * // Update or create a RoleAssignment
     * const roleAssignment = await prisma.roleAssignment.upsert({
     *   create: {
     *     // ... data to create a RoleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends RoleAssignmentUpsertArgs>(args: SelectSubset<T, RoleAssignmentUpsertArgs<ExtArgs>>): Prisma__RoleAssignmentClient<$Result.GetResult<Prisma.$RoleAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentCountArgs} args - Arguments to filter RoleAssignments to count.
     * @example
     * // Count the number of RoleAssignments
     * const count = await prisma.roleAssignment.count({
     *   where: {
     *     // ... the filter for the RoleAssignments we want to count
     *   }
     * })
    **/
    count<T extends RoleAssignmentCountArgs>(
      args?: Subset<T, RoleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAssignmentAggregateArgs>(args: Subset<T, RoleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetRoleAssignmentAggregateType<T>>

    /**
     * Group by RoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: RoleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleAssignment model
   */
  readonly fields: RoleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends RoleAssignment$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, RoleAssignment$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends RoleAssignment$projectArgs<ExtArgs> = {}>(args?: Subset<T, RoleAssignment$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleAssignment model
   */
  interface RoleAssignmentFieldRefs {
    readonly id: FieldRef<"RoleAssignment", 'Int'>
    readonly groupId: FieldRef<"RoleAssignment", 'Int'>
    readonly workspaceId: FieldRef<"RoleAssignment", 'Int'>
    readonly projectId: FieldRef<"RoleAssignment", 'Int'>
    readonly role: FieldRef<"RoleAssignment", 'AssignmentRole'>
    readonly inheritToChildren: FieldRef<"RoleAssignment", 'Boolean'>
    readonly createdAt: FieldRef<"RoleAssignment", 'DateTime'>
    readonly createdById: FieldRef<"RoleAssignment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoleAssignment findUnique
   */
  export type RoleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment findUniqueOrThrow
   */
  export type RoleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment findFirst
   */
  export type RoleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleAssignments.
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleAssignments.
     */
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * RoleAssignment findFirstOrThrow
   */
  export type RoleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignment to fetch.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleAssignments.
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleAssignments.
     */
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * RoleAssignment findMany
   */
  export type RoleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoleAssignments to fetch.
     */
    where?: RoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleAssignments to fetch.
     */
    orderBy?: RoleAssignmentOrderByWithRelationInput | RoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleAssignments.
     */
    cursor?: RoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleAssignments.
     */
    skip?: number
    distinct?: RoleAssignmentScalarFieldEnum | RoleAssignmentScalarFieldEnum[]
  }

  /**
   * RoleAssignment create
   */
  export type RoleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleAssignment.
     */
    data: XOR<RoleAssignmentCreateInput, RoleAssignmentUncheckedCreateInput>
  }

  /**
   * RoleAssignment createMany
   */
  export type RoleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleAssignments.
     */
    data: RoleAssignmentCreateManyInput | RoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleAssignment createManyAndReturn
   */
  export type RoleAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many RoleAssignments.
     */
    data: RoleAssignmentCreateManyInput | RoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleAssignment update
   */
  export type RoleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleAssignment.
     */
    data: XOR<RoleAssignmentUpdateInput, RoleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which RoleAssignment to update.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment updateMany
   */
  export type RoleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleAssignments.
     */
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoleAssignments to update
     */
    where?: RoleAssignmentWhereInput
    /**
     * Limit how many RoleAssignments to update.
     */
    limit?: number
  }

  /**
   * RoleAssignment updateManyAndReturn
   */
  export type RoleAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update RoleAssignments.
     */
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoleAssignments to update
     */
    where?: RoleAssignmentWhereInput
    /**
     * Limit how many RoleAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleAssignment upsert
   */
  export type RoleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleAssignment to update in case it exists.
     */
    where: RoleAssignmentWhereUniqueInput
    /**
     * In case the RoleAssignment found by the `where` argument doesn't exist, create a new RoleAssignment with this data.
     */
    create: XOR<RoleAssignmentCreateInput, RoleAssignmentUncheckedCreateInput>
    /**
     * In case the RoleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleAssignmentUpdateInput, RoleAssignmentUncheckedUpdateInput>
  }

  /**
   * RoleAssignment delete
   */
  export type RoleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which RoleAssignment to delete.
     */
    where: RoleAssignmentWhereUniqueInput
  }

  /**
   * RoleAssignment deleteMany
   */
  export type RoleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleAssignments to delete
     */
    where?: RoleAssignmentWhereInput
    /**
     * Limit how many RoleAssignments to delete.
     */
    limit?: number
  }

  /**
   * RoleAssignment.workspace
   */
  export type RoleAssignment$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * RoleAssignment.project
   */
  export type RoleAssignment$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * RoleAssignment without action
   */
  export type RoleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleAssignment
     */
    select?: RoleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleAssignment
     */
    omit?: RoleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    logoUrl: 'logoUrl',
    settings: 'settings',
    isActive: 'isActive',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceLogoScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    data: 'data',
    mimeType: 'mimeType',
    size: 'size',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceLogoScalarFieldEnum = (typeof WorkspaceLogoScalarFieldEnum)[keyof typeof WorkspaceLogoScalarFieldEnum]


  export const WorkspaceUserScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type WorkspaceUserScalarFieldEnum = (typeof WorkspaceUserScalarFieldEnum)[keyof typeof WorkspaceUserScalarFieldEnum]


  export const WorkspaceInvitationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    role: 'role',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type WorkspaceInvitationScalarFieldEnum = (typeof WorkspaceInvitationScalarFieldEnum)[keyof typeof WorkspaceInvitationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    name: 'name',
    passwordHash: 'passwordHash',
    avatarUrl: 'avatarUrl',
    timezone: 'timezone',
    language: 'language',
    settings: 'settings',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    role: 'role',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twofactorActivated: 'twofactorActivated',
    twofactorSecret: 'twofactorSecret',
    failedLoginCount: 'failedLoginCount',
    lockedUntil: 'lockedUntil',
    lockoutCount: 'lockoutCount',
    googleId: 'googleId',
    githubId: 'githubId',
    gitlabId: 'gitlabId',
    theme: 'theme',
    defaultFilter: 'defaultFilter',
    publicToken: 'publicToken',
    hourlyRate: 'hourlyRate',
    notificationsEnabled: 'notificationsEnabled',
    notificationFilter: 'notificationFilter'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    data: 'data',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const RememberTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RememberTokenScalarFieldEnum = (typeof RememberTokenScalarFieldEnum)[keyof typeof RememberTokenScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    role: 'role',
    invitedById: 'invitedById',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt',
    createdAt: 'createdAt'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    changedBy: 'changedBy',
    changedAt: 'changedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    identifier: 'identifier',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    isPublic: 'isPublic',
    settings: 'settings',
    lastActivityAt: 'lastActivityAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const ColumnScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    position: 'position',
    taskLimit: 'taskLimit',
    isCollapsed: 'isCollapsed',
    showClosed: 'showClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ColumnScalarFieldEnum = (typeof ColumnScalarFieldEnum)[keyof typeof ColumnScalarFieldEnum]


  export const SwimlaneScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    position: 'position',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SwimlaneScalarFieldEnum = (typeof SwimlaneScalarFieldEnum)[keyof typeof SwimlaneScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    columnId: 'columnId',
    swimlaneId: 'swimlaneId',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    reference: 'reference',
    priority: 'priority',
    score: 'score',
    progress: 'progress',
    position: 'position',
    color: 'color',
    dateStarted: 'dateStarted',
    dateDue: 'dateDue',
    dateCompleted: 'dateCompleted',
    reminderAt: 'reminderAt',
    timeEstimated: 'timeEstimated',
    timeSpent: 'timeSpent',
    isActive: 'isActive',
    isDraggable: 'isDraggable',
    recurrenceData: 'recurrenceData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    milestoneId: 'milestoneId',
    moduleId: 'moduleId',
    sprintId: 'sprintId',
    categoryId: 'categoryId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskAssigneeScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type TaskAssigneeScalarFieldEnum = (typeof TaskAssigneeScalarFieldEnum)[keyof typeof TaskAssigneeScalarFieldEnum]


  export const SubtaskScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    title: 'title',
    description: 'description',
    status: 'status',
    position: 'position',
    assigneeId: 'assigneeId',
    timeEstimated: 'timeEstimated',
    timeSpent: 'timeSpent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubtaskScalarFieldEnum = (typeof SubtaskScalarFieldEnum)[keyof typeof SubtaskScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TaskTagScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type TaskTagScalarFieldEnum = (typeof TaskTagScalarFieldEnum)[keyof typeof TaskTagScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId',
    name: 'name',
    path: 'path',
    mimeType: 'mimeType',
    size: 'size',
    isImage: 'isImage',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const TaskLinkScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    oppositeTaskId: 'oppositeTaskId',
    linkType: 'linkType',
    createdAt: 'createdAt'
  };

  export type TaskLinkScalarFieldEnum = (typeof TaskLinkScalarFieldEnum)[keyof typeof TaskLinkScalarFieldEnum]


  export const CustomFieldScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    type: 'type',
    options: 'options',
    isRequired: 'isRequired',
    position: 'position',
    createdAt: 'createdAt'
  };

  export type CustomFieldScalarFieldEnum = (typeof CustomFieldScalarFieldEnum)[keyof typeof CustomFieldScalarFieldEnum]


  export const TaskCustomValueScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    customFieldId: 'customFieldId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskCustomValueScalarFieldEnum = (typeof TaskCustomValueScalarFieldEnum)[keyof typeof TaskCustomValueScalarFieldEnum]


  export const SprintScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    status: 'status',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SprintScalarFieldEnum = (typeof SprintScalarFieldEnum)[keyof typeof SprintScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    color: 'color',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    dateDue: 'dateDue',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const StickyNoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    color: 'color',
    isPinned: 'isPinned',
    visibility: 'visibility',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StickyNoteScalarFieldEnum = (typeof StickyNoteScalarFieldEnum)[keyof typeof StickyNoteScalarFieldEnum]


  export const StickyNoteLinkScalarFieldEnum: {
    id: 'id',
    stickyNoteId: 'stickyNoteId',
    entityType: 'entityType',
    entityId: 'entityId',
    createdAt: 'createdAt'
  };

  export type StickyNoteLinkScalarFieldEnum = (typeof StickyNoteLinkScalarFieldEnum)[keyof typeof StickyNoteLinkScalarFieldEnum]


  export const ProjectGroupScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    color: 'color',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectGroupScalarFieldEnum = (typeof ProjectGroupScalarFieldEnum)[keyof typeof ProjectGroupScalarFieldEnum]


  export const ProjectGroupMemberScalarFieldEnum: {
    id: 'id',
    projectGroupId: 'projectGroupId',
    projectId: 'projectId',
    position: 'position',
    createdAt: 'createdAt'
  };

  export type ProjectGroupMemberScalarFieldEnum = (typeof ProjectGroupMemberScalarFieldEnum)[keyof typeof ProjectGroupMemberScalarFieldEnum]


  export const TaskSessionScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    sessionId: 'sessionId',
    linkType: 'linkType',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type TaskSessionScalarFieldEnum = (typeof TaskSessionScalarFieldEnum)[keyof typeof TaskSessionScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    amount: 'amount',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetLineScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    description: 'description',
    amount: 'amount',
    lineType: 'lineType',
    taskId: 'taskId',
    createdAt: 'createdAt'
  };

  export type BudgetLineScalarFieldEnum = (typeof BudgetLineScalarFieldEnum)[keyof typeof BudgetLineScalarFieldEnum]


  export const WikiPageScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    content: 'content',
    creatorId: 'creatorId',
    modifierId: 'modifierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WikiPageScalarFieldEnum = (typeof WikiPageScalarFieldEnum)[keyof typeof WikiPageScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    keyPrefix: 'keyPrefix',
    keyHash: 'keyHash',
    permissions: 'permissions',
    rateLimit: 'rateLimit',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    url: 'url',
    secret: 'secret',
    events: 'events',
    isActive: 'isActive',
    lastSuccess: 'lastSuccess',
    lastFailure: 'lastFailure',
    failureCount: 'failureCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    event: 'event',
    payload: 'payload',
    statusCode: 'statusCode',
    response: 'response',
    duration: 'duration',
    success: 'success',
    attempts: 'attempts',
    deliveredAt: 'deliveredAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    content: 'content',
    data: 'data',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    eventType: 'eventType',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ip: 'ip',
    userAgent: 'userAgent',
    isUsed: 'isUsed',
    createdAt: 'createdAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const LastLoginScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    authType: 'authType',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type LastLoginScalarFieldEnum = (typeof LastLoginScalarFieldEnum)[keyof typeof LastLoginScalarFieldEnum]


  export const UserMetadataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserMetadataScalarFieldEnum = (typeof UserMetadataScalarFieldEnum)[keyof typeof UserMetadataScalarFieldEnum]


  export const UserNotificationSettingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationType: 'notificationType',
    isEnabled: 'isEnabled'
  };

  export type UserNotificationSettingScalarFieldEnum = (typeof UserNotificationSettingScalarFieldEnum)[keyof typeof UserNotificationSettingScalarFieldEnum]


  export const UserAvatarScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    data: 'data',
    mimeType: 'mimeType',
    size: 'size',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAvatarScalarFieldEnum = (typeof UserAvatarScalarFieldEnum)[keyof typeof UserAvatarScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    objectGuid: 'objectGuid',
    name: 'name',
    displayName: 'displayName',
    distinguishedName: 'distinguishedName',
    description: 'description',
    type: 'type',
    scope: 'scope',
    workspaceId: 'workspaceId',
    projectId: 'projectId',
    parentGroupId: 'parentGroupId',
    externalId: 'externalId',
    source: 'source',
    isSystem: 'isSystem',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isSecurityGroup: 'isSecurityGroup'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    memberType: 'memberType',
    expiresAt: 'expiresAt',
    addedAt: 'addedAt',
    addedById: 'addedById',
    externalSync: 'externalSync'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    category: 'category',
    parentId: 'parentId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const GroupPermissionScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    permissionId: 'permissionId',
    accessType: 'accessType',
    workspaceId: 'workspaceId',
    projectId: 'projectId',
    inherited: 'inherited',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type GroupPermissionScalarFieldEnum = (typeof GroupPermissionScalarFieldEnum)[keyof typeof GroupPermissionScalarFieldEnum]


  export const RoleAssignmentScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    workspaceId: 'workspaceId',
    projectId: 'projectId',
    role: 'role',
    inheritToChildren: 'inheritToChildren',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type RoleAssignmentScalarFieldEnum = (typeof RoleAssignmentScalarFieldEnum)[keyof typeof RoleAssignmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'WorkspaceRole'
   */
  export type EnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole'>
    


  /**
   * Reference to a field of type 'WorkspaceRole[]'
   */
  export type ListEnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole[]'>
    


  /**
   * Reference to a field of type 'AppRole'
   */
  export type EnumAppRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppRole'>
    


  /**
   * Reference to a field of type 'AppRole[]'
   */
  export type ListEnumAppRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppRole[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ProjectRole'
   */
  export type EnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole'>
    


  /**
   * Reference to a field of type 'ProjectRole[]'
   */
  export type ListEnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SubtaskStatus'
   */
  export type EnumSubtaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubtaskStatus'>
    


  /**
   * Reference to a field of type 'SubtaskStatus[]'
   */
  export type ListEnumSubtaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubtaskStatus[]'>
    


  /**
   * Reference to a field of type 'TaskLinkType'
   */
  export type EnumTaskLinkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskLinkType'>
    


  /**
   * Reference to a field of type 'TaskLinkType[]'
   */
  export type ListEnumTaskLinkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskLinkType[]'>
    


  /**
   * Reference to a field of type 'CustomFieldType'
   */
  export type EnumCustomFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomFieldType'>
    


  /**
   * Reference to a field of type 'CustomFieldType[]'
   */
  export type ListEnumCustomFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomFieldType[]'>
    


  /**
   * Reference to a field of type 'SprintStatus'
   */
  export type EnumSprintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SprintStatus'>
    


  /**
   * Reference to a field of type 'SprintStatus[]'
   */
  export type ListEnumSprintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SprintStatus[]'>
    


  /**
   * Reference to a field of type 'StickyNoteColor'
   */
  export type EnumStickyNoteColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickyNoteColor'>
    


  /**
   * Reference to a field of type 'StickyNoteColor[]'
   */
  export type ListEnumStickyNoteColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickyNoteColor[]'>
    


  /**
   * Reference to a field of type 'StickyVisibility'
   */
  export type EnumStickyVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickyVisibility'>
    


  /**
   * Reference to a field of type 'StickyVisibility[]'
   */
  export type ListEnumStickyVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickyVisibility[]'>
    


  /**
   * Reference to a field of type 'StickyLinkType'
   */
  export type EnumStickyLinkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickyLinkType'>
    


  /**
   * Reference to a field of type 'StickyLinkType[]'
   */
  export type ListEnumStickyLinkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StickyLinkType[]'>
    


  /**
   * Reference to a field of type 'ProjectGroupStatus'
   */
  export type EnumProjectGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectGroupStatus'>
    


  /**
   * Reference to a field of type 'ProjectGroupStatus[]'
   */
  export type ListEnumProjectGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectGroupStatus[]'>
    


  /**
   * Reference to a field of type 'TaskSessionType'
   */
  export type EnumTaskSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskSessionType'>
    


  /**
   * Reference to a field of type 'TaskSessionType[]'
   */
  export type ListEnumTaskSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskSessionType[]'>
    


  /**
   * Reference to a field of type 'BudgetLineType'
   */
  export type EnumBudgetLineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetLineType'>
    


  /**
   * Reference to a field of type 'BudgetLineType[]'
   */
  export type ListEnumBudgetLineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetLineType[]'>
    


  /**
   * Reference to a field of type 'GroupType'
   */
  export type EnumGroupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupType'>
    


  /**
   * Reference to a field of type 'GroupType[]'
   */
  export type ListEnumGroupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupType[]'>
    


  /**
   * Reference to a field of type 'GroupScope'
   */
  export type EnumGroupScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupScope'>
    


  /**
   * Reference to a field of type 'GroupScope[]'
   */
  export type ListEnumGroupScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupScope[]'>
    


  /**
   * Reference to a field of type 'GroupSource'
   */
  export type EnumGroupSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupSource'>
    


  /**
   * Reference to a field of type 'GroupSource[]'
   */
  export type ListEnumGroupSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupSource[]'>
    


  /**
   * Reference to a field of type 'MemberType'
   */
  export type EnumMemberTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberType'>
    


  /**
   * Reference to a field of type 'MemberType[]'
   */
  export type ListEnumMemberTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberType[]'>
    


  /**
   * Reference to a field of type 'AccessType'
   */
  export type EnumAccessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessType'>
    


  /**
   * Reference to a field of type 'AccessType[]'
   */
  export type ListEnumAccessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessType[]'>
    


  /**
   * Reference to a field of type 'AssignmentRole'
   */
  export type EnumAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentRole'>
    


  /**
   * Reference to a field of type 'AssignmentRole[]'
   */
  export type ListEnumAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentRole[]'>
    
  /**
   * Deep Input Types
   */


  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: IntFilter<"Workspace"> | number
    name?: StringFilter<"Workspace"> | string
    slug?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    logoUrl?: StringNullableFilter<"Workspace"> | string | null
    settings?: JsonFilter<"Workspace">
    isActive?: BoolFilter<"Workspace"> | boolean
    createdById?: IntNullableFilter<"Workspace"> | number | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: WorkspaceUserListRelationFilter
    projects?: ProjectListRelationFilter
    projectGroups?: ProjectGroupListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
    logo?: XOR<WorkspaceLogoNullableScalarRelationFilter, WorkspaceLogoWhereInput> | null
    groups?: GroupListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    users?: WorkspaceUserOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    projectGroups?: ProjectGroupOrderByRelationAggregateInput
    invitations?: WorkspaceInvitationOrderByRelationAggregateInput
    logo?: WorkspaceLogoOrderByWithRelationInput
    groups?: GroupOrderByRelationAggregateInput
    roleAssignments?: RoleAssignmentOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    logoUrl?: StringNullableFilter<"Workspace"> | string | null
    settings?: JsonFilter<"Workspace">
    isActive?: BoolFilter<"Workspace"> | boolean
    createdById?: IntNullableFilter<"Workspace"> | number | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: WorkspaceUserListRelationFilter
    projects?: ProjectListRelationFilter
    projectGroups?: ProjectGroupListRelationFilter
    invitations?: WorkspaceInvitationListRelationFilter
    logo?: XOR<WorkspaceLogoNullableScalarRelationFilter, WorkspaceLogoWhereInput> | null
    groups?: GroupListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
  }, "id" | "slug">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _avg?: WorkspaceAvgOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
    _sum?: WorkspaceSumOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Workspace"> | number
    name?: StringWithAggregatesFilter<"Workspace"> | string
    slug?: StringWithAggregatesFilter<"Workspace"> | string
    description?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    settings?: JsonWithAggregatesFilter<"Workspace">
    isActive?: BoolWithAggregatesFilter<"Workspace"> | boolean
    createdById?: IntNullableWithAggregatesFilter<"Workspace"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceLogoWhereInput = {
    AND?: WorkspaceLogoWhereInput | WorkspaceLogoWhereInput[]
    OR?: WorkspaceLogoWhereInput[]
    NOT?: WorkspaceLogoWhereInput | WorkspaceLogoWhereInput[]
    id?: IntFilter<"WorkspaceLogo"> | number
    workspaceId?: IntFilter<"WorkspaceLogo"> | number
    data?: BytesFilter<"WorkspaceLogo"> | Bytes
    mimeType?: StringFilter<"WorkspaceLogo"> | string
    size?: IntFilter<"WorkspaceLogo"> | number
    createdAt?: DateTimeFilter<"WorkspaceLogo"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceLogo"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceLogoOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceLogoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    workspaceId?: number
    AND?: WorkspaceLogoWhereInput | WorkspaceLogoWhereInput[]
    OR?: WorkspaceLogoWhereInput[]
    NOT?: WorkspaceLogoWhereInput | WorkspaceLogoWhereInput[]
    data?: BytesFilter<"WorkspaceLogo"> | Bytes
    mimeType?: StringFilter<"WorkspaceLogo"> | string
    size?: IntFilter<"WorkspaceLogo"> | number
    createdAt?: DateTimeFilter<"WorkspaceLogo"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceLogo"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId">

  export type WorkspaceLogoOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceLogoCountOrderByAggregateInput
    _avg?: WorkspaceLogoAvgOrderByAggregateInput
    _max?: WorkspaceLogoMaxOrderByAggregateInput
    _min?: WorkspaceLogoMinOrderByAggregateInput
    _sum?: WorkspaceLogoSumOrderByAggregateInput
  }

  export type WorkspaceLogoScalarWhereWithAggregatesInput = {
    AND?: WorkspaceLogoScalarWhereWithAggregatesInput | WorkspaceLogoScalarWhereWithAggregatesInput[]
    OR?: WorkspaceLogoScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceLogoScalarWhereWithAggregatesInput | WorkspaceLogoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkspaceLogo"> | number
    workspaceId?: IntWithAggregatesFilter<"WorkspaceLogo"> | number
    data?: BytesWithAggregatesFilter<"WorkspaceLogo"> | Bytes
    mimeType?: StringWithAggregatesFilter<"WorkspaceLogo"> | string
    size?: IntWithAggregatesFilter<"WorkspaceLogo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceLogo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceLogo"> | Date | string
  }

  export type WorkspaceUserWhereInput = {
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    id?: IntFilter<"WorkspaceUser"> | number
    workspaceId?: IntFilter<"WorkspaceUser"> | number
    userId?: IntFilter<"WorkspaceUser"> | number
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkspaceUserOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WorkspaceUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    workspaceId_userId?: WorkspaceUserWorkspaceIdUserIdCompoundUniqueInput
    AND?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    OR?: WorkspaceUserWhereInput[]
    NOT?: WorkspaceUserWhereInput | WorkspaceUserWhereInput[]
    workspaceId?: IntFilter<"WorkspaceUser"> | number
    userId?: IntFilter<"WorkspaceUser"> | number
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "workspaceId_userId">

  export type WorkspaceUserOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: WorkspaceUserCountOrderByAggregateInput
    _avg?: WorkspaceUserAvgOrderByAggregateInput
    _max?: WorkspaceUserMaxOrderByAggregateInput
    _min?: WorkspaceUserMinOrderByAggregateInput
    _sum?: WorkspaceUserSumOrderByAggregateInput
  }

  export type WorkspaceUserScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    OR?: WorkspaceUserScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceUserScalarWhereWithAggregatesInput | WorkspaceUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkspaceUser"> | number
    workspaceId?: IntWithAggregatesFilter<"WorkspaceUser"> | number
    userId?: IntWithAggregatesFilter<"WorkspaceUser"> | number
    role?: EnumWorkspaceRoleWithAggregatesFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceUser"> | Date | string
  }

  export type WorkspaceInvitationWhereInput = {
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    id?: IntFilter<"WorkspaceInvitation"> | number
    workspaceId?: IntFilter<"WorkspaceInvitation"> | number
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    token?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdBy?: IntFilter<"WorkspaceInvitation"> | number
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkspaceInvitationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type WorkspaceInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    OR?: WorkspaceInvitationWhereInput[]
    NOT?: WorkspaceInvitationWhereInput | WorkspaceInvitationWhereInput[]
    workspaceId?: IntFilter<"WorkspaceInvitation"> | number
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdBy?: IntFilter<"WorkspaceInvitation"> | number
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type WorkspaceInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: WorkspaceInvitationCountOrderByAggregateInput
    _avg?: WorkspaceInvitationAvgOrderByAggregateInput
    _max?: WorkspaceInvitationMaxOrderByAggregateInput
    _min?: WorkspaceInvitationMinOrderByAggregateInput
    _sum?: WorkspaceInvitationSumOrderByAggregateInput
  }

  export type WorkspaceInvitationScalarWhereWithAggregatesInput = {
    AND?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    OR?: WorkspaceInvitationScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceInvitationScalarWhereWithAggregatesInput | WorkspaceInvitationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkspaceInvitation"> | number
    workspaceId?: IntWithAggregatesFilter<"WorkspaceInvitation"> | number
    email?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleWithAggregatesFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    token?: StringWithAggregatesFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceInvitation"> | Date | string
    createdBy?: IntWithAggregatesFilter<"WorkspaceInvitation"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    language?: StringFilter<"User"> | string
    settings?: JsonFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    role?: EnumAppRoleFilter<"User"> | $Enums.AppRole
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twofactorActivated?: BoolFilter<"User"> | boolean
    twofactorSecret?: StringNullableFilter<"User"> | string | null
    failedLoginCount?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    lockoutCount?: IntFilter<"User"> | number
    googleId?: StringNullableFilter<"User"> | string | null
    githubId?: StringNullableFilter<"User"> | string | null
    gitlabId?: IntNullableFilter<"User"> | number | null
    theme?: StringFilter<"User"> | string
    defaultFilter?: StringNullableFilter<"User"> | string | null
    publicToken?: StringNullableFilter<"User"> | string | null
    hourlyRate?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFilter<"User"> | boolean
    notificationFilter?: IntFilter<"User"> | number
    workspaces?: WorkspaceUserListRelationFilter
    workspacesCreated?: WorkspaceListRelationFilter
    invitationsCreated?: WorkspaceInvitationListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    tasksCreated?: TaskListRelationFilter
    tasksAssigned?: TaskAssigneeListRelationFilter
    subtasksAssigned?: SubtaskListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    sessions?: SessionListRelationFilter
    rememberTokens?: RememberTokenListRelationFilter
    notifications?: NotificationListRelationFilter
    activities?: ActivityListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    lastLogins?: LastLoginListRelationFilter
    metadata?: UserMetadataListRelationFilter
    notificationSettings?: UserNotificationSettingListRelationFilter
    avatar?: XOR<UserAvatarNullableScalarRelationFilter, UserAvatarWhereInput> | null
    invitesSent?: InviteListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    groupMembersAdded?: GroupMemberListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twofactorActivated?: SortOrder
    twofactorSecret?: SortOrderInput | SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lockoutCount?: SortOrder
    googleId?: SortOrderInput | SortOrder
    githubId?: SortOrderInput | SortOrder
    gitlabId?: SortOrderInput | SortOrder
    theme?: SortOrder
    defaultFilter?: SortOrderInput | SortOrder
    publicToken?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    notificationsEnabled?: SortOrder
    notificationFilter?: SortOrder
    workspaces?: WorkspaceUserOrderByRelationAggregateInput
    workspacesCreated?: WorkspaceOrderByRelationAggregateInput
    invitationsCreated?: WorkspaceInvitationOrderByRelationAggregateInput
    projectMembers?: ProjectMemberOrderByRelationAggregateInput
    tasksCreated?: TaskOrderByRelationAggregateInput
    tasksAssigned?: TaskAssigneeOrderByRelationAggregateInput
    subtasksAssigned?: SubtaskOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    rememberTokens?: RememberTokenOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    passwordResets?: PasswordResetOrderByRelationAggregateInput
    lastLogins?: LastLoginOrderByRelationAggregateInput
    metadata?: UserMetadataOrderByRelationAggregateInput
    notificationSettings?: UserNotificationSettingOrderByRelationAggregateInput
    avatar?: UserAvatarOrderByWithRelationInput
    invitesSent?: InviteOrderByRelationAggregateInput
    groupMemberships?: GroupMemberOrderByRelationAggregateInput
    groupMembersAdded?: GroupMemberOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    username?: string
    publicToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    language?: StringFilter<"User"> | string
    settings?: JsonFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    role?: EnumAppRoleFilter<"User"> | $Enums.AppRole
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    twofactorActivated?: BoolFilter<"User"> | boolean
    twofactorSecret?: StringNullableFilter<"User"> | string | null
    failedLoginCount?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    lockoutCount?: IntFilter<"User"> | number
    googleId?: StringNullableFilter<"User"> | string | null
    githubId?: StringNullableFilter<"User"> | string | null
    gitlabId?: IntNullableFilter<"User"> | number | null
    theme?: StringFilter<"User"> | string
    defaultFilter?: StringNullableFilter<"User"> | string | null
    hourlyRate?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFilter<"User"> | boolean
    notificationFilter?: IntFilter<"User"> | number
    workspaces?: WorkspaceUserListRelationFilter
    workspacesCreated?: WorkspaceListRelationFilter
    invitationsCreated?: WorkspaceInvitationListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    tasksCreated?: TaskListRelationFilter
    tasksAssigned?: TaskAssigneeListRelationFilter
    subtasksAssigned?: SubtaskListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    sessions?: SessionListRelationFilter
    rememberTokens?: RememberTokenListRelationFilter
    notifications?: NotificationListRelationFilter
    activities?: ActivityListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    lastLogins?: LastLoginListRelationFilter
    metadata?: UserMetadataListRelationFilter
    notificationSettings?: UserNotificationSettingListRelationFilter
    avatar?: XOR<UserAvatarNullableScalarRelationFilter, UserAvatarWhereInput> | null
    invitesSent?: InviteListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    groupMembersAdded?: GroupMemberListRelationFilter
  }, "id" | "email" | "username" | "publicToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twofactorActivated?: SortOrder
    twofactorSecret?: SortOrderInput | SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    lockoutCount?: SortOrder
    googleId?: SortOrderInput | SortOrder
    githubId?: SortOrderInput | SortOrder
    gitlabId?: SortOrderInput | SortOrder
    theme?: SortOrder
    defaultFilter?: SortOrderInput | SortOrder
    publicToken?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    notificationsEnabled?: SortOrder
    notificationFilter?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    language?: StringWithAggregatesFilter<"User"> | string
    settings?: JsonWithAggregatesFilter<"User">
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumAppRoleWithAggregatesFilter<"User"> | $Enums.AppRole
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    twofactorActivated?: BoolWithAggregatesFilter<"User"> | boolean
    twofactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    failedLoginCount?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lockoutCount?: IntWithAggregatesFilter<"User"> | number
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    githubId?: StringNullableWithAggregatesFilter<"User"> | string | null
    gitlabId?: IntNullableWithAggregatesFilter<"User"> | number | null
    theme?: StringWithAggregatesFilter<"User"> | string
    defaultFilter?: StringNullableWithAggregatesFilter<"User"> | string | null
    publicToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    hourlyRate?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    notificationFilter?: IntWithAggregatesFilter<"User"> | number
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    data?: JsonFilter<"Session">
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    data?: JsonFilter<"Session">
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    data?: JsonWithAggregatesFilter<"Session">
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type RememberTokenWhereInput = {
    AND?: RememberTokenWhereInput | RememberTokenWhereInput[]
    OR?: RememberTokenWhereInput[]
    NOT?: RememberTokenWhereInput | RememberTokenWhereInput[]
    id?: IntFilter<"RememberToken"> | number
    userId?: IntFilter<"RememberToken"> | number
    token?: StringFilter<"RememberToken"> | string
    expiresAt?: DateTimeFilter<"RememberToken"> | Date | string
    createdAt?: DateTimeFilter<"RememberToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RememberTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RememberTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: RememberTokenWhereInput | RememberTokenWhereInput[]
    OR?: RememberTokenWhereInput[]
    NOT?: RememberTokenWhereInput | RememberTokenWhereInput[]
    userId?: IntFilter<"RememberToken"> | number
    expiresAt?: DateTimeFilter<"RememberToken"> | Date | string
    createdAt?: DateTimeFilter<"RememberToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RememberTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RememberTokenCountOrderByAggregateInput
    _avg?: RememberTokenAvgOrderByAggregateInput
    _max?: RememberTokenMaxOrderByAggregateInput
    _min?: RememberTokenMinOrderByAggregateInput
    _sum?: RememberTokenSumOrderByAggregateInput
  }

  export type RememberTokenScalarWhereWithAggregatesInput = {
    AND?: RememberTokenScalarWhereWithAggregatesInput | RememberTokenScalarWhereWithAggregatesInput[]
    OR?: RememberTokenScalarWhereWithAggregatesInput[]
    NOT?: RememberTokenScalarWhereWithAggregatesInput | RememberTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RememberToken"> | number
    userId?: IntWithAggregatesFilter<"RememberToken"> | number
    token?: StringWithAggregatesFilter<"RememberToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RememberToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RememberToken"> | Date | string
  }

  export type InviteWhereInput = {
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    id?: IntFilter<"Invite"> | number
    email?: StringFilter<"Invite"> | string
    token?: StringFilter<"Invite"> | string
    role?: EnumAppRoleFilter<"Invite"> | $Enums.AppRole
    invitedById?: IntFilter<"Invite"> | number
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    invitedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InviteOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invitedBy?: UserOrderByWithRelationInput
  }

  export type InviteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    email?: StringFilter<"Invite"> | string
    role?: EnumAppRoleFilter<"Invite"> | $Enums.AppRole
    invitedById?: IntFilter<"Invite"> | number
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    invitedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type InviteOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InviteCountOrderByAggregateInput
    _avg?: InviteAvgOrderByAggregateInput
    _max?: InviteMaxOrderByAggregateInput
    _min?: InviteMinOrderByAggregateInput
    _sum?: InviteSumOrderByAggregateInput
  }

  export type InviteScalarWhereWithAggregatesInput = {
    AND?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    OR?: InviteScalarWhereWithAggregatesInput[]
    NOT?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invite"> | number
    email?: StringWithAggregatesFilter<"Invite"> | string
    token?: StringWithAggregatesFilter<"Invite"> | string
    role?: EnumAppRoleWithAggregatesFilter<"Invite"> | $Enums.AppRole
    invitedById?: IntWithAggregatesFilter<"Invite"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    key?: StringFilter<"SystemSetting"> | string
    value?: StringNullableFilter<"SystemSetting"> | string | null
    changedBy?: IntNullableFilter<"SystemSetting"> | number | null
    changedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    changedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringNullableFilter<"SystemSetting"> | string | null
    changedBy?: IntNullableFilter<"SystemSetting"> | number | null
    changedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "key">

  export type SystemSettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _avg?: SystemSettingAvgOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
    _sum?: SystemSettingSumOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    changedBy?: IntNullableWithAggregatesFilter<"SystemSetting"> | number | null
    changedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    workspaceId?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    identifier?: StringNullableFilter<"Project"> | string | null
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    isActive?: BoolFilter<"Project"> | boolean
    isPublic?: BoolFilter<"Project"> | boolean
    settings?: JsonFilter<"Project">
    lastActivityAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    members?: ProjectMemberListRelationFilter
    columns?: ColumnListRelationFilter
    swimlanes?: SwimlaneListRelationFilter
    tasks?: TaskListRelationFilter
    tags?: TagListRelationFilter
    categories?: CategoryListRelationFilter
    customFields?: CustomFieldListRelationFilter
    modules?: ModuleListRelationFilter
    milestones?: MilestoneListRelationFilter
    sprints?: SprintListRelationFilter
    budgets?: BudgetListRelationFilter
    wikiPages?: WikiPageListRelationFilter
    activities?: ActivityListRelationFilter
    projectGroups?: ProjectGroupMemberListRelationFilter
    webhooks?: WebhookListRelationFilter
    groups?: GroupListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    identifier?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    settings?: SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    columns?: ColumnOrderByRelationAggregateInput
    swimlanes?: SwimlaneOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    customFields?: CustomFieldOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    sprints?: SprintOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    wikiPages?: WikiPageOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    projectGroups?: ProjectGroupMemberOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
    roleAssignments?: RoleAssignmentOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    workspaceId_identifier?: ProjectWorkspaceIdIdentifierCompoundUniqueInput
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    workspaceId?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    identifier?: StringNullableFilter<"Project"> | string | null
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    isActive?: BoolFilter<"Project"> | boolean
    isPublic?: BoolFilter<"Project"> | boolean
    settings?: JsonFilter<"Project">
    lastActivityAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    members?: ProjectMemberListRelationFilter
    columns?: ColumnListRelationFilter
    swimlanes?: SwimlaneListRelationFilter
    tasks?: TaskListRelationFilter
    tags?: TagListRelationFilter
    categories?: CategoryListRelationFilter
    customFields?: CustomFieldListRelationFilter
    modules?: ModuleListRelationFilter
    milestones?: MilestoneListRelationFilter
    sprints?: SprintListRelationFilter
    budgets?: BudgetListRelationFilter
    wikiPages?: WikiPageListRelationFilter
    activities?: ActivityListRelationFilter
    projectGroups?: ProjectGroupMemberListRelationFilter
    webhooks?: WebhookListRelationFilter
    groups?: GroupListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
  }, "id" | "workspaceId_identifier">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    identifier?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    settings?: SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    workspaceId?: IntWithAggregatesFilter<"Project"> | number
    name?: StringWithAggregatesFilter<"Project"> | string
    identifier?: StringNullableWithAggregatesFilter<"Project"> | string | null
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Project"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Project"> | boolean
    settings?: JsonWithAggregatesFilter<"Project">
    lastActivityAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _avg?: ProjectMemberAvgOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
    _sum?: ProjectMemberSumOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectMember"> | number
    projectId?: IntWithAggregatesFilter<"ProjectMember"> | number
    userId?: IntWithAggregatesFilter<"ProjectMember"> | number
    role?: EnumProjectRoleWithAggregatesFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type ColumnWhereInput = {
    AND?: ColumnWhereInput | ColumnWhereInput[]
    OR?: ColumnWhereInput[]
    NOT?: ColumnWhereInput | ColumnWhereInput[]
    id?: IntFilter<"Column"> | number
    projectId?: IntFilter<"Column"> | number
    title?: StringFilter<"Column"> | string
    description?: StringNullableFilter<"Column"> | string | null
    position?: IntFilter<"Column"> | number
    taskLimit?: IntFilter<"Column"> | number
    isCollapsed?: BoolFilter<"Column"> | boolean
    showClosed?: BoolFilter<"Column"> | boolean
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type ColumnOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
    isCollapsed?: SortOrder
    showClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ColumnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ColumnWhereInput | ColumnWhereInput[]
    OR?: ColumnWhereInput[]
    NOT?: ColumnWhereInput | ColumnWhereInput[]
    projectId?: IntFilter<"Column"> | number
    title?: StringFilter<"Column"> | string
    description?: StringNullableFilter<"Column"> | string | null
    position?: IntFilter<"Column"> | number
    taskLimit?: IntFilter<"Column"> | number
    isCollapsed?: BoolFilter<"Column"> | boolean
    showClosed?: BoolFilter<"Column"> | boolean
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type ColumnOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
    isCollapsed?: SortOrder
    showClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ColumnCountOrderByAggregateInput
    _avg?: ColumnAvgOrderByAggregateInput
    _max?: ColumnMaxOrderByAggregateInput
    _min?: ColumnMinOrderByAggregateInput
    _sum?: ColumnSumOrderByAggregateInput
  }

  export type ColumnScalarWhereWithAggregatesInput = {
    AND?: ColumnScalarWhereWithAggregatesInput | ColumnScalarWhereWithAggregatesInput[]
    OR?: ColumnScalarWhereWithAggregatesInput[]
    NOT?: ColumnScalarWhereWithAggregatesInput | ColumnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Column"> | number
    projectId?: IntWithAggregatesFilter<"Column"> | number
    title?: StringWithAggregatesFilter<"Column"> | string
    description?: StringNullableWithAggregatesFilter<"Column"> | string | null
    position?: IntWithAggregatesFilter<"Column"> | number
    taskLimit?: IntWithAggregatesFilter<"Column"> | number
    isCollapsed?: BoolWithAggregatesFilter<"Column"> | boolean
    showClosed?: BoolWithAggregatesFilter<"Column"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Column"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Column"> | Date | string
  }

  export type SwimlaneWhereInput = {
    AND?: SwimlaneWhereInput | SwimlaneWhereInput[]
    OR?: SwimlaneWhereInput[]
    NOT?: SwimlaneWhereInput | SwimlaneWhereInput[]
    id?: IntFilter<"Swimlane"> | number
    projectId?: IntFilter<"Swimlane"> | number
    name?: StringFilter<"Swimlane"> | string
    description?: StringNullableFilter<"Swimlane"> | string | null
    position?: IntFilter<"Swimlane"> | number
    isActive?: BoolFilter<"Swimlane"> | boolean
    createdAt?: DateTimeFilter<"Swimlane"> | Date | string
    updatedAt?: DateTimeFilter<"Swimlane"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type SwimlaneOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type SwimlaneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SwimlaneWhereInput | SwimlaneWhereInput[]
    OR?: SwimlaneWhereInput[]
    NOT?: SwimlaneWhereInput | SwimlaneWhereInput[]
    projectId?: IntFilter<"Swimlane"> | number
    name?: StringFilter<"Swimlane"> | string
    description?: StringNullableFilter<"Swimlane"> | string | null
    position?: IntFilter<"Swimlane"> | number
    isActive?: BoolFilter<"Swimlane"> | boolean
    createdAt?: DateTimeFilter<"Swimlane"> | Date | string
    updatedAt?: DateTimeFilter<"Swimlane"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type SwimlaneOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SwimlaneCountOrderByAggregateInput
    _avg?: SwimlaneAvgOrderByAggregateInput
    _max?: SwimlaneMaxOrderByAggregateInput
    _min?: SwimlaneMinOrderByAggregateInput
    _sum?: SwimlaneSumOrderByAggregateInput
  }

  export type SwimlaneScalarWhereWithAggregatesInput = {
    AND?: SwimlaneScalarWhereWithAggregatesInput | SwimlaneScalarWhereWithAggregatesInput[]
    OR?: SwimlaneScalarWhereWithAggregatesInput[]
    NOT?: SwimlaneScalarWhereWithAggregatesInput | SwimlaneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Swimlane"> | number
    projectId?: IntWithAggregatesFilter<"Swimlane"> | number
    name?: StringWithAggregatesFilter<"Swimlane"> | string
    description?: StringNullableWithAggregatesFilter<"Swimlane"> | string | null
    position?: IntWithAggregatesFilter<"Swimlane"> | number
    isActive?: BoolWithAggregatesFilter<"Swimlane"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Swimlane"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Swimlane"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    projectId?: IntFilter<"Task"> | number
    columnId?: IntFilter<"Task"> | number
    swimlaneId?: IntNullableFilter<"Task"> | number | null
    creatorId?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    reference?: StringNullableFilter<"Task"> | string | null
    priority?: IntFilter<"Task"> | number
    score?: IntFilter<"Task"> | number
    progress?: IntFilter<"Task"> | number
    position?: IntFilter<"Task"> | number
    color?: StringNullableFilter<"Task"> | string | null
    dateStarted?: DateTimeNullableFilter<"Task"> | Date | string | null
    dateDue?: DateTimeNullableFilter<"Task"> | Date | string | null
    dateCompleted?: DateTimeNullableFilter<"Task"> | Date | string | null
    reminderAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    timeEstimated?: FloatFilter<"Task"> | number
    timeSpent?: FloatFilter<"Task"> | number
    isActive?: BoolFilter<"Task"> | boolean
    isDraggable?: BoolFilter<"Task"> | boolean
    recurrenceData?: JsonNullableFilter<"Task">
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    milestoneId?: IntNullableFilter<"Task"> | number | null
    moduleId?: IntNullableFilter<"Task"> | number | null
    sprintId?: IntNullableFilter<"Task"> | number | null
    categoryId?: IntNullableFilter<"Task"> | number | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    column?: XOR<ColumnScalarRelationFilter, ColumnWhereInput>
    swimlane?: XOR<SwimlaneNullableScalarRelationFilter, SwimlaneWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    milestone?: XOR<MilestoneNullableScalarRelationFilter, MilestoneWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    assignees?: TaskAssigneeListRelationFilter
    subtasks?: SubtaskListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    tags?: TaskTagListRelationFilter
    customValues?: TaskCustomValueListRelationFilter
    linksFrom?: TaskLinkListRelationFilter
    linksTo?: TaskLinkListRelationFilter
    genxSessions?: TaskSessionListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    color?: SortOrderInput | SortOrder
    dateStarted?: SortOrderInput | SortOrder
    dateDue?: SortOrderInput | SortOrder
    dateCompleted?: SortOrderInput | SortOrder
    reminderAt?: SortOrderInput | SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    isDraggable?: SortOrder
    recurrenceData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestoneId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    sprintId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    column?: ColumnOrderByWithRelationInput
    swimlane?: SwimlaneOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    milestone?: MilestoneOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    assignees?: TaskAssigneeOrderByRelationAggregateInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    tags?: TaskTagOrderByRelationAggregateInput
    customValues?: TaskCustomValueOrderByRelationAggregateInput
    linksFrom?: TaskLinkOrderByRelationAggregateInput
    linksTo?: TaskLinkOrderByRelationAggregateInput
    genxSessions?: TaskSessionOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    projectId?: IntFilter<"Task"> | number
    columnId?: IntFilter<"Task"> | number
    swimlaneId?: IntNullableFilter<"Task"> | number | null
    creatorId?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    reference?: StringNullableFilter<"Task"> | string | null
    priority?: IntFilter<"Task"> | number
    score?: IntFilter<"Task"> | number
    progress?: IntFilter<"Task"> | number
    position?: IntFilter<"Task"> | number
    color?: StringNullableFilter<"Task"> | string | null
    dateStarted?: DateTimeNullableFilter<"Task"> | Date | string | null
    dateDue?: DateTimeNullableFilter<"Task"> | Date | string | null
    dateCompleted?: DateTimeNullableFilter<"Task"> | Date | string | null
    reminderAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    timeEstimated?: FloatFilter<"Task"> | number
    timeSpent?: FloatFilter<"Task"> | number
    isActive?: BoolFilter<"Task"> | boolean
    isDraggable?: BoolFilter<"Task"> | boolean
    recurrenceData?: JsonNullableFilter<"Task">
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    milestoneId?: IntNullableFilter<"Task"> | number | null
    moduleId?: IntNullableFilter<"Task"> | number | null
    sprintId?: IntNullableFilter<"Task"> | number | null
    categoryId?: IntNullableFilter<"Task"> | number | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    column?: XOR<ColumnScalarRelationFilter, ColumnWhereInput>
    swimlane?: XOR<SwimlaneNullableScalarRelationFilter, SwimlaneWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    milestone?: XOR<MilestoneNullableScalarRelationFilter, MilestoneWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    assignees?: TaskAssigneeListRelationFilter
    subtasks?: SubtaskListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    tags?: TaskTagListRelationFilter
    customValues?: TaskCustomValueListRelationFilter
    linksFrom?: TaskLinkListRelationFilter
    linksTo?: TaskLinkListRelationFilter
    genxSessions?: TaskSessionListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    color?: SortOrderInput | SortOrder
    dateStarted?: SortOrderInput | SortOrder
    dateDue?: SortOrderInput | SortOrder
    dateCompleted?: SortOrderInput | SortOrder
    reminderAt?: SortOrderInput | SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    isDraggable?: SortOrder
    recurrenceData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestoneId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    sprintId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    projectId?: IntWithAggregatesFilter<"Task"> | number
    columnId?: IntWithAggregatesFilter<"Task"> | number
    swimlaneId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    creatorId?: IntWithAggregatesFilter<"Task"> | number
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Task"> | string | null
    priority?: IntWithAggregatesFilter<"Task"> | number
    score?: IntWithAggregatesFilter<"Task"> | number
    progress?: IntWithAggregatesFilter<"Task"> | number
    position?: IntWithAggregatesFilter<"Task"> | number
    color?: StringNullableWithAggregatesFilter<"Task"> | string | null
    dateStarted?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    dateDue?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    dateCompleted?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    reminderAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    timeEstimated?: FloatWithAggregatesFilter<"Task"> | number
    timeSpent?: FloatWithAggregatesFilter<"Task"> | number
    isActive?: BoolWithAggregatesFilter<"Task"> | boolean
    isDraggable?: BoolWithAggregatesFilter<"Task"> | boolean
    recurrenceData?: JsonNullableWithAggregatesFilter<"Task">
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    milestoneId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    moduleId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    sprintId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    categoryId?: IntNullableWithAggregatesFilter<"Task"> | number | null
  }

  export type TaskAssigneeWhereInput = {
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    id?: IntFilter<"TaskAssignee"> | number
    taskId?: IntFilter<"TaskAssignee"> | number
    userId?: IntFilter<"TaskAssignee"> | number
    createdAt?: DateTimeFilter<"TaskAssignee"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskAssigneeOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskAssigneeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId_userId?: TaskAssigneeTaskIdUserIdCompoundUniqueInput
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    taskId?: IntFilter<"TaskAssignee"> | number
    userId?: IntFilter<"TaskAssignee"> | number
    createdAt?: DateTimeFilter<"TaskAssignee"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "taskId_userId">

  export type TaskAssigneeOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: TaskAssigneeCountOrderByAggregateInput
    _avg?: TaskAssigneeAvgOrderByAggregateInput
    _max?: TaskAssigneeMaxOrderByAggregateInput
    _min?: TaskAssigneeMinOrderByAggregateInput
    _sum?: TaskAssigneeSumOrderByAggregateInput
  }

  export type TaskAssigneeScalarWhereWithAggregatesInput = {
    AND?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    OR?: TaskAssigneeScalarWhereWithAggregatesInput[]
    NOT?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskAssignee"> | number
    taskId?: IntWithAggregatesFilter<"TaskAssignee"> | number
    userId?: IntWithAggregatesFilter<"TaskAssignee"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TaskAssignee"> | Date | string
  }

  export type SubtaskWhereInput = {
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    id?: IntFilter<"Subtask"> | number
    taskId?: IntFilter<"Subtask"> | number
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusFilter<"Subtask"> | $Enums.SubtaskStatus
    position?: IntFilter<"Subtask"> | number
    assigneeId?: IntNullableFilter<"Subtask"> | number | null
    timeEstimated?: FloatFilter<"Subtask"> | number
    timeSpent?: FloatFilter<"Subtask"> | number
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SubtaskOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
  }

  export type SubtaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    taskId?: IntFilter<"Subtask"> | number
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusFilter<"Subtask"> | $Enums.SubtaskStatus
    position?: IntFilter<"Subtask"> | number
    assigneeId?: IntNullableFilter<"Subtask"> | number | null
    timeEstimated?: FloatFilter<"Subtask"> | number
    timeSpent?: FloatFilter<"Subtask"> | number
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SubtaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubtaskCountOrderByAggregateInput
    _avg?: SubtaskAvgOrderByAggregateInput
    _max?: SubtaskMaxOrderByAggregateInput
    _min?: SubtaskMinOrderByAggregateInput
    _sum?: SubtaskSumOrderByAggregateInput
  }

  export type SubtaskScalarWhereWithAggregatesInput = {
    AND?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    OR?: SubtaskScalarWhereWithAggregatesInput[]
    NOT?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subtask"> | number
    taskId?: IntWithAggregatesFilter<"Subtask"> | number
    title?: StringWithAggregatesFilter<"Subtask"> | string
    description?: StringNullableWithAggregatesFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusWithAggregatesFilter<"Subtask"> | $Enums.SubtaskStatus
    position?: IntWithAggregatesFilter<"Subtask"> | number
    assigneeId?: IntNullableWithAggregatesFilter<"Subtask"> | number | null
    timeEstimated?: FloatWithAggregatesFilter<"Subtask"> | number
    timeSpent?: FloatWithAggregatesFilter<"Subtask"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subtask"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    taskId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    taskId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    taskId?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    projectId?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_name?: TagProjectIdNameCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    projectId?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskTagListRelationFilter
  }, "id" | "projectId_name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    projectId?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TaskTagWhereInput = {
    AND?: TaskTagWhereInput | TaskTagWhereInput[]
    OR?: TaskTagWhereInput[]
    NOT?: TaskTagWhereInput | TaskTagWhereInput[]
    id?: IntFilter<"TaskTag"> | number
    taskId?: IntFilter<"TaskTag"> | number
    tagId?: IntFilter<"TaskTag"> | number
    createdAt?: DateTimeFilter<"TaskTag"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type TaskTagOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TaskTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId_tagId?: TaskTagTaskIdTagIdCompoundUniqueInput
    AND?: TaskTagWhereInput | TaskTagWhereInput[]
    OR?: TaskTagWhereInput[]
    NOT?: TaskTagWhereInput | TaskTagWhereInput[]
    taskId?: IntFilter<"TaskTag"> | number
    tagId?: IntFilter<"TaskTag"> | number
    createdAt?: DateTimeFilter<"TaskTag"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "taskId_tagId">

  export type TaskTagOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: TaskTagCountOrderByAggregateInput
    _avg?: TaskTagAvgOrderByAggregateInput
    _max?: TaskTagMaxOrderByAggregateInput
    _min?: TaskTagMinOrderByAggregateInput
    _sum?: TaskTagSumOrderByAggregateInput
  }

  export type TaskTagScalarWhereWithAggregatesInput = {
    AND?: TaskTagScalarWhereWithAggregatesInput | TaskTagScalarWhereWithAggregatesInput[]
    OR?: TaskTagScalarWhereWithAggregatesInput[]
    NOT?: TaskTagScalarWhereWithAggregatesInput | TaskTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskTag"> | number
    taskId?: IntWithAggregatesFilter<"TaskTag"> | number
    tagId?: IntWithAggregatesFilter<"TaskTag"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TaskTag"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    projectId?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_name?: CategoryProjectIdNameCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    projectId?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id" | "projectId_name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    projectId?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: IntFilter<"Attachment"> | number
    taskId?: IntFilter<"Attachment"> | number
    userId?: IntFilter<"Attachment"> | number
    name?: StringFilter<"Attachment"> | string
    path?: StringFilter<"Attachment"> | string
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    size?: IntFilter<"Attachment"> | number
    isImage?: BoolFilter<"Attachment"> | boolean
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrder
    isImage?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    taskId?: IntFilter<"Attachment"> | number
    userId?: IntFilter<"Attachment"> | number
    name?: StringFilter<"Attachment"> | string
    path?: StringFilter<"Attachment"> | string
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    size?: IntFilter<"Attachment"> | number
    isImage?: BoolFilter<"Attachment"> | boolean
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrder
    isImage?: SortOrder
    createdAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attachment"> | number
    taskId?: IntWithAggregatesFilter<"Attachment"> | number
    userId?: IntWithAggregatesFilter<"Attachment"> | number
    name?: StringWithAggregatesFilter<"Attachment"> | string
    path?: StringWithAggregatesFilter<"Attachment"> | string
    mimeType?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    size?: IntWithAggregatesFilter<"Attachment"> | number
    isImage?: BoolWithAggregatesFilter<"Attachment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type TaskLinkWhereInput = {
    AND?: TaskLinkWhereInput | TaskLinkWhereInput[]
    OR?: TaskLinkWhereInput[]
    NOT?: TaskLinkWhereInput | TaskLinkWhereInput[]
    id?: IntFilter<"TaskLink"> | number
    taskId?: IntFilter<"TaskLink"> | number
    oppositeTaskId?: IntFilter<"TaskLink"> | number
    linkType?: EnumTaskLinkTypeFilter<"TaskLink"> | $Enums.TaskLinkType
    createdAt?: DateTimeFilter<"TaskLink"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    oppositeTask?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskLinkOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
    linkType?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    oppositeTask?: TaskOrderByWithRelationInput
  }

  export type TaskLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId_oppositeTaskId_linkType?: TaskLinkTaskIdOppositeTaskIdLinkTypeCompoundUniqueInput
    AND?: TaskLinkWhereInput | TaskLinkWhereInput[]
    OR?: TaskLinkWhereInput[]
    NOT?: TaskLinkWhereInput | TaskLinkWhereInput[]
    taskId?: IntFilter<"TaskLink"> | number
    oppositeTaskId?: IntFilter<"TaskLink"> | number
    linkType?: EnumTaskLinkTypeFilter<"TaskLink"> | $Enums.TaskLinkType
    createdAt?: DateTimeFilter<"TaskLink"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    oppositeTask?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "taskId_oppositeTaskId_linkType">

  export type TaskLinkOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
    linkType?: SortOrder
    createdAt?: SortOrder
    _count?: TaskLinkCountOrderByAggregateInput
    _avg?: TaskLinkAvgOrderByAggregateInput
    _max?: TaskLinkMaxOrderByAggregateInput
    _min?: TaskLinkMinOrderByAggregateInput
    _sum?: TaskLinkSumOrderByAggregateInput
  }

  export type TaskLinkScalarWhereWithAggregatesInput = {
    AND?: TaskLinkScalarWhereWithAggregatesInput | TaskLinkScalarWhereWithAggregatesInput[]
    OR?: TaskLinkScalarWhereWithAggregatesInput[]
    NOT?: TaskLinkScalarWhereWithAggregatesInput | TaskLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskLink"> | number
    taskId?: IntWithAggregatesFilter<"TaskLink"> | number
    oppositeTaskId?: IntWithAggregatesFilter<"TaskLink"> | number
    linkType?: EnumTaskLinkTypeWithAggregatesFilter<"TaskLink"> | $Enums.TaskLinkType
    createdAt?: DateTimeWithAggregatesFilter<"TaskLink"> | Date | string
  }

  export type CustomFieldWhereInput = {
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    id?: IntFilter<"CustomField"> | number
    projectId?: IntFilter<"CustomField"> | number
    name?: StringFilter<"CustomField"> | string
    type?: EnumCustomFieldTypeFilter<"CustomField"> | $Enums.CustomFieldType
    options?: JsonNullableFilter<"CustomField">
    isRequired?: BoolFilter<"CustomField"> | boolean
    position?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    values?: TaskCustomValueListRelationFilter
  }

  export type CustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    values?: TaskCustomValueOrderByRelationAggregateInput
  }

  export type CustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_name?: CustomFieldProjectIdNameCompoundUniqueInput
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    projectId?: IntFilter<"CustomField"> | number
    name?: StringFilter<"CustomField"> | string
    type?: EnumCustomFieldTypeFilter<"CustomField"> | $Enums.CustomFieldType
    options?: JsonNullableFilter<"CustomField">
    isRequired?: BoolFilter<"CustomField"> | boolean
    position?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    values?: TaskCustomValueListRelationFilter
  }, "id" | "projectId_name">

  export type CustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    _count?: CustomFieldCountOrderByAggregateInput
    _avg?: CustomFieldAvgOrderByAggregateInput
    _max?: CustomFieldMaxOrderByAggregateInput
    _min?: CustomFieldMinOrderByAggregateInput
    _sum?: CustomFieldSumOrderByAggregateInput
  }

  export type CustomFieldScalarWhereWithAggregatesInput = {
    AND?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    OR?: CustomFieldScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomField"> | number
    projectId?: IntWithAggregatesFilter<"CustomField"> | number
    name?: StringWithAggregatesFilter<"CustomField"> | string
    type?: EnumCustomFieldTypeWithAggregatesFilter<"CustomField"> | $Enums.CustomFieldType
    options?: JsonNullableWithAggregatesFilter<"CustomField">
    isRequired?: BoolWithAggregatesFilter<"CustomField"> | boolean
    position?: IntWithAggregatesFilter<"CustomField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomField"> | Date | string
  }

  export type TaskCustomValueWhereInput = {
    AND?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    OR?: TaskCustomValueWhereInput[]
    NOT?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    id?: IntFilter<"TaskCustomValue"> | number
    taskId?: IntFilter<"TaskCustomValue"> | number
    customFieldId?: IntFilter<"TaskCustomValue"> | number
    value?: StringFilter<"TaskCustomValue"> | string
    createdAt?: DateTimeFilter<"TaskCustomValue"> | Date | string
    updatedAt?: DateTimeFilter<"TaskCustomValue"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    customField?: XOR<CustomFieldScalarRelationFilter, CustomFieldWhereInput>
  }

  export type TaskCustomValueOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    customField?: CustomFieldOrderByWithRelationInput
  }

  export type TaskCustomValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId_customFieldId?: TaskCustomValueTaskIdCustomFieldIdCompoundUniqueInput
    AND?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    OR?: TaskCustomValueWhereInput[]
    NOT?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    taskId?: IntFilter<"TaskCustomValue"> | number
    customFieldId?: IntFilter<"TaskCustomValue"> | number
    value?: StringFilter<"TaskCustomValue"> | string
    createdAt?: DateTimeFilter<"TaskCustomValue"> | Date | string
    updatedAt?: DateTimeFilter<"TaskCustomValue"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    customField?: XOR<CustomFieldScalarRelationFilter, CustomFieldWhereInput>
  }, "id" | "taskId_customFieldId">

  export type TaskCustomValueOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCustomValueCountOrderByAggregateInput
    _avg?: TaskCustomValueAvgOrderByAggregateInput
    _max?: TaskCustomValueMaxOrderByAggregateInput
    _min?: TaskCustomValueMinOrderByAggregateInput
    _sum?: TaskCustomValueSumOrderByAggregateInput
  }

  export type TaskCustomValueScalarWhereWithAggregatesInput = {
    AND?: TaskCustomValueScalarWhereWithAggregatesInput | TaskCustomValueScalarWhereWithAggregatesInput[]
    OR?: TaskCustomValueScalarWhereWithAggregatesInput[]
    NOT?: TaskCustomValueScalarWhereWithAggregatesInput | TaskCustomValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskCustomValue"> | number
    taskId?: IntWithAggregatesFilter<"TaskCustomValue"> | number
    customFieldId?: IntWithAggregatesFilter<"TaskCustomValue"> | number
    value?: StringWithAggregatesFilter<"TaskCustomValue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskCustomValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskCustomValue"> | Date | string
  }

  export type SprintWhereInput = {
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    id?: IntFilter<"Sprint"> | number
    projectId?: IntFilter<"Sprint"> | number
    name?: StringFilter<"Sprint"> | string
    description?: StringNullableFilter<"Sprint"> | string | null
    status?: EnumSprintStatusFilter<"Sprint"> | $Enums.SprintStatus
    dateStart?: DateTimeFilter<"Sprint"> | Date | string
    dateEnd?: DateTimeFilter<"Sprint"> | Date | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type SprintOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type SprintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    projectId?: IntFilter<"Sprint"> | number
    name?: StringFilter<"Sprint"> | string
    description?: StringNullableFilter<"Sprint"> | string | null
    status?: EnumSprintStatusFilter<"Sprint"> | $Enums.SprintStatus
    dateStart?: DateTimeFilter<"Sprint"> | Date | string
    dateEnd?: DateTimeFilter<"Sprint"> | Date | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type SprintOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SprintCountOrderByAggregateInput
    _avg?: SprintAvgOrderByAggregateInput
    _max?: SprintMaxOrderByAggregateInput
    _min?: SprintMinOrderByAggregateInput
    _sum?: SprintSumOrderByAggregateInput
  }

  export type SprintScalarWhereWithAggregatesInput = {
    AND?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    OR?: SprintScalarWhereWithAggregatesInput[]
    NOT?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sprint"> | number
    projectId?: IntWithAggregatesFilter<"Sprint"> | number
    name?: StringWithAggregatesFilter<"Sprint"> | string
    description?: StringNullableWithAggregatesFilter<"Sprint"> | string | null
    status?: EnumSprintStatusWithAggregatesFilter<"Sprint"> | $Enums.SprintStatus
    dateStart?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    dateEnd?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: IntFilter<"Module"> | number
    projectId?: IntFilter<"Module"> | number
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    color?: StringFilter<"Module"> | string
    position?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_name?: ModuleProjectIdNameCompoundUniqueInput
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    projectId?: IntFilter<"Module"> | number
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    color?: StringFilter<"Module"> | string
    position?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id" | "projectId_name">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Module"> | number
    projectId?: IntWithAggregatesFilter<"Module"> | number
    name?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    color?: StringWithAggregatesFilter<"Module"> | string
    position?: IntWithAggregatesFilter<"Module"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: IntFilter<"Milestone"> | number
    projectId?: IntFilter<"Milestone"> | number
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    dateDue?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    isCompleted?: BoolFilter<"Milestone"> | boolean
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dateDue?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    projectId?: IntFilter<"Milestone"> | number
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    dateDue?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    isCompleted?: BoolFilter<"Milestone"> | boolean
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dateDue?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _avg?: MilestoneAvgOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
    _sum?: MilestoneSumOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Milestone"> | number
    projectId?: IntWithAggregatesFilter<"Milestone"> | number
    name?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    dateDue?: DateTimeNullableWithAggregatesFilter<"Milestone"> | Date | string | null
    isCompleted?: BoolWithAggregatesFilter<"Milestone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type StickyNoteWhereInput = {
    AND?: StickyNoteWhereInput | StickyNoteWhereInput[]
    OR?: StickyNoteWhereInput[]
    NOT?: StickyNoteWhereInput | StickyNoteWhereInput[]
    id?: IntFilter<"StickyNote"> | number
    userId?: IntFilter<"StickyNote"> | number
    title?: StringNullableFilter<"StickyNote"> | string | null
    content?: StringFilter<"StickyNote"> | string
    color?: EnumStickyNoteColorFilter<"StickyNote"> | $Enums.StickyNoteColor
    isPinned?: BoolFilter<"StickyNote"> | boolean
    visibility?: EnumStickyVisibilityFilter<"StickyNote"> | $Enums.StickyVisibility
    createdAt?: DateTimeFilter<"StickyNote"> | Date | string
    updatedAt?: DateTimeFilter<"StickyNote"> | Date | string
    links?: StickyNoteLinkListRelationFilter
  }

  export type StickyNoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    color?: SortOrder
    isPinned?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    links?: StickyNoteLinkOrderByRelationAggregateInput
  }

  export type StickyNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StickyNoteWhereInput | StickyNoteWhereInput[]
    OR?: StickyNoteWhereInput[]
    NOT?: StickyNoteWhereInput | StickyNoteWhereInput[]
    userId?: IntFilter<"StickyNote"> | number
    title?: StringNullableFilter<"StickyNote"> | string | null
    content?: StringFilter<"StickyNote"> | string
    color?: EnumStickyNoteColorFilter<"StickyNote"> | $Enums.StickyNoteColor
    isPinned?: BoolFilter<"StickyNote"> | boolean
    visibility?: EnumStickyVisibilityFilter<"StickyNote"> | $Enums.StickyVisibility
    createdAt?: DateTimeFilter<"StickyNote"> | Date | string
    updatedAt?: DateTimeFilter<"StickyNote"> | Date | string
    links?: StickyNoteLinkListRelationFilter
  }, "id">

  export type StickyNoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    color?: SortOrder
    isPinned?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StickyNoteCountOrderByAggregateInput
    _avg?: StickyNoteAvgOrderByAggregateInput
    _max?: StickyNoteMaxOrderByAggregateInput
    _min?: StickyNoteMinOrderByAggregateInput
    _sum?: StickyNoteSumOrderByAggregateInput
  }

  export type StickyNoteScalarWhereWithAggregatesInput = {
    AND?: StickyNoteScalarWhereWithAggregatesInput | StickyNoteScalarWhereWithAggregatesInput[]
    OR?: StickyNoteScalarWhereWithAggregatesInput[]
    NOT?: StickyNoteScalarWhereWithAggregatesInput | StickyNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StickyNote"> | number
    userId?: IntWithAggregatesFilter<"StickyNote"> | number
    title?: StringNullableWithAggregatesFilter<"StickyNote"> | string | null
    content?: StringWithAggregatesFilter<"StickyNote"> | string
    color?: EnumStickyNoteColorWithAggregatesFilter<"StickyNote"> | $Enums.StickyNoteColor
    isPinned?: BoolWithAggregatesFilter<"StickyNote"> | boolean
    visibility?: EnumStickyVisibilityWithAggregatesFilter<"StickyNote"> | $Enums.StickyVisibility
    createdAt?: DateTimeWithAggregatesFilter<"StickyNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StickyNote"> | Date | string
  }

  export type StickyNoteLinkWhereInput = {
    AND?: StickyNoteLinkWhereInput | StickyNoteLinkWhereInput[]
    OR?: StickyNoteLinkWhereInput[]
    NOT?: StickyNoteLinkWhereInput | StickyNoteLinkWhereInput[]
    id?: IntFilter<"StickyNoteLink"> | number
    stickyNoteId?: IntFilter<"StickyNoteLink"> | number
    entityType?: EnumStickyLinkTypeFilter<"StickyNoteLink"> | $Enums.StickyLinkType
    entityId?: IntFilter<"StickyNoteLink"> | number
    createdAt?: DateTimeFilter<"StickyNoteLink"> | Date | string
    stickyNote?: XOR<StickyNoteScalarRelationFilter, StickyNoteWhereInput>
  }

  export type StickyNoteLinkOrderByWithRelationInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    stickyNote?: StickyNoteOrderByWithRelationInput
  }

  export type StickyNoteLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stickyNoteId_entityType_entityId?: StickyNoteLinkStickyNoteIdEntityTypeEntityIdCompoundUniqueInput
    AND?: StickyNoteLinkWhereInput | StickyNoteLinkWhereInput[]
    OR?: StickyNoteLinkWhereInput[]
    NOT?: StickyNoteLinkWhereInput | StickyNoteLinkWhereInput[]
    stickyNoteId?: IntFilter<"StickyNoteLink"> | number
    entityType?: EnumStickyLinkTypeFilter<"StickyNoteLink"> | $Enums.StickyLinkType
    entityId?: IntFilter<"StickyNoteLink"> | number
    createdAt?: DateTimeFilter<"StickyNoteLink"> | Date | string
    stickyNote?: XOR<StickyNoteScalarRelationFilter, StickyNoteWhereInput>
  }, "id" | "stickyNoteId_entityType_entityId">

  export type StickyNoteLinkOrderByWithAggregationInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    _count?: StickyNoteLinkCountOrderByAggregateInput
    _avg?: StickyNoteLinkAvgOrderByAggregateInput
    _max?: StickyNoteLinkMaxOrderByAggregateInput
    _min?: StickyNoteLinkMinOrderByAggregateInput
    _sum?: StickyNoteLinkSumOrderByAggregateInput
  }

  export type StickyNoteLinkScalarWhereWithAggregatesInput = {
    AND?: StickyNoteLinkScalarWhereWithAggregatesInput | StickyNoteLinkScalarWhereWithAggregatesInput[]
    OR?: StickyNoteLinkScalarWhereWithAggregatesInput[]
    NOT?: StickyNoteLinkScalarWhereWithAggregatesInput | StickyNoteLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StickyNoteLink"> | number
    stickyNoteId?: IntWithAggregatesFilter<"StickyNoteLink"> | number
    entityType?: EnumStickyLinkTypeWithAggregatesFilter<"StickyNoteLink"> | $Enums.StickyLinkType
    entityId?: IntWithAggregatesFilter<"StickyNoteLink"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StickyNoteLink"> | Date | string
  }

  export type ProjectGroupWhereInput = {
    AND?: ProjectGroupWhereInput | ProjectGroupWhereInput[]
    OR?: ProjectGroupWhereInput[]
    NOT?: ProjectGroupWhereInput | ProjectGroupWhereInput[]
    id?: IntFilter<"ProjectGroup"> | number
    workspaceId?: IntFilter<"ProjectGroup"> | number
    name?: StringFilter<"ProjectGroup"> | string
    description?: StringNullableFilter<"ProjectGroup"> | string | null
    color?: StringFilter<"ProjectGroup"> | string
    status?: EnumProjectGroupStatusFilter<"ProjectGroup"> | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFilter<"ProjectGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectGroup"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    projects?: ProjectGroupMemberListRelationFilter
  }

  export type ProjectGroupOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    projects?: ProjectGroupMemberOrderByRelationAggregateInput
  }

  export type ProjectGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectGroupWhereInput | ProjectGroupWhereInput[]
    OR?: ProjectGroupWhereInput[]
    NOT?: ProjectGroupWhereInput | ProjectGroupWhereInput[]
    workspaceId?: IntFilter<"ProjectGroup"> | number
    name?: StringFilter<"ProjectGroup"> | string
    description?: StringNullableFilter<"ProjectGroup"> | string | null
    color?: StringFilter<"ProjectGroup"> | string
    status?: EnumProjectGroupStatusFilter<"ProjectGroup"> | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFilter<"ProjectGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectGroup"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    projects?: ProjectGroupMemberListRelationFilter
  }, "id">

  export type ProjectGroupOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectGroupCountOrderByAggregateInput
    _avg?: ProjectGroupAvgOrderByAggregateInput
    _max?: ProjectGroupMaxOrderByAggregateInput
    _min?: ProjectGroupMinOrderByAggregateInput
    _sum?: ProjectGroupSumOrderByAggregateInput
  }

  export type ProjectGroupScalarWhereWithAggregatesInput = {
    AND?: ProjectGroupScalarWhereWithAggregatesInput | ProjectGroupScalarWhereWithAggregatesInput[]
    OR?: ProjectGroupScalarWhereWithAggregatesInput[]
    NOT?: ProjectGroupScalarWhereWithAggregatesInput | ProjectGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectGroup"> | number
    workspaceId?: IntWithAggregatesFilter<"ProjectGroup"> | number
    name?: StringWithAggregatesFilter<"ProjectGroup"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectGroup"> | string | null
    color?: StringWithAggregatesFilter<"ProjectGroup"> | string
    status?: EnumProjectGroupStatusWithAggregatesFilter<"ProjectGroup"> | $Enums.ProjectGroupStatus
    createdAt?: DateTimeWithAggregatesFilter<"ProjectGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectGroup"> | Date | string
  }

  export type ProjectGroupMemberWhereInput = {
    AND?: ProjectGroupMemberWhereInput | ProjectGroupMemberWhereInput[]
    OR?: ProjectGroupMemberWhereInput[]
    NOT?: ProjectGroupMemberWhereInput | ProjectGroupMemberWhereInput[]
    id?: IntFilter<"ProjectGroupMember"> | number
    projectGroupId?: IntFilter<"ProjectGroupMember"> | number
    projectId?: IntFilter<"ProjectGroupMember"> | number
    position?: IntFilter<"ProjectGroupMember"> | number
    createdAt?: DateTimeFilter<"ProjectGroupMember"> | Date | string
    projectGroup?: XOR<ProjectGroupScalarRelationFilter, ProjectGroupWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    projectGroup?: ProjectGroupOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectGroupId_projectId?: ProjectGroupMemberProjectGroupIdProjectIdCompoundUniqueInput
    AND?: ProjectGroupMemberWhereInput | ProjectGroupMemberWhereInput[]
    OR?: ProjectGroupMemberWhereInput[]
    NOT?: ProjectGroupMemberWhereInput | ProjectGroupMemberWhereInput[]
    projectGroupId?: IntFilter<"ProjectGroupMember"> | number
    projectId?: IntFilter<"ProjectGroupMember"> | number
    position?: IntFilter<"ProjectGroupMember"> | number
    createdAt?: DateTimeFilter<"ProjectGroupMember"> | Date | string
    projectGroup?: XOR<ProjectGroupScalarRelationFilter, ProjectGroupWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectGroupId_projectId">

  export type ProjectGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectGroupMemberCountOrderByAggregateInput
    _avg?: ProjectGroupMemberAvgOrderByAggregateInput
    _max?: ProjectGroupMemberMaxOrderByAggregateInput
    _min?: ProjectGroupMemberMinOrderByAggregateInput
    _sum?: ProjectGroupMemberSumOrderByAggregateInput
  }

  export type ProjectGroupMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectGroupMemberScalarWhereWithAggregatesInput | ProjectGroupMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectGroupMemberScalarWhereWithAggregatesInput | ProjectGroupMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectGroupMember"> | number
    projectGroupId?: IntWithAggregatesFilter<"ProjectGroupMember"> | number
    projectId?: IntWithAggregatesFilter<"ProjectGroupMember"> | number
    position?: IntWithAggregatesFilter<"ProjectGroupMember"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectGroupMember"> | Date | string
  }

  export type TaskSessionWhereInput = {
    AND?: TaskSessionWhereInput | TaskSessionWhereInput[]
    OR?: TaskSessionWhereInput[]
    NOT?: TaskSessionWhereInput | TaskSessionWhereInput[]
    id?: IntFilter<"TaskSession"> | number
    taskId?: IntFilter<"TaskSession"> | number
    sessionId?: StringFilter<"TaskSession"> | string
    linkType?: EnumTaskSessionTypeFilter<"TaskSession"> | $Enums.TaskSessionType
    notes?: StringNullableFilter<"TaskSession"> | string | null
    createdAt?: DateTimeFilter<"TaskSession"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskSessionOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    sessionId?: SortOrder
    linkType?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    taskId_sessionId_linkType?: TaskSessionTaskIdSessionIdLinkTypeCompoundUniqueInput
    AND?: TaskSessionWhereInput | TaskSessionWhereInput[]
    OR?: TaskSessionWhereInput[]
    NOT?: TaskSessionWhereInput | TaskSessionWhereInput[]
    taskId?: IntFilter<"TaskSession"> | number
    sessionId?: StringFilter<"TaskSession"> | string
    linkType?: EnumTaskSessionTypeFilter<"TaskSession"> | $Enums.TaskSessionType
    notes?: StringNullableFilter<"TaskSession"> | string | null
    createdAt?: DateTimeFilter<"TaskSession"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "taskId_sessionId_linkType">

  export type TaskSessionOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    sessionId?: SortOrder
    linkType?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskSessionCountOrderByAggregateInput
    _avg?: TaskSessionAvgOrderByAggregateInput
    _max?: TaskSessionMaxOrderByAggregateInput
    _min?: TaskSessionMinOrderByAggregateInput
    _sum?: TaskSessionSumOrderByAggregateInput
  }

  export type TaskSessionScalarWhereWithAggregatesInput = {
    AND?: TaskSessionScalarWhereWithAggregatesInput | TaskSessionScalarWhereWithAggregatesInput[]
    OR?: TaskSessionScalarWhereWithAggregatesInput[]
    NOT?: TaskSessionScalarWhereWithAggregatesInput | TaskSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskSession"> | number
    taskId?: IntWithAggregatesFilter<"TaskSession"> | number
    sessionId?: StringWithAggregatesFilter<"TaskSession"> | string
    linkType?: EnumTaskSessionTypeWithAggregatesFilter<"TaskSession"> | $Enums.TaskSessionType
    notes?: StringNullableWithAggregatesFilter<"TaskSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskSession"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: IntFilter<"Budget"> | number
    projectId?: IntFilter<"Budget"> | number
    name?: StringFilter<"Budget"> | string
    amount?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    lines?: BudgetLineListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    lines?: BudgetLineOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    projectId?: IntFilter<"Budget"> | number
    name?: StringFilter<"Budget"> | string
    amount?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    lines?: BudgetLineListRelationFilter
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Budget"> | number
    projectId?: IntWithAggregatesFilter<"Budget"> | number
    name?: StringWithAggregatesFilter<"Budget"> | string
    amount?: DecimalWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Budget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type BudgetLineWhereInput = {
    AND?: BudgetLineWhereInput | BudgetLineWhereInput[]
    OR?: BudgetLineWhereInput[]
    NOT?: BudgetLineWhereInput | BudgetLineWhereInput[]
    id?: IntFilter<"BudgetLine"> | number
    budgetId?: IntFilter<"BudgetLine"> | number
    description?: StringFilter<"BudgetLine"> | string
    amount?: DecimalFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFilter<"BudgetLine"> | $Enums.BudgetLineType
    taskId?: IntNullableFilter<"BudgetLine"> | number | null
    createdAt?: DateTimeFilter<"BudgetLine"> | Date | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
  }

  export type BudgetLineOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    lineType?: SortOrder
    taskId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    budget?: BudgetOrderByWithRelationInput
  }

  export type BudgetLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BudgetLineWhereInput | BudgetLineWhereInput[]
    OR?: BudgetLineWhereInput[]
    NOT?: BudgetLineWhereInput | BudgetLineWhereInput[]
    budgetId?: IntFilter<"BudgetLine"> | number
    description?: StringFilter<"BudgetLine"> | string
    amount?: DecimalFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFilter<"BudgetLine"> | $Enums.BudgetLineType
    taskId?: IntNullableFilter<"BudgetLine"> | number | null
    createdAt?: DateTimeFilter<"BudgetLine"> | Date | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
  }, "id">

  export type BudgetLineOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    lineType?: SortOrder
    taskId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BudgetLineCountOrderByAggregateInput
    _avg?: BudgetLineAvgOrderByAggregateInput
    _max?: BudgetLineMaxOrderByAggregateInput
    _min?: BudgetLineMinOrderByAggregateInput
    _sum?: BudgetLineSumOrderByAggregateInput
  }

  export type BudgetLineScalarWhereWithAggregatesInput = {
    AND?: BudgetLineScalarWhereWithAggregatesInput | BudgetLineScalarWhereWithAggregatesInput[]
    OR?: BudgetLineScalarWhereWithAggregatesInput[]
    NOT?: BudgetLineScalarWhereWithAggregatesInput | BudgetLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BudgetLine"> | number
    budgetId?: IntWithAggregatesFilter<"BudgetLine"> | number
    description?: StringWithAggregatesFilter<"BudgetLine"> | string
    amount?: DecimalWithAggregatesFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeWithAggregatesFilter<"BudgetLine"> | $Enums.BudgetLineType
    taskId?: IntNullableWithAggregatesFilter<"BudgetLine"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BudgetLine"> | Date | string
  }

  export type WikiPageWhereInput = {
    AND?: WikiPageWhereInput | WikiPageWhereInput[]
    OR?: WikiPageWhereInput[]
    NOT?: WikiPageWhereInput | WikiPageWhereInput[]
    id?: IntFilter<"WikiPage"> | number
    projectId?: IntFilter<"WikiPage"> | number
    title?: StringFilter<"WikiPage"> | string
    content?: StringFilter<"WikiPage"> | string
    creatorId?: IntNullableFilter<"WikiPage"> | number | null
    modifierId?: IntNullableFilter<"WikiPage"> | number | null
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type WikiPageOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    modifierId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type WikiPageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WikiPageWhereInput | WikiPageWhereInput[]
    OR?: WikiPageWhereInput[]
    NOT?: WikiPageWhereInput | WikiPageWhereInput[]
    projectId?: IntFilter<"WikiPage"> | number
    title?: StringFilter<"WikiPage"> | string
    content?: StringFilter<"WikiPage"> | string
    creatorId?: IntNullableFilter<"WikiPage"> | number | null
    modifierId?: IntNullableFilter<"WikiPage"> | number | null
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type WikiPageOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    modifierId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WikiPageCountOrderByAggregateInput
    _avg?: WikiPageAvgOrderByAggregateInput
    _max?: WikiPageMaxOrderByAggregateInput
    _min?: WikiPageMinOrderByAggregateInput
    _sum?: WikiPageSumOrderByAggregateInput
  }

  export type WikiPageScalarWhereWithAggregatesInput = {
    AND?: WikiPageScalarWhereWithAggregatesInput | WikiPageScalarWhereWithAggregatesInput[]
    OR?: WikiPageScalarWhereWithAggregatesInput[]
    NOT?: WikiPageScalarWhereWithAggregatesInput | WikiPageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WikiPage"> | number
    projectId?: IntWithAggregatesFilter<"WikiPage"> | number
    title?: StringWithAggregatesFilter<"WikiPage"> | string
    content?: StringWithAggregatesFilter<"WikiPage"> | string
    creatorId?: IntNullableWithAggregatesFilter<"WikiPage"> | number | null
    modifierId?: IntNullableWithAggregatesFilter<"WikiPage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WikiPage"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    userId?: IntFilter<"ApiKey"> | number
    name?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    permissions?: JsonFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    keyPrefix?: SortOrder
    keyHash?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: IntFilter<"ApiKey"> | number
    name?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    permissions?: JsonFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    keyPrefix?: SortOrder
    keyHash?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiKey"> | number
    userId?: IntWithAggregatesFilter<"ApiKey"> | number
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    keyPrefix?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    permissions?: JsonWithAggregatesFilter<"ApiKey">
    rateLimit?: IntWithAggregatesFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: IntFilter<"Webhook"> | number
    projectId?: IntFilter<"Webhook"> | number
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: JsonFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    failureCount?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    lastSuccess?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    projectId?: IntFilter<"Webhook"> | number
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: JsonFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    failureCount?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    lastSuccess?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Webhook"> | number
    projectId?: IntWithAggregatesFilter<"Webhook"> | number
    name?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    events?: JsonWithAggregatesFilter<"Webhook">
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    lastSuccess?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    failureCount?: IntWithAggregatesFilter<"Webhook"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: IntFilter<"WebhookDelivery"> | number
    webhookId?: IntFilter<"WebhookDelivery"> | number
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    duration?: IntNullableFilter<"WebhookDelivery"> | number | null
    success?: BoolFilter<"WebhookDelivery"> | boolean
    attempts?: IntFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    success?: SortOrder
    attempts?: SortOrder
    deliveredAt?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    webhookId?: IntFilter<"WebhookDelivery"> | number
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    duration?: IntNullableFilter<"WebhookDelivery"> | number | null
    success?: BoolFilter<"WebhookDelivery"> | boolean
    attempts?: IntFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    success?: SortOrder
    attempts?: SortOrder
    deliveredAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    webhookId?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    event?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    statusCode?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    response?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    duration?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    success?: BoolWithAggregatesFilter<"WebhookDelivery"> | boolean
    attempts?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringNullableFilter<"Notification"> | string | null
    data?: JsonFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    data?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringNullableFilter<"Notification"> | string | null
    data?: JsonFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    data?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    data?: JsonWithAggregatesFilter<"Notification">
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: IntFilter<"Activity"> | number
    projectId?: IntFilter<"Activity"> | number
    userId?: IntNullableFilter<"Activity"> | number | null
    eventType?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: IntFilter<"Activity"> | number
    changes?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    projectId?: IntFilter<"Activity"> | number
    userId?: IntNullableFilter<"Activity"> | number | null
    eventType?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: IntFilter<"Activity"> | number
    changes?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Activity"> | number
    projectId?: IntWithAggregatesFilter<"Activity"> | number
    userId?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    eventType?: StringWithAggregatesFilter<"Activity"> | string
    entityType?: StringWithAggregatesFilter<"Activity"> | string
    entityId?: IntWithAggregatesFilter<"Activity"> | number
    changes?: JsonWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    userId?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    ip?: StringFilter<"PasswordReset"> | string
    userAgent?: StringFilter<"PasswordReset"> | string
    isUsed?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    userId?: IntFilter<"PasswordReset"> | number
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    ip?: StringFilter<"PasswordReset"> | string
    userAgent?: StringFilter<"PasswordReset"> | string
    isUsed?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _avg?: PasswordResetAvgOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
    _sum?: PasswordResetSumOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordReset"> | number
    userId?: IntWithAggregatesFilter<"PasswordReset"> | number
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    ip?: StringWithAggregatesFilter<"PasswordReset"> | string
    userAgent?: StringWithAggregatesFilter<"PasswordReset"> | string
    isUsed?: BoolWithAggregatesFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type LastLoginWhereInput = {
    AND?: LastLoginWhereInput | LastLoginWhereInput[]
    OR?: LastLoginWhereInput[]
    NOT?: LastLoginWhereInput | LastLoginWhereInput[]
    id?: IntFilter<"LastLogin"> | number
    userId?: IntFilter<"LastLogin"> | number
    authType?: StringFilter<"LastLogin"> | string
    ip?: StringFilter<"LastLogin"> | string
    userAgent?: StringFilter<"LastLogin"> | string
    createdAt?: DateTimeFilter<"LastLogin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LastLoginOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    authType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LastLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LastLoginWhereInput | LastLoginWhereInput[]
    OR?: LastLoginWhereInput[]
    NOT?: LastLoginWhereInput | LastLoginWhereInput[]
    userId?: IntFilter<"LastLogin"> | number
    authType?: StringFilter<"LastLogin"> | string
    ip?: StringFilter<"LastLogin"> | string
    userAgent?: StringFilter<"LastLogin"> | string
    createdAt?: DateTimeFilter<"LastLogin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LastLoginOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    authType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    _count?: LastLoginCountOrderByAggregateInput
    _avg?: LastLoginAvgOrderByAggregateInput
    _max?: LastLoginMaxOrderByAggregateInput
    _min?: LastLoginMinOrderByAggregateInput
    _sum?: LastLoginSumOrderByAggregateInput
  }

  export type LastLoginScalarWhereWithAggregatesInput = {
    AND?: LastLoginScalarWhereWithAggregatesInput | LastLoginScalarWhereWithAggregatesInput[]
    OR?: LastLoginScalarWhereWithAggregatesInput[]
    NOT?: LastLoginScalarWhereWithAggregatesInput | LastLoginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LastLogin"> | number
    userId?: IntWithAggregatesFilter<"LastLogin"> | number
    authType?: StringWithAggregatesFilter<"LastLogin"> | string
    ip?: StringWithAggregatesFilter<"LastLogin"> | string
    userAgent?: StringWithAggregatesFilter<"LastLogin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LastLogin"> | Date | string
  }

  export type UserMetadataWhereInput = {
    AND?: UserMetadataWhereInput | UserMetadataWhereInput[]
    OR?: UserMetadataWhereInput[]
    NOT?: UserMetadataWhereInput | UserMetadataWhereInput[]
    id?: IntFilter<"UserMetadata"> | number
    userId?: IntFilter<"UserMetadata"> | number
    key?: StringFilter<"UserMetadata"> | string
    value?: StringFilter<"UserMetadata"> | string
    createdAt?: DateTimeFilter<"UserMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"UserMetadata"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserMetadataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_key?: UserMetadataUserIdKeyCompoundUniqueInput
    AND?: UserMetadataWhereInput | UserMetadataWhereInput[]
    OR?: UserMetadataWhereInput[]
    NOT?: UserMetadataWhereInput | UserMetadataWhereInput[]
    userId?: IntFilter<"UserMetadata"> | number
    key?: StringFilter<"UserMetadata"> | string
    value?: StringFilter<"UserMetadata"> | string
    createdAt?: DateTimeFilter<"UserMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"UserMetadata"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_key">

  export type UserMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserMetadataCountOrderByAggregateInput
    _avg?: UserMetadataAvgOrderByAggregateInput
    _max?: UserMetadataMaxOrderByAggregateInput
    _min?: UserMetadataMinOrderByAggregateInput
    _sum?: UserMetadataSumOrderByAggregateInput
  }

  export type UserMetadataScalarWhereWithAggregatesInput = {
    AND?: UserMetadataScalarWhereWithAggregatesInput | UserMetadataScalarWhereWithAggregatesInput[]
    OR?: UserMetadataScalarWhereWithAggregatesInput[]
    NOT?: UserMetadataScalarWhereWithAggregatesInput | UserMetadataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserMetadata"> | number
    userId?: IntWithAggregatesFilter<"UserMetadata"> | number
    key?: StringWithAggregatesFilter<"UserMetadata"> | string
    value?: StringWithAggregatesFilter<"UserMetadata"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserMetadata"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserMetadata"> | Date | string
  }

  export type UserNotificationSettingWhereInput = {
    AND?: UserNotificationSettingWhereInput | UserNotificationSettingWhereInput[]
    OR?: UserNotificationSettingWhereInput[]
    NOT?: UserNotificationSettingWhereInput | UserNotificationSettingWhereInput[]
    id?: IntFilter<"UserNotificationSetting"> | number
    userId?: IntFilter<"UserNotificationSetting"> | number
    notificationType?: StringFilter<"UserNotificationSetting"> | string
    isEnabled?: BoolFilter<"UserNotificationSetting"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserNotificationSettingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    isEnabled?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserNotificationSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_notificationType?: UserNotificationSettingUserIdNotificationTypeCompoundUniqueInput
    AND?: UserNotificationSettingWhereInput | UserNotificationSettingWhereInput[]
    OR?: UserNotificationSettingWhereInput[]
    NOT?: UserNotificationSettingWhereInput | UserNotificationSettingWhereInput[]
    userId?: IntFilter<"UserNotificationSetting"> | number
    notificationType?: StringFilter<"UserNotificationSetting"> | string
    isEnabled?: BoolFilter<"UserNotificationSetting"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_notificationType">

  export type UserNotificationSettingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    isEnabled?: SortOrder
    _count?: UserNotificationSettingCountOrderByAggregateInput
    _avg?: UserNotificationSettingAvgOrderByAggregateInput
    _max?: UserNotificationSettingMaxOrderByAggregateInput
    _min?: UserNotificationSettingMinOrderByAggregateInput
    _sum?: UserNotificationSettingSumOrderByAggregateInput
  }

  export type UserNotificationSettingScalarWhereWithAggregatesInput = {
    AND?: UserNotificationSettingScalarWhereWithAggregatesInput | UserNotificationSettingScalarWhereWithAggregatesInput[]
    OR?: UserNotificationSettingScalarWhereWithAggregatesInput[]
    NOT?: UserNotificationSettingScalarWhereWithAggregatesInput | UserNotificationSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserNotificationSetting"> | number
    userId?: IntWithAggregatesFilter<"UserNotificationSetting"> | number
    notificationType?: StringWithAggregatesFilter<"UserNotificationSetting"> | string
    isEnabled?: BoolWithAggregatesFilter<"UserNotificationSetting"> | boolean
  }

  export type UserAvatarWhereInput = {
    AND?: UserAvatarWhereInput | UserAvatarWhereInput[]
    OR?: UserAvatarWhereInput[]
    NOT?: UserAvatarWhereInput | UserAvatarWhereInput[]
    id?: IntFilter<"UserAvatar"> | number
    userId?: IntFilter<"UserAvatar"> | number
    data?: BytesFilter<"UserAvatar"> | Bytes
    mimeType?: StringFilter<"UserAvatar"> | string
    size?: IntFilter<"UserAvatar"> | number
    createdAt?: DateTimeFilter<"UserAvatar"> | Date | string
    updatedAt?: DateTimeFilter<"UserAvatar"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAvatarOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAvatarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserAvatarWhereInput | UserAvatarWhereInput[]
    OR?: UserAvatarWhereInput[]
    NOT?: UserAvatarWhereInput | UserAvatarWhereInput[]
    data?: BytesFilter<"UserAvatar"> | Bytes
    mimeType?: StringFilter<"UserAvatar"> | string
    size?: IntFilter<"UserAvatar"> | number
    createdAt?: DateTimeFilter<"UserAvatar"> | Date | string
    updatedAt?: DateTimeFilter<"UserAvatar"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserAvatarOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAvatarCountOrderByAggregateInput
    _avg?: UserAvatarAvgOrderByAggregateInput
    _max?: UserAvatarMaxOrderByAggregateInput
    _min?: UserAvatarMinOrderByAggregateInput
    _sum?: UserAvatarSumOrderByAggregateInput
  }

  export type UserAvatarScalarWhereWithAggregatesInput = {
    AND?: UserAvatarScalarWhereWithAggregatesInput | UserAvatarScalarWhereWithAggregatesInput[]
    OR?: UserAvatarScalarWhereWithAggregatesInput[]
    NOT?: UserAvatarScalarWhereWithAggregatesInput | UserAvatarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAvatar"> | number
    userId?: IntWithAggregatesFilter<"UserAvatar"> | number
    data?: BytesWithAggregatesFilter<"UserAvatar"> | Bytes
    mimeType?: StringWithAggregatesFilter<"UserAvatar"> | string
    size?: IntWithAggregatesFilter<"UserAvatar"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAvatar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAvatar"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter<"Group"> | number
    objectGuid?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    displayName?: StringFilter<"Group"> | string
    distinguishedName?: StringNullableFilter<"Group"> | string | null
    description?: StringNullableFilter<"Group"> | string | null
    type?: EnumGroupTypeFilter<"Group"> | $Enums.GroupType
    scope?: EnumGroupScopeFilter<"Group"> | $Enums.GroupScope
    workspaceId?: IntNullableFilter<"Group"> | number | null
    projectId?: IntNullableFilter<"Group"> | number | null
    parentGroupId?: IntNullableFilter<"Group"> | number | null
    externalId?: StringNullableFilter<"Group"> | string | null
    source?: EnumGroupSourceFilter<"Group"> | $Enums.GroupSource
    isSystem?: BoolFilter<"Group"> | boolean
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    isSecurityGroup?: BoolFilter<"Group"> | boolean
    parentGroup?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
    childGroups?: GroupListRelationFilter
    workspace?: XOR<WorkspaceNullableScalarRelationFilter, WorkspaceWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    members?: GroupMemberListRelationFilter
    permissions?: GroupPermissionListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    objectGuid?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    distinguishedName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    scope?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    parentGroupId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    source?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSecurityGroup?: SortOrder
    parentGroup?: GroupOrderByWithRelationInput
    childGroups?: GroupOrderByRelationAggregateInput
    workspace?: WorkspaceOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    members?: GroupMemberOrderByRelationAggregateInput
    permissions?: GroupPermissionOrderByRelationAggregateInput
    roleAssignments?: RoleAssignmentOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    objectGuid?: string
    name?: string
    distinguishedName?: string
    externalId?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    displayName?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    type?: EnumGroupTypeFilter<"Group"> | $Enums.GroupType
    scope?: EnumGroupScopeFilter<"Group"> | $Enums.GroupScope
    workspaceId?: IntNullableFilter<"Group"> | number | null
    projectId?: IntNullableFilter<"Group"> | number | null
    parentGroupId?: IntNullableFilter<"Group"> | number | null
    source?: EnumGroupSourceFilter<"Group"> | $Enums.GroupSource
    isSystem?: BoolFilter<"Group"> | boolean
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    isSecurityGroup?: BoolFilter<"Group"> | boolean
    parentGroup?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
    childGroups?: GroupListRelationFilter
    workspace?: XOR<WorkspaceNullableScalarRelationFilter, WorkspaceWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    members?: GroupMemberListRelationFilter
    permissions?: GroupPermissionListRelationFilter
    roleAssignments?: RoleAssignmentListRelationFilter
  }, "id" | "objectGuid" | "name" | "distinguishedName" | "externalId">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    objectGuid?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    distinguishedName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    scope?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    parentGroupId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    source?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSecurityGroup?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Group"> | number
    objectGuid?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    displayName?: StringWithAggregatesFilter<"Group"> | string
    distinguishedName?: StringNullableWithAggregatesFilter<"Group"> | string | null
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    type?: EnumGroupTypeWithAggregatesFilter<"Group"> | $Enums.GroupType
    scope?: EnumGroupScopeWithAggregatesFilter<"Group"> | $Enums.GroupScope
    workspaceId?: IntNullableWithAggregatesFilter<"Group"> | number | null
    projectId?: IntNullableWithAggregatesFilter<"Group"> | number | null
    parentGroupId?: IntNullableWithAggregatesFilter<"Group"> | number | null
    externalId?: StringNullableWithAggregatesFilter<"Group"> | string | null
    source?: EnumGroupSourceWithAggregatesFilter<"Group"> | $Enums.GroupSource
    isSystem?: BoolWithAggregatesFilter<"Group"> | boolean
    isActive?: BoolWithAggregatesFilter<"Group"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    isSecurityGroup?: BoolWithAggregatesFilter<"Group"> | boolean
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: IntFilter<"GroupMember"> | number
    groupId?: IntFilter<"GroupMember"> | number
    userId?: IntFilter<"GroupMember"> | number
    memberType?: EnumMemberTypeFilter<"GroupMember"> | $Enums.MemberType
    expiresAt?: DateTimeNullableFilter<"GroupMember"> | Date | string | null
    addedAt?: DateTimeFilter<"GroupMember"> | Date | string
    addedById?: IntNullableFilter<"GroupMember"> | number | null
    externalSync?: BoolFilter<"GroupMember"> | boolean
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    addedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    memberType?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    addedById?: SortOrderInput | SortOrder
    externalSync?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    addedBy?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    groupId_userId?: GroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    groupId?: IntFilter<"GroupMember"> | number
    userId?: IntFilter<"GroupMember"> | number
    memberType?: EnumMemberTypeFilter<"GroupMember"> | $Enums.MemberType
    expiresAt?: DateTimeNullableFilter<"GroupMember"> | Date | string | null
    addedAt?: DateTimeFilter<"GroupMember"> | Date | string
    addedById?: IntNullableFilter<"GroupMember"> | number | null
    externalSync?: BoolFilter<"GroupMember"> | boolean
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    addedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "groupId_userId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    memberType?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    addedById?: SortOrderInput | SortOrder
    externalSync?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _avg?: GroupMemberAvgOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
    _sum?: GroupMemberSumOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupMember"> | number
    groupId?: IntWithAggregatesFilter<"GroupMember"> | number
    userId?: IntWithAggregatesFilter<"GroupMember"> | number
    memberType?: EnumMemberTypeWithAggregatesFilter<"GroupMember"> | $Enums.MemberType
    expiresAt?: DateTimeNullableWithAggregatesFilter<"GroupMember"> | Date | string | null
    addedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
    addedById?: IntNullableWithAggregatesFilter<"GroupMember"> | number | null
    externalSync?: BoolWithAggregatesFilter<"GroupMember"> | boolean
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    displayName?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    parentId?: IntNullableFilter<"Permission"> | number | null
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    parent?: XOR<PermissionNullableScalarRelationFilter, PermissionWhereInput> | null
    children?: PermissionListRelationFilter
    groupPermissions?: GroupPermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    parent?: PermissionOrderByWithRelationInput
    children?: PermissionOrderByRelationAggregateInput
    groupPermissions?: GroupPermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    displayName?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    parentId?: IntNullableFilter<"Permission"> | number | null
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    parent?: XOR<PermissionNullableScalarRelationFilter, PermissionWhereInput> | null
    children?: PermissionListRelationFilter
    groupPermissions?: GroupPermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    name?: StringWithAggregatesFilter<"Permission"> | string
    displayName?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    category?: StringWithAggregatesFilter<"Permission"> | string
    parentId?: IntNullableWithAggregatesFilter<"Permission"> | number | null
    sortOrder?: IntWithAggregatesFilter<"Permission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type GroupPermissionWhereInput = {
    AND?: GroupPermissionWhereInput | GroupPermissionWhereInput[]
    OR?: GroupPermissionWhereInput[]
    NOT?: GroupPermissionWhereInput | GroupPermissionWhereInput[]
    id?: IntFilter<"GroupPermission"> | number
    groupId?: IntFilter<"GroupPermission"> | number
    permissionId?: IntFilter<"GroupPermission"> | number
    accessType?: EnumAccessTypeFilter<"GroupPermission"> | $Enums.AccessType
    workspaceId?: IntNullableFilter<"GroupPermission"> | number | null
    projectId?: IntNullableFilter<"GroupPermission"> | number | null
    inherited?: BoolFilter<"GroupPermission"> | boolean
    createdAt?: DateTimeFilter<"GroupPermission"> | Date | string
    createdById?: IntNullableFilter<"GroupPermission"> | number | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type GroupPermissionOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    accessType?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    inherited?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    group?: GroupOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type GroupPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    groupId_permissionId_workspaceId_projectId?: GroupPermissionGroupIdPermissionIdWorkspaceIdProjectIdCompoundUniqueInput
    AND?: GroupPermissionWhereInput | GroupPermissionWhereInput[]
    OR?: GroupPermissionWhereInput[]
    NOT?: GroupPermissionWhereInput | GroupPermissionWhereInput[]
    groupId?: IntFilter<"GroupPermission"> | number
    permissionId?: IntFilter<"GroupPermission"> | number
    accessType?: EnumAccessTypeFilter<"GroupPermission"> | $Enums.AccessType
    workspaceId?: IntNullableFilter<"GroupPermission"> | number | null
    projectId?: IntNullableFilter<"GroupPermission"> | number | null
    inherited?: BoolFilter<"GroupPermission"> | boolean
    createdAt?: DateTimeFilter<"GroupPermission"> | Date | string
    createdById?: IntNullableFilter<"GroupPermission"> | number | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "groupId_permissionId_workspaceId_projectId">

  export type GroupPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    accessType?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    inherited?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: GroupPermissionCountOrderByAggregateInput
    _avg?: GroupPermissionAvgOrderByAggregateInput
    _max?: GroupPermissionMaxOrderByAggregateInput
    _min?: GroupPermissionMinOrderByAggregateInput
    _sum?: GroupPermissionSumOrderByAggregateInput
  }

  export type GroupPermissionScalarWhereWithAggregatesInput = {
    AND?: GroupPermissionScalarWhereWithAggregatesInput | GroupPermissionScalarWhereWithAggregatesInput[]
    OR?: GroupPermissionScalarWhereWithAggregatesInput[]
    NOT?: GroupPermissionScalarWhereWithAggregatesInput | GroupPermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupPermission"> | number
    groupId?: IntWithAggregatesFilter<"GroupPermission"> | number
    permissionId?: IntWithAggregatesFilter<"GroupPermission"> | number
    accessType?: EnumAccessTypeWithAggregatesFilter<"GroupPermission"> | $Enums.AccessType
    workspaceId?: IntNullableWithAggregatesFilter<"GroupPermission"> | number | null
    projectId?: IntNullableWithAggregatesFilter<"GroupPermission"> | number | null
    inherited?: BoolWithAggregatesFilter<"GroupPermission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GroupPermission"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"GroupPermission"> | number | null
  }

  export type RoleAssignmentWhereInput = {
    AND?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    OR?: RoleAssignmentWhereInput[]
    NOT?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    id?: IntFilter<"RoleAssignment"> | number
    groupId?: IntFilter<"RoleAssignment"> | number
    workspaceId?: IntNullableFilter<"RoleAssignment"> | number | null
    projectId?: IntNullableFilter<"RoleAssignment"> | number | null
    role?: EnumAssignmentRoleFilter<"RoleAssignment"> | $Enums.AssignmentRole
    inheritToChildren?: BoolFilter<"RoleAssignment"> | boolean
    createdAt?: DateTimeFilter<"RoleAssignment"> | Date | string
    createdById?: IntNullableFilter<"RoleAssignment"> | number | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    workspace?: XOR<WorkspaceNullableScalarRelationFilter, WorkspaceWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type RoleAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    role?: SortOrder
    inheritToChildren?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    group?: GroupOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type RoleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    groupId_workspaceId_projectId?: RoleAssignmentGroupIdWorkspaceIdProjectIdCompoundUniqueInput
    AND?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    OR?: RoleAssignmentWhereInput[]
    NOT?: RoleAssignmentWhereInput | RoleAssignmentWhereInput[]
    groupId?: IntFilter<"RoleAssignment"> | number
    workspaceId?: IntNullableFilter<"RoleAssignment"> | number | null
    projectId?: IntNullableFilter<"RoleAssignment"> | number | null
    role?: EnumAssignmentRoleFilter<"RoleAssignment"> | $Enums.AssignmentRole
    inheritToChildren?: BoolFilter<"RoleAssignment"> | boolean
    createdAt?: DateTimeFilter<"RoleAssignment"> | Date | string
    createdById?: IntNullableFilter<"RoleAssignment"> | number | null
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    workspace?: XOR<WorkspaceNullableScalarRelationFilter, WorkspaceWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "groupId_workspaceId_projectId">

  export type RoleAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    role?: SortOrder
    inheritToChildren?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: RoleAssignmentCountOrderByAggregateInput
    _avg?: RoleAssignmentAvgOrderByAggregateInput
    _max?: RoleAssignmentMaxOrderByAggregateInput
    _min?: RoleAssignmentMinOrderByAggregateInput
    _sum?: RoleAssignmentSumOrderByAggregateInput
  }

  export type RoleAssignmentScalarWhereWithAggregatesInput = {
    AND?: RoleAssignmentScalarWhereWithAggregatesInput | RoleAssignmentScalarWhereWithAggregatesInput[]
    OR?: RoleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: RoleAssignmentScalarWhereWithAggregatesInput | RoleAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleAssignment"> | number
    groupId?: IntWithAggregatesFilter<"RoleAssignment"> | number
    workspaceId?: IntNullableWithAggregatesFilter<"RoleAssignment"> | number | null
    projectId?: IntNullableWithAggregatesFilter<"RoleAssignment"> | number | null
    role?: EnumAssignmentRoleWithAggregatesFilter<"RoleAssignment"> | $Enums.AssignmentRole
    inheritToChildren?: BoolWithAggregatesFilter<"RoleAssignment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoleAssignment"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"RoleAssignment"> | number | null
  }

  export type WorkspaceCreateInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceLogoCreateInput = {
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLogoInput
  }

  export type WorkspaceLogoUncheckedCreateInput = {
    id?: number
    workspaceId: number
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceLogoUpdateInput = {
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLogoNestedInput
  }

  export type WorkspaceLogoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceLogoCreateManyInput = {
    id?: number
    workspaceId: number
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceLogoUpdateManyMutationInput = {
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceLogoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserCreateInput = {
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateInput = {
    id?: number
    workspaceId: number
    userId: number
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
  }

  export type WorkspaceUserUpdateInput = {
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserCreateManyInput = {
    id?: number
    workspaceId: number
    userId: number
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
  }

  export type WorkspaceUserUpdateManyMutationInput = {
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInvitationCreateInput = {
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
    creator: UserCreateNestedOneWithoutInvitationsCreatedInput
  }

  export type WorkspaceInvitationUncheckedCreateInput = {
    id?: number
    workspaceId: number
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    createdBy: number
  }

  export type WorkspaceInvitationUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
    creator?: UserUpdateOneRequiredWithoutInvitationsCreatedNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type WorkspaceInvitationCreateManyInput = {
    id?: number
    workspaceId: number
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    createdBy: number
  }

  export type WorkspaceInvitationUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInvitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateInput = {
    id: string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    userId: number
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id: string
    userId: number
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RememberTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRememberTokensInput
  }

  export type RememberTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RememberTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRememberTokensNestedInput
  }

  export type RememberTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RememberTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RememberTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RememberTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateInput = {
    email: string
    token: string
    role?: $Enums.AppRole
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    invitedBy: UserCreateNestedOneWithoutInvitesSentInput
  }

  export type InviteUncheckedCreateInput = {
    id?: number
    email: string
    token: string
    role?: $Enums.AppRole
    invitedById: number
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InviteUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: UserUpdateOneRequiredWithoutInvitesSentNestedInput
  }

  export type InviteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    invitedById?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateManyInput = {
    id?: number
    email: string
    token: string
    role?: $Enums.AppRole
    invitedById: number
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InviteUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    invitedById?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    key: string
    value?: string | null
    changedBy?: number | null
    changedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    key: string
    value?: string | null
    changedBy?: number | null
    changedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    key: string
    value?: string | null
    changedBy?: number | null
    changedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableIntFieldUpdateOperationsInput | number | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnCreateInput = {
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutColumnsInput
    tasks?: TaskCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateInput = {
    id?: number
    projectId: number
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutColumnsNestedInput
    tasks?: TaskUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ColumnCreateManyInput = {
    id?: number
    projectId: number
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColumnUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwimlaneCreateInput = {
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSwimlanesInput
    tasks?: TaskCreateNestedManyWithoutSwimlaneInput
  }

  export type SwimlaneUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSwimlaneInput
  }

  export type SwimlaneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSwimlanesNestedInput
    tasks?: TaskUpdateManyWithoutSwimlaneNestedInput
  }

  export type SwimlaneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSwimlaneNestedInput
  }

  export type SwimlaneCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwimlaneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwimlaneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskAssigneeCreateInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAssigneesInput
    user: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TaskAssigneeUncheckedCreateInput = {
    id?: number
    taskId: number
    userId: number
    createdAt?: Date | string
  }

  export type TaskAssigneeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput
    user?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
  }

  export type TaskAssigneeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeCreateManyInput = {
    id?: number
    taskId: number
    userId: number
    createdAt?: Date | string
  }

  export type TaskAssigneeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskCreateInput = {
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutSubtasksInput
    assignee?: UserCreateNestedOneWithoutSubtasksAssignedInput
  }

  export type SubtaskUncheckedCreateInput = {
    id?: number
    taskId: number
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    assigneeId?: number | null
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    assignee?: UserUpdateOneWithoutSubtasksAssignedNestedInput
  }

  export type SubtaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    assigneeId?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskCreateManyInput = {
    id?: number
    taskId: number
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    assigneeId?: number | null
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    assigneeId?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    taskId: number
    userId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: number
    taskId: number
    userId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    name: string
    color?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutTagsInput
    tasks?: TaskTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    color?: string
    createdAt?: Date | string
    tasks?: TaskTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTagsNestedInput
    tasks?: TaskTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    projectId: number
    name: string
    color?: string
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagCreateInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutTasksInput
  }

  export type TaskTagUncheckedCreateInput = {
    id?: number
    taskId: number
    tagId: number
    createdAt?: Date | string
  }

  export type TaskTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagCreateManyInput = {
    id?: number
    taskId: number
    tagId: number
    createdAt?: Date | string
  }

  export type TaskTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutCategoriesInput
    tasks?: TaskCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCategoriesNestedInput
    tasks?: TaskUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAttachmentsInput
    user: UserCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: number
    taskId: number
    userId: number
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
    user?: UserUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: number
    taskId: number
    userId: number
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkCreateInput = {
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutLinksFromInput
    oppositeTask: TaskCreateNestedOneWithoutLinksToInput
  }

  export type TaskLinkUncheckedCreateInput = {
    id?: number
    taskId: number
    oppositeTaskId: number
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
  }

  export type TaskLinkUpdateInput = {
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLinksFromNestedInput
    oppositeTask?: TaskUpdateOneRequiredWithoutLinksToNestedInput
  }

  export type TaskLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    oppositeTaskId?: IntFieldUpdateOperationsInput | number
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkCreateManyInput = {
    id?: number
    taskId: number
    oppositeTaskId: number
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
  }

  export type TaskLinkUpdateManyMutationInput = {
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    oppositeTaskId?: IntFieldUpdateOperationsInput | number
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldCreateInput = {
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutCustomFieldsInput
    values?: TaskCustomValueCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
    values?: TaskCustomValueUncheckedCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCustomFieldsNestedInput
    values?: TaskCustomValueUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: TaskCustomValueUncheckedUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldCreateManyInput = {
    id?: number
    projectId: number
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
  }

  export type CustomFieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueCreateInput = {
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCustomValuesInput
    customField: CustomFieldCreateNestedOneWithoutValuesInput
  }

  export type TaskCustomValueUncheckedCreateInput = {
    id?: number
    taskId: number
    customFieldId: number
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCustomValueUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCustomValuesNestedInput
    customField?: CustomFieldUpdateOneRequiredWithoutValuesNestedInput
  }

  export type TaskCustomValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    customFieldId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueCreateManyInput = {
    id?: number
    taskId: number
    customFieldId: number
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCustomValueUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    customFieldId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintCreateInput = {
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    tasks?: TaskCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    tasks?: TaskUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutModulesInput
    tasks?: TaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutModulesNestedInput
    tasks?: TaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
    tasks?: TaskCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
    tasks?: TaskUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteCreateInput = {
    userId: number
    title?: string | null
    content: string
    color?: $Enums.StickyNoteColor
    isPinned?: boolean
    visibility?: $Enums.StickyVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: StickyNoteLinkCreateNestedManyWithoutStickyNoteInput
  }

  export type StickyNoteUncheckedCreateInput = {
    id?: number
    userId: number
    title?: string | null
    content: string
    color?: $Enums.StickyNoteColor
    isPinned?: boolean
    visibility?: $Enums.StickyVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: StickyNoteLinkUncheckedCreateNestedManyWithoutStickyNoteInput
  }

  export type StickyNoteUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    color?: EnumStickyNoteColorFieldUpdateOperationsInput | $Enums.StickyNoteColor
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumStickyVisibilityFieldUpdateOperationsInput | $Enums.StickyVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: StickyNoteLinkUpdateManyWithoutStickyNoteNestedInput
  }

  export type StickyNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    color?: EnumStickyNoteColorFieldUpdateOperationsInput | $Enums.StickyNoteColor
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumStickyVisibilityFieldUpdateOperationsInput | $Enums.StickyVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: StickyNoteLinkUncheckedUpdateManyWithoutStickyNoteNestedInput
  }

  export type StickyNoteCreateManyInput = {
    id?: number
    userId: number
    title?: string | null
    content: string
    color?: $Enums.StickyNoteColor
    isPinned?: boolean
    visibility?: $Enums.StickyVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StickyNoteUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    color?: EnumStickyNoteColorFieldUpdateOperationsInput | $Enums.StickyNoteColor
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumStickyVisibilityFieldUpdateOperationsInput | $Enums.StickyVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    color?: EnumStickyNoteColorFieldUpdateOperationsInput | $Enums.StickyNoteColor
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumStickyVisibilityFieldUpdateOperationsInput | $Enums.StickyVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteLinkCreateInput = {
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt?: Date | string
    stickyNote: StickyNoteCreateNestedOneWithoutLinksInput
  }

  export type StickyNoteLinkUncheckedCreateInput = {
    id?: number
    stickyNoteId: number
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt?: Date | string
  }

  export type StickyNoteLinkUpdateInput = {
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickyNote?: StickyNoteUpdateOneRequiredWithoutLinksNestedInput
  }

  export type StickyNoteLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stickyNoteId?: IntFieldUpdateOperationsInput | number
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteLinkCreateManyInput = {
    id?: number
    stickyNoteId: number
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt?: Date | string
  }

  export type StickyNoteLinkUpdateManyMutationInput = {
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stickyNoteId?: IntFieldUpdateOperationsInput | number
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupCreateInput = {
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectGroupsInput
    projects?: ProjectGroupMemberCreateNestedManyWithoutProjectGroupInput
  }

  export type ProjectGroupUncheckedCreateInput = {
    id?: number
    workspaceId: number
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectGroupInput
  }

  export type ProjectGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectGroupsNestedInput
    projects?: ProjectGroupMemberUpdateManyWithoutProjectGroupNestedInput
  }

  export type ProjectGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectGroupNestedInput
  }

  export type ProjectGroupCreateManyInput = {
    id?: number
    workspaceId: number
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberCreateInput = {
    position?: number
    createdAt?: Date | string
    projectGroup: ProjectGroupCreateNestedOneWithoutProjectsInput
    project: ProjectCreateNestedOneWithoutProjectGroupsInput
  }

  export type ProjectGroupMemberUncheckedCreateInput = {
    id?: number
    projectGroupId: number
    projectId: number
    position?: number
    createdAt?: Date | string
  }

  export type ProjectGroupMemberUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectGroup?: ProjectGroupUpdateOneRequiredWithoutProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutProjectGroupsNestedInput
  }

  export type ProjectGroupMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectGroupId?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberCreateManyInput = {
    id?: number
    projectGroupId: number
    projectId: number
    position?: number
    createdAt?: Date | string
  }

  export type ProjectGroupMemberUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectGroupId?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskSessionCreateInput = {
    sessionId: string
    linkType?: $Enums.TaskSessionType
    notes?: string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutGenxSessionsInput
  }

  export type TaskSessionUncheckedCreateInput = {
    id?: number
    taskId: number
    sessionId: string
    linkType?: $Enums.TaskSessionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type TaskSessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutGenxSessionsNestedInput
  }

  export type TaskSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskSessionCreateManyInput = {
    id?: number
    taskId: number
    sessionId: string
    linkType?: $Enums.TaskSessionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type TaskSessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBudgetsInput
    lines?: BudgetLineCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: BudgetLineUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBudgetsNestedInput
    lines?: BudgetLineUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: BudgetLineUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: number
    projectId: number
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineCreateInput = {
    description: string
    amount: Decimal | DecimalJsLike | number | string
    lineType?: $Enums.BudgetLineType
    taskId?: number | null
    createdAt?: Date | string
    budget: BudgetCreateNestedOneWithoutLinesInput
  }

  export type BudgetLineUncheckedCreateInput = {
    id?: number
    budgetId: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    lineType?: $Enums.BudgetLineType
    taskId?: number | null
    createdAt?: Date | string
  }

  export type BudgetLineUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutLinesNestedInput
  }

  export type BudgetLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    budgetId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineCreateManyInput = {
    id?: number
    budgetId: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    lineType?: $Enums.BudgetLineType
    taskId?: number | null
    createdAt?: Date | string
  }

  export type BudgetLineUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    budgetId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageCreateInput = {
    title: string
    content: string
    creatorId?: number | null
    modifierId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutWikiPagesInput
  }

  export type WikiPageUncheckedCreateInput = {
    id?: number
    projectId: number
    title: string
    content: string
    creatorId?: number | null
    modifierId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutWikiPagesNestedInput
  }

  export type WikiPageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageCreateManyInput = {
    id?: number
    projectId: number
    title: string
    content: string
    creatorId?: number | null
    modifierId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    name: string
    keyPrefix: string
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    keyPrefix: string
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: number
    userId: number
    name: string
    keyPrefix: string
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: number
    projectId: number
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    event: string
    payload: JsonNullValueInput | InputJsonValue
    statusCode?: number | null
    response?: string | null
    duration?: number | null
    success?: boolean
    attempts?: number
    deliveredAt?: Date | string
    webhook: WebhookCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: number
    webhookId: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    statusCode?: number | null
    response?: string | null
    duration?: number | null
    success?: boolean
    attempts?: number
    deliveredAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook?: WebhookUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    webhookId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: number
    webhookId: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    statusCode?: number | null
    response?: string | null
    duration?: number | null
    success?: boolean
    attempts?: number
    deliveredAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    webhookId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type: string
    title: string
    content?: string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    title: string
    content?: string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    type: string
    title: string
    content?: string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutActivitiesInput
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: number
    projectId: number
    userId?: number | null
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutActivitiesNestedInput
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: number
    projectId: number
    userId?: number | null
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    token: string
    expiresAt: Date | string
    ip: string
    userAgent: string
    isUsed?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    ip: string
    userAgent: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    ip: string
    userAgent: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastLoginCreateInput = {
    authType: string
    ip: string
    userAgent: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLastLoginsInput
  }

  export type LastLoginUncheckedCreateInput = {
    id?: number
    userId: number
    authType: string
    ip: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LastLoginUpdateInput = {
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLastLoginsNestedInput
  }

  export type LastLoginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastLoginCreateManyInput = {
    id?: number
    userId: number
    authType: string
    ip: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LastLoginUpdateManyMutationInput = {
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastLoginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetadataCreateInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMetadataInput
  }

  export type UserMetadataUncheckedCreateInput = {
    id?: number
    userId: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMetadataUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMetadataNestedInput
  }

  export type UserMetadataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetadataCreateManyInput = {
    id?: number
    userId: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMetadataUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetadataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationSettingCreateInput = {
    notificationType: string
    isEnabled?: boolean
    user: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type UserNotificationSettingUncheckedCreateInput = {
    id?: number
    userId: number
    notificationType: string
    isEnabled?: boolean
  }

  export type UserNotificationSettingUpdateInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type UserNotificationSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserNotificationSettingCreateManyInput = {
    id?: number
    userId: number
    notificationType: string
    isEnabled?: boolean
  }

  export type UserNotificationSettingUpdateManyMutationInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserNotificationSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAvatarCreateInput = {
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAvatarInput
  }

  export type UserAvatarUncheckedCreateInput = {
    id?: number
    userId: number
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAvatarUpdateInput = {
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAvatarNestedInput
  }

  export type UserAvatarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvatarCreateManyInput = {
    id?: number
    userId: number
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAvatarUpdateManyMutationInput = {
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvatarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
  }

  export type GroupUpdateManyMutationInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberCreateInput = {
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    externalSync?: boolean
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembershipsInput
    addedBy?: UserCreateNestedOneWithoutGroupMembersAddedInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: number
    groupId: number
    userId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    addedById?: number | null
    externalSync?: boolean
  }

  export type GroupMemberUpdateInput = {
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
    addedBy?: UserUpdateOneWithoutGroupMembersAddedNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberCreateManyInput = {
    id?: number
    groupId: number
    userId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    addedById?: number | null
    externalSync?: boolean
  }

  export type GroupMemberUpdateManyMutationInput = {
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionCreateInput = {
    name: string
    displayName: string
    description?: string | null
    category: string
    sortOrder?: number
    createdAt?: Date | string
    parent?: PermissionCreateNestedOneWithoutChildrenInput
    children?: PermissionCreateNestedManyWithoutParentInput
    groupPermissions?: GroupPermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    name: string
    displayName: string
    description?: string | null
    category: string
    parentId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    children?: PermissionUncheckedCreateNestedManyWithoutParentInput
    groupPermissions?: GroupPermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PermissionUpdateOneWithoutChildrenNestedInput
    children?: PermissionUpdateManyWithoutParentNestedInput
    groupPermissions?: GroupPermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PermissionUncheckedUpdateManyWithoutParentNestedInput
    groupPermissions?: GroupPermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    name: string
    displayName: string
    description?: string | null
    category: string
    parentId?: number | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupPermissionCreateInput = {
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
    group: GroupCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutGroupPermissionsInput
  }

  export type GroupPermissionUncheckedCreateInput = {
    id?: number
    groupId: number
    permissionId: number
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type GroupPermissionUpdateInput = {
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    group?: GroupUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutGroupPermissionsNestedInput
  }

  export type GroupPermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GroupPermissionCreateManyInput = {
    id?: number
    groupId: number
    permissionId: number
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type GroupPermissionUpdateManyMutationInput = {
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GroupPermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentCreateInput = {
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
    group: GroupCreateNestedOneWithoutRoleAssignmentsInput
    workspace?: WorkspaceCreateNestedOneWithoutRoleAssignmentsInput
    project?: ProjectCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type RoleAssignmentUncheckedCreateInput = {
    id?: number
    groupId: number
    workspaceId?: number | null
    projectId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type RoleAssignmentUpdateInput = {
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    group?: GroupUpdateOneRequiredWithoutRoleAssignmentsNestedInput
    workspace?: WorkspaceUpdateOneWithoutRoleAssignmentsNestedInput
    project?: ProjectUpdateOneWithoutRoleAssignmentsNestedInput
  }

  export type RoleAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentCreateManyInput = {
    id?: number
    groupId: number
    workspaceId?: number | null
    projectId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type RoleAssignmentUpdateManyMutationInput = {
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WorkspaceUserListRelationFilter = {
    every?: WorkspaceUserWhereInput
    some?: WorkspaceUserWhereInput
    none?: WorkspaceUserWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectGroupListRelationFilter = {
    every?: ProjectGroupWhereInput
    some?: ProjectGroupWhereInput
    none?: ProjectGroupWhereInput
  }

  export type WorkspaceInvitationListRelationFilter = {
    every?: WorkspaceInvitationWhereInput
    some?: WorkspaceInvitationWhereInput
    none?: WorkspaceInvitationWhereInput
  }

  export type WorkspaceLogoNullableScalarRelationFilter = {
    is?: WorkspaceLogoWhereInput | null
    isNot?: WorkspaceLogoWhereInput | null
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type RoleAssignmentListRelationFilter = {
    every?: RoleAssignmentWhereInput
    some?: RoleAssignmentWhereInput
    none?: RoleAssignmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkspaceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type WorkspaceLogoCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceLogoAvgOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    size?: SortOrder
  }

  export type WorkspaceLogoMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceLogoMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceLogoSumOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    size?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type EnumWorkspaceRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleFilter<$PrismaModel> | $Enums.WorkspaceRole
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WorkspaceUserWorkspaceIdUserIdCompoundUniqueInput = {
    workspaceId: number
    userId: number
  }

  export type WorkspaceUserCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type WorkspaceUserAvgOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
  }

  export type WorkspaceUserMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type WorkspaceUserMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type WorkspaceUserSumOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
  }

  export type EnumWorkspaceRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
  }

  export type WorkspaceInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkspaceInvitationAvgOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkspaceInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkspaceInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type WorkspaceInvitationSumOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumAppRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleFilter<$PrismaModel> | $Enums.AppRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkspaceListRelationFilter = {
    every?: WorkspaceWhereInput
    some?: WorkspaceWhereInput
    none?: WorkspaceWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskAssigneeListRelationFilter = {
    every?: TaskAssigneeWhereInput
    some?: TaskAssigneeWhereInput
    none?: TaskAssigneeWhereInput
  }

  export type SubtaskListRelationFilter = {
    every?: SubtaskWhereInput
    some?: SubtaskWhereInput
    none?: SubtaskWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type RememberTokenListRelationFilter = {
    every?: RememberTokenWhereInput
    some?: RememberTokenWhereInput
    none?: RememberTokenWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type PasswordResetListRelationFilter = {
    every?: PasswordResetWhereInput
    some?: PasswordResetWhereInput
    none?: PasswordResetWhereInput
  }

  export type LastLoginListRelationFilter = {
    every?: LastLoginWhereInput
    some?: LastLoginWhereInput
    none?: LastLoginWhereInput
  }

  export type UserMetadataListRelationFilter = {
    every?: UserMetadataWhereInput
    some?: UserMetadataWhereInput
    none?: UserMetadataWhereInput
  }

  export type UserNotificationSettingListRelationFilter = {
    every?: UserNotificationSettingWhereInput
    some?: UserNotificationSettingWhereInput
    none?: UserNotificationSettingWhereInput
  }

  export type UserAvatarNullableScalarRelationFilter = {
    is?: UserAvatarWhereInput | null
    isNot?: UserAvatarWhereInput | null
  }

  export type InviteListRelationFilter = {
    every?: InviteWhereInput
    some?: InviteWhereInput
    none?: InviteWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type WorkspaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RememberTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LastLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserNotificationSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twofactorActivated?: SortOrder
    twofactorSecret?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
    lockoutCount?: SortOrder
    googleId?: SortOrder
    githubId?: SortOrder
    gitlabId?: SortOrder
    theme?: SortOrder
    defaultFilter?: SortOrder
    publicToken?: SortOrder
    hourlyRate?: SortOrder
    notificationsEnabled?: SortOrder
    notificationFilter?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    failedLoginCount?: SortOrder
    lockoutCount?: SortOrder
    gitlabId?: SortOrder
    hourlyRate?: SortOrder
    notificationFilter?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twofactorActivated?: SortOrder
    twofactorSecret?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
    lockoutCount?: SortOrder
    googleId?: SortOrder
    githubId?: SortOrder
    gitlabId?: SortOrder
    theme?: SortOrder
    defaultFilter?: SortOrder
    publicToken?: SortOrder
    hourlyRate?: SortOrder
    notificationsEnabled?: SortOrder
    notificationFilter?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twofactorActivated?: SortOrder
    twofactorSecret?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
    lockoutCount?: SortOrder
    googleId?: SortOrder
    githubId?: SortOrder
    gitlabId?: SortOrder
    theme?: SortOrder
    defaultFilter?: SortOrder
    publicToken?: SortOrder
    hourlyRate?: SortOrder
    notificationsEnabled?: SortOrder
    notificationFilter?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    failedLoginCount?: SortOrder
    lockoutCount?: SortOrder
    gitlabId?: SortOrder
    hourlyRate?: SortOrder
    notificationFilter?: SortOrder
  }

  export type EnumAppRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleWithAggregatesFilter<$PrismaModel> | $Enums.AppRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppRoleFilter<$PrismaModel>
    _max?: NestedEnumAppRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RememberTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RememberTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RememberTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RememberTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RememberTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InviteCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InviteAvgOrderByAggregateInput = {
    id?: SortOrder
    invitedById?: SortOrder
  }

  export type InviteMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InviteMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InviteSumOrderByAggregateInput = {
    id?: SortOrder
    invitedById?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type SystemSettingAvgOrderByAggregateInput = {
    changedBy?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type SystemSettingSumOrderByAggregateInput = {
    changedBy?: SortOrder
  }

  export type ColumnListRelationFilter = {
    every?: ColumnWhereInput
    some?: ColumnWhereInput
    none?: ColumnWhereInput
  }

  export type SwimlaneListRelationFilter = {
    every?: SwimlaneWhereInput
    some?: SwimlaneWhereInput
    none?: SwimlaneWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CustomFieldListRelationFilter = {
    every?: CustomFieldWhereInput
    some?: CustomFieldWhereInput
    none?: CustomFieldWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type SprintListRelationFilter = {
    every?: SprintWhereInput
    some?: SprintWhereInput
    none?: SprintWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type WikiPageListRelationFilter = {
    every?: WikiPageWhereInput
    some?: WikiPageWhereInput
    none?: WikiPageWhereInput
  }

  export type ProjectGroupMemberListRelationFilter = {
    every?: ProjectGroupMemberWhereInput
    some?: ProjectGroupMemberWhereInput
    none?: ProjectGroupMemberWhereInput
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type ColumnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SwimlaneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SprintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WikiPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectWorkspaceIdIdentifierCompoundUniqueInput = {
    workspaceId: number
    identifier: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    settings?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type EnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: number
    userId: number
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type EnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type ColumnCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
    isCollapsed?: SortOrder
    showClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColumnAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
  }

  export type ColumnMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
    isCollapsed?: SortOrder
    showClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColumnMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
    isCollapsed?: SortOrder
    showClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColumnSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    taskLimit?: SortOrder
  }

  export type SwimlaneCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwimlaneAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type SwimlaneMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwimlaneMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SwimlaneSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ColumnScalarRelationFilter = {
    is?: ColumnWhereInput
    isNot?: ColumnWhereInput
  }

  export type SwimlaneNullableScalarRelationFilter = {
    is?: SwimlaneWhereInput | null
    isNot?: SwimlaneWhereInput | null
  }

  export type MilestoneNullableScalarRelationFilter = {
    is?: MilestoneWhereInput | null
    isNot?: MilestoneWhereInput | null
  }

  export type ModuleNullableScalarRelationFilter = {
    is?: ModuleWhereInput | null
    isNot?: ModuleWhereInput | null
  }

  export type SprintNullableScalarRelationFilter = {
    is?: SprintWhereInput | null
    isNot?: SprintWhereInput | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type TaskTagListRelationFilter = {
    every?: TaskTagWhereInput
    some?: TaskTagWhereInput
    none?: TaskTagWhereInput
  }

  export type TaskCustomValueListRelationFilter = {
    every?: TaskCustomValueWhereInput
    some?: TaskCustomValueWhereInput
    none?: TaskCustomValueWhereInput
  }

  export type TaskLinkListRelationFilter = {
    every?: TaskLinkWhereInput
    some?: TaskLinkWhereInput
    none?: TaskLinkWhereInput
  }

  export type TaskSessionListRelationFilter = {
    every?: TaskSessionWhereInput
    some?: TaskSessionWhereInput
    none?: TaskSessionWhereInput
  }

  export type TaskTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCustomValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    color?: SortOrder
    dateStarted?: SortOrder
    dateDue?: SortOrder
    dateCompleted?: SortOrder
    reminderAt?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    isDraggable?: SortOrder
    recurrenceData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestoneId?: SortOrder
    moduleId?: SortOrder
    sprintId?: SortOrder
    categoryId?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrder
    creatorId?: SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    milestoneId?: SortOrder
    moduleId?: SortOrder
    sprintId?: SortOrder
    categoryId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    color?: SortOrder
    dateStarted?: SortOrder
    dateDue?: SortOrder
    dateCompleted?: SortOrder
    reminderAt?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    isDraggable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestoneId?: SortOrder
    moduleId?: SortOrder
    sprintId?: SortOrder
    categoryId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    color?: SortOrder
    dateStarted?: SortOrder
    dateDue?: SortOrder
    dateCompleted?: SortOrder
    reminderAt?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    isActive?: SortOrder
    isDraggable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestoneId?: SortOrder
    moduleId?: SortOrder
    sprintId?: SortOrder
    categoryId?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    columnId?: SortOrder
    swimlaneId?: SortOrder
    creatorId?: SortOrder
    priority?: SortOrder
    score?: SortOrder
    progress?: SortOrder
    position?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    milestoneId?: SortOrder
    moduleId?: SortOrder
    sprintId?: SortOrder
    categoryId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskAssigneeTaskIdUserIdCompoundUniqueInput = {
    taskId: number
    userId: number
  }

  export type TaskAssigneeCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAssigneeAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAssigneeMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAssigneeMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAssigneeSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type EnumSubtaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusFilter<$PrismaModel> | $Enums.SubtaskStatus
  }

  export type SubtaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
  }

  export type SubtaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    position?: SortOrder
    assigneeId?: SortOrder
    timeEstimated?: SortOrder
    timeSpent?: SortOrder
  }

  export type EnumSubtaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubtaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubtaskStatusFilter<$PrismaModel>
    _max?: NestedEnumSubtaskStatusFilter<$PrismaModel>
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TagProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TaskTagTaskIdTagIdCompoundUniqueInput = {
    taskId: number
    tagId: number
  }

  export type TaskTagCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskTagAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
  }

  export type TaskTagMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskTagMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskTagSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    tagId?: SortOrder
  }

  export type CategoryProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    isImage?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    size?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    isImage?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    isImage?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    size?: SortOrder
  }

  export type EnumTaskLinkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLinkType | EnumTaskLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskLinkTypeFilter<$PrismaModel> | $Enums.TaskLinkType
  }

  export type TaskLinkTaskIdOppositeTaskIdLinkTypeCompoundUniqueInput = {
    taskId: number
    oppositeTaskId: number
    linkType: $Enums.TaskLinkType
  }

  export type TaskLinkCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
    linkType?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
  }

  export type TaskLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
    linkType?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLinkMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
    linkType?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLinkSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    oppositeTaskId?: SortOrder
  }

  export type EnumTaskLinkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLinkType | EnumTaskLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskLinkTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskLinkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskLinkTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskLinkTypeFilter<$PrismaModel>
  }

  export type EnumCustomFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomFieldType | EnumCustomFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomFieldTypeFilter<$PrismaModel> | $Enums.CustomFieldType
  }

  export type CustomFieldProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type CustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    isRequired?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type CustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isRequired?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isRequired?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomFieldSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type EnumCustomFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomFieldType | EnumCustomFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomFieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomFieldTypeFilter<$PrismaModel>
  }

  export type CustomFieldScalarRelationFilter = {
    is?: CustomFieldWhereInput
    isNot?: CustomFieldWhereInput
  }

  export type TaskCustomValueTaskIdCustomFieldIdCompoundUniqueInput = {
    taskId: number
    customFieldId: number
  }

  export type TaskCustomValueCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskCustomValueAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
  }

  export type TaskCustomValueMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskCustomValueMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskCustomValueSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    customFieldId?: SortOrder
  }

  export type EnumSprintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SprintStatus | EnumSprintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSprintStatusFilter<$PrismaModel> | $Enums.SprintStatus
  }

  export type SprintCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SprintMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EnumSprintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SprintStatus | EnumSprintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSprintStatusWithAggregatesFilter<$PrismaModel> | $Enums.SprintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSprintStatusFilter<$PrismaModel>
    _max?: NestedEnumSprintStatusFilter<$PrismaModel>
  }

  export type ModuleProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dateDue?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dateDue?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dateDue?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EnumStickyNoteColorFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyNoteColor | EnumStickyNoteColorFieldRefInput<$PrismaModel>
    in?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyNoteColorFilter<$PrismaModel> | $Enums.StickyNoteColor
  }

  export type EnumStickyVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyVisibility | EnumStickyVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyVisibilityFilter<$PrismaModel> | $Enums.StickyVisibility
  }

  export type StickyNoteLinkListRelationFilter = {
    every?: StickyNoteLinkWhereInput
    some?: StickyNoteLinkWhereInput
    none?: StickyNoteLinkWhereInput
  }

  export type StickyNoteLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StickyNoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    color?: SortOrder
    isPinned?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StickyNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type StickyNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    color?: SortOrder
    isPinned?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StickyNoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    color?: SortOrder
    isPinned?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StickyNoteSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumStickyNoteColorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyNoteColor | EnumStickyNoteColorFieldRefInput<$PrismaModel>
    in?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyNoteColorWithAggregatesFilter<$PrismaModel> | $Enums.StickyNoteColor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickyNoteColorFilter<$PrismaModel>
    _max?: NestedEnumStickyNoteColorFilter<$PrismaModel>
  }

  export type EnumStickyVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyVisibility | EnumStickyVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.StickyVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickyVisibilityFilter<$PrismaModel>
    _max?: NestedEnumStickyVisibilityFilter<$PrismaModel>
  }

  export type EnumStickyLinkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyLinkType | EnumStickyLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyLinkTypeFilter<$PrismaModel> | $Enums.StickyLinkType
  }

  export type StickyNoteScalarRelationFilter = {
    is?: StickyNoteWhereInput
    isNot?: StickyNoteWhereInput
  }

  export type StickyNoteLinkStickyNoteIdEntityTypeEntityIdCompoundUniqueInput = {
    stickyNoteId: number
    entityType: $Enums.StickyLinkType
    entityId: number
  }

  export type StickyNoteLinkCountOrderByAggregateInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type StickyNoteLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityId?: SortOrder
  }

  export type StickyNoteLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type StickyNoteLinkMinOrderByAggregateInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type StickyNoteLinkSumOrderByAggregateInput = {
    id?: SortOrder
    stickyNoteId?: SortOrder
    entityId?: SortOrder
  }

  export type EnumStickyLinkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyLinkType | EnumStickyLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyLinkTypeWithAggregatesFilter<$PrismaModel> | $Enums.StickyLinkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickyLinkTypeFilter<$PrismaModel>
    _max?: NestedEnumStickyLinkTypeFilter<$PrismaModel>
  }

  export type EnumProjectGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectGroupStatus | EnumProjectGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectGroupStatusFilter<$PrismaModel> | $Enums.ProjectGroupStatus
  }

  export type ProjectGroupCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type ProjectGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectGroupMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectGroupSumOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
  }

  export type EnumProjectGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectGroupStatus | EnumProjectGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectGroupStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectGroupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectGroupStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectGroupStatusFilter<$PrismaModel>
  }

  export type ProjectGroupScalarRelationFilter = {
    is?: ProjectGroupWhereInput
    isNot?: ProjectGroupWhereInput
  }

  export type ProjectGroupMemberProjectGroupIdProjectIdCompoundUniqueInput = {
    projectGroupId: number
    projectId: number
  }

  export type ProjectGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectGroupMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type ProjectGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectGroupMemberSumOrderByAggregateInput = {
    id?: SortOrder
    projectGroupId?: SortOrder
    projectId?: SortOrder
    position?: SortOrder
  }

  export type EnumTaskSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskSessionType | EnumTaskSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskSessionTypeFilter<$PrismaModel> | $Enums.TaskSessionType
  }

  export type TaskSessionTaskIdSessionIdLinkTypeCompoundUniqueInput = {
    taskId: number
    sessionId: string
    linkType: $Enums.TaskSessionType
  }

  export type TaskSessionCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    sessionId?: SortOrder
    linkType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type TaskSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    sessionId?: SortOrder
    linkType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskSessionMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    sessionId?: SortOrder
    linkType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskSessionSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type EnumTaskSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskSessionType | EnumTaskSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskSessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskSessionTypeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BudgetLineListRelationFilter = {
    every?: BudgetLineWhereInput
    some?: BudgetLineWhereInput
    none?: BudgetLineWhereInput
  }

  export type BudgetLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumBudgetLineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetLineType | EnumBudgetLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetLineTypeFilter<$PrismaModel> | $Enums.BudgetLineType
  }

  export type BudgetScalarRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type BudgetLineCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    lineType?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetLineAvgOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    amount?: SortOrder
    taskId?: SortOrder
  }

  export type BudgetLineMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    lineType?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetLineMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    lineType?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetLineSumOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    amount?: SortOrder
    taskId?: SortOrder
  }

  export type EnumBudgetLineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetLineType | EnumBudgetLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetLineTypeWithAggregatesFilter<$PrismaModel> | $Enums.BudgetLineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetLineTypeFilter<$PrismaModel>
    _max?: NestedEnumBudgetLineTypeFilter<$PrismaModel>
  }

  export type WikiPageCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    modifierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WikiPageAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    modifierId?: SortOrder
  }

  export type WikiPageMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    modifierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WikiPageMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    modifierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WikiPageSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    creatorId?: SortOrder
    modifierId?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    keyPrefix?: SortOrder
    keyHash?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rateLimit?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    keyPrefix?: SortOrder
    keyHash?: SortOrder
    rateLimit?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    keyPrefix?: SortOrder
    keyHash?: SortOrder
    rateLimit?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rateLimit?: SortOrder
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    failureCount?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    lastSuccess?: SortOrder
    lastFailure?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    failureCount?: SortOrder
  }

  export type WebhookScalarRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    statusCode?: SortOrder
    response?: SortOrder
    duration?: SortOrder
    success?: SortOrder
    attempts?: SortOrder
    deliveredAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    statusCode?: SortOrder
    duration?: SortOrder
    attempts?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    statusCode?: SortOrder
    response?: SortOrder
    duration?: SortOrder
    success?: SortOrder
    attempts?: SortOrder
    deliveredAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    statusCode?: SortOrder
    response?: SortOrder
    duration?: SortOrder
    success?: SortOrder
    attempts?: SortOrder
    deliveredAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    statusCode?: SortOrder
    duration?: SortOrder
    attempts?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    data?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LastLoginCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    authType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LastLoginAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LastLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    authType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LastLoginMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    authType?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LastLoginSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserMetadataUserIdKeyCompoundUniqueInput = {
    userId: number
    key: string
  }

  export type UserMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMetadataAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMetadataSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserNotificationSettingUserIdNotificationTypeCompoundUniqueInput = {
    userId: number
    notificationType: string
  }

  export type UserNotificationSettingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    isEnabled?: SortOrder
  }

  export type UserNotificationSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserNotificationSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    isEnabled?: SortOrder
  }

  export type UserNotificationSettingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    isEnabled?: SortOrder
  }

  export type UserNotificationSettingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserAvatarCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvatarAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    size?: SortOrder
  }

  export type UserAvatarMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvatarMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvatarSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    size?: SortOrder
  }

  export type EnumGroupTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupType | EnumGroupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypeFilter<$PrismaModel> | $Enums.GroupType
  }

  export type EnumGroupScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupScope | EnumGroupScopeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupScopeFilter<$PrismaModel> | $Enums.GroupScope
  }

  export type EnumGroupSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupSource | EnumGroupSourceFieldRefInput<$PrismaModel>
    in?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupSourceFilter<$PrismaModel> | $Enums.GroupSource
  }

  export type GroupNullableScalarRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type WorkspaceNullableScalarRelationFilter = {
    is?: WorkspaceWhereInput | null
    isNot?: WorkspaceWhereInput | null
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type GroupPermissionListRelationFilter = {
    every?: GroupPermissionWhereInput
    some?: GroupPermissionWhereInput
    none?: GroupPermissionWhereInput
  }

  export type GroupPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    objectGuid?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    distinguishedName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scope?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    parentGroupId?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSecurityGroup?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    parentGroupId?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    objectGuid?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    distinguishedName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scope?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    parentGroupId?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSecurityGroup?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    objectGuid?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    distinguishedName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scope?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    parentGroupId?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSecurityGroup?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    parentGroupId?: SortOrder
  }

  export type EnumGroupTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupType | EnumGroupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypeWithAggregatesFilter<$PrismaModel> | $Enums.GroupType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupTypeFilter<$PrismaModel>
    _max?: NestedEnumGroupTypeFilter<$PrismaModel>
  }

  export type EnumGroupScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupScope | EnumGroupScopeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupScopeWithAggregatesFilter<$PrismaModel> | $Enums.GroupScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupScopeFilter<$PrismaModel>
    _max?: NestedEnumGroupScopeFilter<$PrismaModel>
  }

  export type EnumGroupSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupSource | EnumGroupSourceFieldRefInput<$PrismaModel>
    in?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupSourceWithAggregatesFilter<$PrismaModel> | $Enums.GroupSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupSourceFilter<$PrismaModel>
    _max?: NestedEnumGroupSourceFilter<$PrismaModel>
  }

  export type EnumMemberTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberType | EnumMemberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberTypeFilter<$PrismaModel> | $Enums.MemberType
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: number
    userId: number
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    memberType?: SortOrder
    expiresAt?: SortOrder
    addedAt?: SortOrder
    addedById?: SortOrder
    externalSync?: SortOrder
  }

  export type GroupMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    memberType?: SortOrder
    expiresAt?: SortOrder
    addedAt?: SortOrder
    addedById?: SortOrder
    externalSync?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    memberType?: SortOrder
    expiresAt?: SortOrder
    addedAt?: SortOrder
    addedById?: SortOrder
    externalSync?: SortOrder
  }

  export type GroupMemberSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
  }

  export type EnumMemberTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberType | EnumMemberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberTypeWithAggregatesFilter<$PrismaModel> | $Enums.MemberType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberTypeFilter<$PrismaModel>
    _max?: NestedEnumMemberTypeFilter<$PrismaModel>
  }

  export type PermissionNullableScalarRelationFilter = {
    is?: PermissionWhereInput | null
    isNot?: PermissionWhereInput | null
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumAccessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeFilter<$PrismaModel> | $Enums.AccessType
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type GroupPermissionGroupIdPermissionIdWorkspaceIdProjectIdCompoundUniqueInput = {
    groupId: number
    permissionId: number
    workspaceId: number
    projectId: number
  }

  export type GroupPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    accessType?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    inherited?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type GroupPermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
  }

  export type GroupPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    accessType?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    inherited?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type GroupPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    accessType?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    inherited?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type GroupPermissionSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    permissionId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumAccessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessTypeFilter<$PrismaModel>
    _max?: NestedEnumAccessTypeFilter<$PrismaModel>
  }

  export type EnumAssignmentRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleFilter<$PrismaModel> | $Enums.AssignmentRole
  }

  export type RoleAssignmentGroupIdWorkspaceIdProjectIdCompoundUniqueInput = {
    groupId: number
    workspaceId: number
    projectId: number
  }

  export type RoleAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    inheritToChildren?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
  }

  export type RoleAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    inheritToChildren?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    inheritToChildren?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type RoleAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    workspaceId?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumAssignmentRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentRoleFilter<$PrismaModel>
    _max?: NestedEnumAssignmentRoleFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutWorkspacesCreatedInput = {
    create?: XOR<UserCreateWithoutWorkspacesCreatedInput, UserUncheckedCreateWithoutWorkspacesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUserCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectGroupCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectGroupCreateWithoutWorkspaceInput, ProjectGroupUncheckedCreateWithoutWorkspaceInput> | ProjectGroupCreateWithoutWorkspaceInput[] | ProjectGroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectGroupCreateOrConnectWithoutWorkspaceInput | ProjectGroupCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectGroupCreateManyWorkspaceInputEnvelope
    connect?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceLogoCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<WorkspaceLogoCreateWithoutWorkspaceInput, WorkspaceLogoUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceLogoCreateOrConnectWithoutWorkspaceInput
    connect?: WorkspaceLogoWhereUniqueInput
  }

  export type GroupCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<GroupCreateWithoutWorkspaceInput, GroupUncheckedCreateWithoutWorkspaceInput> | GroupCreateWithoutWorkspaceInput[] | GroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutWorkspaceInput | GroupCreateOrConnectWithoutWorkspaceInput[]
    createMany?: GroupCreateManyWorkspaceInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type RoleAssignmentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<RoleAssignmentCreateWithoutWorkspaceInput, RoleAssignmentUncheckedCreateWithoutWorkspaceInput> | RoleAssignmentCreateWithoutWorkspaceInput[] | RoleAssignmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutWorkspaceInput | RoleAssignmentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: RoleAssignmentCreateManyWorkspaceInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectGroupCreateWithoutWorkspaceInput, ProjectGroupUncheckedCreateWithoutWorkspaceInput> | ProjectGroupCreateWithoutWorkspaceInput[] | ProjectGroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectGroupCreateOrConnectWithoutWorkspaceInput | ProjectGroupCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectGroupCreateManyWorkspaceInputEnvelope
    connect?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<WorkspaceLogoCreateWithoutWorkspaceInput, WorkspaceLogoUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceLogoCreateOrConnectWithoutWorkspaceInput
    connect?: WorkspaceLogoWhereUniqueInput
  }

  export type GroupUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<GroupCreateWithoutWorkspaceInput, GroupUncheckedCreateWithoutWorkspaceInput> | GroupCreateWithoutWorkspaceInput[] | GroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutWorkspaceInput | GroupCreateOrConnectWithoutWorkspaceInput[]
    createMany?: GroupCreateManyWorkspaceInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<RoleAssignmentCreateWithoutWorkspaceInput, RoleAssignmentUncheckedCreateWithoutWorkspaceInput> | RoleAssignmentCreateWithoutWorkspaceInput[] | RoleAssignmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutWorkspaceInput | RoleAssignmentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: RoleAssignmentCreateManyWorkspaceInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutWorkspacesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesCreatedInput, UserUncheckedCreateWithoutWorkspacesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesCreatedInput
    upsert?: UserUpsertWithoutWorkspacesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesCreatedInput, UserUpdateWithoutWorkspacesCreatedInput>, UserUncheckedUpdateWithoutWorkspacesCreatedInput>
  }

  export type WorkspaceUserUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutWorkspaceInput | ProjectUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectGroupUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectGroupCreateWithoutWorkspaceInput, ProjectGroupUncheckedCreateWithoutWorkspaceInput> | ProjectGroupCreateWithoutWorkspaceInput[] | ProjectGroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectGroupCreateOrConnectWithoutWorkspaceInput | ProjectGroupCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectGroupUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectGroupUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectGroupCreateManyWorkspaceInputEnvelope
    set?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    disconnect?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    delete?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    connect?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    update?: ProjectGroupUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectGroupUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectGroupUpdateManyWithWhereWithoutWorkspaceInput | ProjectGroupUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectGroupScalarWhereInput | ProjectGroupScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceLogoCreateWithoutWorkspaceInput, WorkspaceLogoUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceLogoCreateOrConnectWithoutWorkspaceInput
    upsert?: WorkspaceLogoUpsertWithoutWorkspaceInput
    disconnect?: WorkspaceLogoWhereInput | boolean
    delete?: WorkspaceLogoWhereInput | boolean
    connect?: WorkspaceLogoWhereUniqueInput
    update?: XOR<XOR<WorkspaceLogoUpdateToOneWithWhereWithoutWorkspaceInput, WorkspaceLogoUpdateWithoutWorkspaceInput>, WorkspaceLogoUncheckedUpdateWithoutWorkspaceInput>
  }

  export type GroupUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<GroupCreateWithoutWorkspaceInput, GroupUncheckedCreateWithoutWorkspaceInput> | GroupCreateWithoutWorkspaceInput[] | GroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutWorkspaceInput | GroupCreateOrConnectWithoutWorkspaceInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutWorkspaceInput | GroupUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: GroupCreateManyWorkspaceInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutWorkspaceInput | GroupUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutWorkspaceInput | GroupUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type RoleAssignmentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutWorkspaceInput, RoleAssignmentUncheckedCreateWithoutWorkspaceInput> | RoleAssignmentCreateWithoutWorkspaceInput[] | RoleAssignmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutWorkspaceInput | RoleAssignmentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutWorkspaceInput | RoleAssignmentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: RoleAssignmentCreateManyWorkspaceInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutWorkspaceInput | RoleAssignmentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutWorkspaceInput | RoleAssignmentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserCreateWithoutWorkspaceInput[] | WorkspaceUserUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutWorkspaceInput | WorkspaceUserCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutWorkspaceInput | ProjectUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectGroupCreateWithoutWorkspaceInput, ProjectGroupUncheckedCreateWithoutWorkspaceInput> | ProjectGroupCreateWithoutWorkspaceInput[] | ProjectGroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectGroupCreateOrConnectWithoutWorkspaceInput | ProjectGroupCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectGroupUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectGroupUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectGroupCreateManyWorkspaceInputEnvelope
    set?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    disconnect?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    delete?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    connect?: ProjectGroupWhereUniqueInput | ProjectGroupWhereUniqueInput[]
    update?: ProjectGroupUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectGroupUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectGroupUpdateManyWithWhereWithoutWorkspaceInput | ProjectGroupUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectGroupScalarWhereInput | ProjectGroupScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput> | WorkspaceInvitationCreateWithoutWorkspaceInput[] | WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput | WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceInvitationCreateManyWorkspaceInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceLogoCreateWithoutWorkspaceInput, WorkspaceLogoUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: WorkspaceLogoCreateOrConnectWithoutWorkspaceInput
    upsert?: WorkspaceLogoUpsertWithoutWorkspaceInput
    disconnect?: WorkspaceLogoWhereInput | boolean
    delete?: WorkspaceLogoWhereInput | boolean
    connect?: WorkspaceLogoWhereUniqueInput
    update?: XOR<XOR<WorkspaceLogoUpdateToOneWithWhereWithoutWorkspaceInput, WorkspaceLogoUpdateWithoutWorkspaceInput>, WorkspaceLogoUncheckedUpdateWithoutWorkspaceInput>
  }

  export type GroupUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<GroupCreateWithoutWorkspaceInput, GroupUncheckedCreateWithoutWorkspaceInput> | GroupCreateWithoutWorkspaceInput[] | GroupUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutWorkspaceInput | GroupCreateOrConnectWithoutWorkspaceInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutWorkspaceInput | GroupUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: GroupCreateManyWorkspaceInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutWorkspaceInput | GroupUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutWorkspaceInput | GroupUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutWorkspaceInput, RoleAssignmentUncheckedCreateWithoutWorkspaceInput> | RoleAssignmentCreateWithoutWorkspaceInput[] | RoleAssignmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutWorkspaceInput | RoleAssignmentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutWorkspaceInput | RoleAssignmentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: RoleAssignmentCreateManyWorkspaceInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutWorkspaceInput | RoleAssignmentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutWorkspaceInput | RoleAssignmentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutLogoInput = {
    create?: XOR<WorkspaceCreateWithoutLogoInput, WorkspaceUncheckedCreateWithoutLogoInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLogoInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes
  }

  export type WorkspaceUpdateOneRequiredWithoutLogoNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLogoInput, WorkspaceUncheckedCreateWithoutLogoInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLogoInput
    upsert?: WorkspaceUpsertWithoutLogoInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLogoInput, WorkspaceUpdateWithoutLogoInput>, WorkspaceUncheckedUpdateWithoutLogoInput>
  }

  export type WorkspaceCreateNestedOneWithoutUsersInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumWorkspaceRoleFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceRole
  }

  export type WorkspaceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    upsert?: WorkspaceUpsertWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutUsersInput, WorkspaceUpdateWithoutUsersInput>, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsCreatedInput = {
    create?: XOR<UserCreateWithoutInvitationsCreatedInput, UserUncheckedCreateWithoutInvitationsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    upsert?: WorkspaceUpsertWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitationsInput, WorkspaceUpdateWithoutInvitationsInput>, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsCreatedInput, UserUncheckedCreateWithoutInvitationsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsCreatedInput
    upsert?: UserUpsertWithoutInvitationsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsCreatedInput, UserUpdateWithoutInvitationsCreatedInput>, UserUncheckedUpdateWithoutInvitationsCreatedInput>
  }

  export type WorkspaceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkspaceCreateWithoutCreatedByInput, WorkspaceUncheckedCreateWithoutCreatedByInput> | WorkspaceCreateWithoutCreatedByInput[] | WorkspaceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCreatedByInput | WorkspaceCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkspaceCreateManyCreatedByInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type WorkspaceInvitationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutCreatorInput, WorkspaceInvitationUncheckedCreateWithoutCreatorInput> | WorkspaceInvitationCreateWithoutCreatorInput[] | WorkspaceInvitationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutCreatorInput | WorkspaceInvitationCreateOrConnectWithoutCreatorInput[]
    createMany?: WorkspaceInvitationCreateManyCreatorInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskAssigneeCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RememberTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RememberTokenCreateWithoutUserInput, RememberTokenUncheckedCreateWithoutUserInput> | RememberTokenCreateWithoutUserInput[] | RememberTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RememberTokenCreateOrConnectWithoutUserInput | RememberTokenCreateOrConnectWithoutUserInput[]
    createMany?: RememberTokenCreateManyUserInputEnvelope
    connect?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type PasswordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type LastLoginCreateNestedManyWithoutUserInput = {
    create?: XOR<LastLoginCreateWithoutUserInput, LastLoginUncheckedCreateWithoutUserInput> | LastLoginCreateWithoutUserInput[] | LastLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LastLoginCreateOrConnectWithoutUserInput | LastLoginCreateOrConnectWithoutUserInput[]
    createMany?: LastLoginCreateManyUserInputEnvelope
    connect?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
  }

  export type UserMetadataCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMetadataCreateWithoutUserInput, UserMetadataUncheckedCreateWithoutUserInput> | UserMetadataCreateWithoutUserInput[] | UserMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetadataCreateOrConnectWithoutUserInput | UserMetadataCreateOrConnectWithoutUserInput[]
    createMany?: UserMetadataCreateManyUserInputEnvelope
    connect?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
  }

  export type UserNotificationSettingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNotificationSettingCreateWithoutUserInput, UserNotificationSettingUncheckedCreateWithoutUserInput> | UserNotificationSettingCreateWithoutUserInput[] | UserNotificationSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationSettingCreateOrConnectWithoutUserInput | UserNotificationSettingCreateOrConnectWithoutUserInput[]
    createMany?: UserNotificationSettingCreateManyUserInputEnvelope
    connect?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
  }

  export type UserAvatarCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAvatarCreateWithoutUserInput, UserAvatarUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAvatarCreateOrConnectWithoutUserInput
    connect?: UserAvatarWhereUniqueInput
  }

  export type InviteCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<InviteCreateWithoutInvitedByInput, InviteUncheckedCreateWithoutInvitedByInput> | InviteCreateWithoutInvitedByInput[] | InviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByInput | InviteCreateOrConnectWithoutInvitedByInput[]
    createMany?: InviteCreateManyInvitedByInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutAddedByInput = {
    create?: XOR<GroupMemberCreateWithoutAddedByInput, GroupMemberUncheckedCreateWithoutAddedByInput> | GroupMemberCreateWithoutAddedByInput[] | GroupMemberUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutAddedByInput | GroupMemberCreateOrConnectWithoutAddedByInput[]
    createMany?: GroupMemberCreateManyAddedByInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type WorkspaceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
  }

  export type WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WorkspaceCreateWithoutCreatedByInput, WorkspaceUncheckedCreateWithoutCreatedByInput> | WorkspaceCreateWithoutCreatedByInput[] | WorkspaceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCreatedByInput | WorkspaceCreateOrConnectWithoutCreatedByInput[]
    createMany?: WorkspaceCreateManyCreatedByInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutCreatorInput, WorkspaceInvitationUncheckedCreateWithoutCreatorInput> | WorkspaceInvitationCreateWithoutCreatorInput[] | WorkspaceInvitationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutCreatorInput | WorkspaceInvitationCreateOrConnectWithoutCreatorInput[]
    createMany?: WorkspaceInvitationCreateManyCreatorInputEnvelope
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RememberTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RememberTokenCreateWithoutUserInput, RememberTokenUncheckedCreateWithoutUserInput> | RememberTokenCreateWithoutUserInput[] | RememberTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RememberTokenCreateOrConnectWithoutUserInput | RememberTokenCreateOrConnectWithoutUserInput[]
    createMany?: RememberTokenCreateManyUserInputEnvelope
    connect?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type PasswordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type LastLoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LastLoginCreateWithoutUserInput, LastLoginUncheckedCreateWithoutUserInput> | LastLoginCreateWithoutUserInput[] | LastLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LastLoginCreateOrConnectWithoutUserInput | LastLoginCreateOrConnectWithoutUserInput[]
    createMany?: LastLoginCreateManyUserInputEnvelope
    connect?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
  }

  export type UserMetadataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMetadataCreateWithoutUserInput, UserMetadataUncheckedCreateWithoutUserInput> | UserMetadataCreateWithoutUserInput[] | UserMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetadataCreateOrConnectWithoutUserInput | UserMetadataCreateOrConnectWithoutUserInput[]
    createMany?: UserMetadataCreateManyUserInputEnvelope
    connect?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
  }

  export type UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNotificationSettingCreateWithoutUserInput, UserNotificationSettingUncheckedCreateWithoutUserInput> | UserNotificationSettingCreateWithoutUserInput[] | UserNotificationSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationSettingCreateOrConnectWithoutUserInput | UserNotificationSettingCreateOrConnectWithoutUserInput[]
    createMany?: UserNotificationSettingCreateManyUserInputEnvelope
    connect?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
  }

  export type UserAvatarUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAvatarCreateWithoutUserInput, UserAvatarUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAvatarCreateOrConnectWithoutUserInput
    connect?: UserAvatarWhereUniqueInput
  }

  export type InviteUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<InviteCreateWithoutInvitedByInput, InviteUncheckedCreateWithoutInvitedByInput> | InviteCreateWithoutInvitedByInput[] | InviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByInput | InviteCreateOrConnectWithoutInvitedByInput[]
    createMany?: InviteCreateManyInvitedByInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<GroupMemberCreateWithoutAddedByInput, GroupMemberUncheckedCreateWithoutAddedByInput> | GroupMemberCreateWithoutAddedByInput[] | GroupMemberUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutAddedByInput | GroupMemberCreateOrConnectWithoutAddedByInput[]
    createMany?: GroupMemberCreateManyAddedByInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type EnumAppRoleFieldUpdateOperationsInput = {
    set?: $Enums.AppRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type WorkspaceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type WorkspaceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCreatedByInput, WorkspaceUncheckedCreateWithoutCreatedByInput> | WorkspaceCreateWithoutCreatedByInput[] | WorkspaceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCreatedByInput | WorkspaceCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutCreatedByInput | WorkspaceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkspaceCreateManyCreatedByInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutCreatedByInput | WorkspaceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutCreatedByInput | WorkspaceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type WorkspaceInvitationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutCreatorInput, WorkspaceInvitationUncheckedCreateWithoutCreatorInput> | WorkspaceInvitationCreateWithoutCreatorInput[] | WorkspaceInvitationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutCreatorInput | WorkspaceInvitationCreateOrConnectWithoutCreatorInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutCreatorInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WorkspaceInvitationCreateManyCreatorInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutCreatorInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutCreatorInput | WorkspaceInvitationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssigneeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutUserInput | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutUserInput | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutUserInput | TaskAssigneeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutAssigneeInput | SubtaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutAssigneeInput | SubtaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutAssigneeInput | SubtaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RememberTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RememberTokenCreateWithoutUserInput, RememberTokenUncheckedCreateWithoutUserInput> | RememberTokenCreateWithoutUserInput[] | RememberTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RememberTokenCreateOrConnectWithoutUserInput | RememberTokenCreateOrConnectWithoutUserInput[]
    upsert?: RememberTokenUpsertWithWhereUniqueWithoutUserInput | RememberTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RememberTokenCreateManyUserInputEnvelope
    set?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    disconnect?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    delete?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    connect?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    update?: RememberTokenUpdateWithWhereUniqueWithoutUserInput | RememberTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RememberTokenUpdateManyWithWhereWithoutUserInput | RememberTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RememberTokenScalarWhereInput | RememberTokenScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type PasswordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type LastLoginUpdateManyWithoutUserNestedInput = {
    create?: XOR<LastLoginCreateWithoutUserInput, LastLoginUncheckedCreateWithoutUserInput> | LastLoginCreateWithoutUserInput[] | LastLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LastLoginCreateOrConnectWithoutUserInput | LastLoginCreateOrConnectWithoutUserInput[]
    upsert?: LastLoginUpsertWithWhereUniqueWithoutUserInput | LastLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LastLoginCreateManyUserInputEnvelope
    set?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    disconnect?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    delete?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    connect?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    update?: LastLoginUpdateWithWhereUniqueWithoutUserInput | LastLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LastLoginUpdateManyWithWhereWithoutUserInput | LastLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LastLoginScalarWhereInput | LastLoginScalarWhereInput[]
  }

  export type UserMetadataUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMetadataCreateWithoutUserInput, UserMetadataUncheckedCreateWithoutUserInput> | UserMetadataCreateWithoutUserInput[] | UserMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetadataCreateOrConnectWithoutUserInput | UserMetadataCreateOrConnectWithoutUserInput[]
    upsert?: UserMetadataUpsertWithWhereUniqueWithoutUserInput | UserMetadataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMetadataCreateManyUserInputEnvelope
    set?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    disconnect?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    delete?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    connect?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    update?: UserMetadataUpdateWithWhereUniqueWithoutUserInput | UserMetadataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMetadataUpdateManyWithWhereWithoutUserInput | UserMetadataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMetadataScalarWhereInput | UserMetadataScalarWhereInput[]
  }

  export type UserNotificationSettingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNotificationSettingCreateWithoutUserInput, UserNotificationSettingUncheckedCreateWithoutUserInput> | UserNotificationSettingCreateWithoutUserInput[] | UserNotificationSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationSettingCreateOrConnectWithoutUserInput | UserNotificationSettingCreateOrConnectWithoutUserInput[]
    upsert?: UserNotificationSettingUpsertWithWhereUniqueWithoutUserInput | UserNotificationSettingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNotificationSettingCreateManyUserInputEnvelope
    set?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    disconnect?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    delete?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    connect?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    update?: UserNotificationSettingUpdateWithWhereUniqueWithoutUserInput | UserNotificationSettingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNotificationSettingUpdateManyWithWhereWithoutUserInput | UserNotificationSettingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNotificationSettingScalarWhereInput | UserNotificationSettingScalarWhereInput[]
  }

  export type UserAvatarUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAvatarCreateWithoutUserInput, UserAvatarUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAvatarCreateOrConnectWithoutUserInput
    upsert?: UserAvatarUpsertWithoutUserInput
    disconnect?: UserAvatarWhereInput | boolean
    delete?: UserAvatarWhereInput | boolean
    connect?: UserAvatarWhereUniqueInput
    update?: XOR<XOR<UserAvatarUpdateToOneWithWhereWithoutUserInput, UserAvatarUpdateWithoutUserInput>, UserAvatarUncheckedUpdateWithoutUserInput>
  }

  export type InviteUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<InviteCreateWithoutInvitedByInput, InviteUncheckedCreateWithoutInvitedByInput> | InviteCreateWithoutInvitedByInput[] | InviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByInput | InviteCreateOrConnectWithoutInvitedByInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutInvitedByInput | InviteUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: InviteCreateManyInvitedByInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutInvitedByInput | InviteUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutInvitedByInput | InviteUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<GroupMemberCreateWithoutAddedByInput, GroupMemberUncheckedCreateWithoutAddedByInput> | GroupMemberCreateWithoutAddedByInput[] | GroupMemberUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutAddedByInput | GroupMemberCreateOrConnectWithoutAddedByInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutAddedByInput | GroupMemberUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: GroupMemberCreateManyAddedByInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutAddedByInput | GroupMemberUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutAddedByInput | GroupMemberUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput> | WorkspaceUserCreateWithoutUserInput[] | WorkspaceUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserCreateOrConnectWithoutUserInput | WorkspaceUserCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserCreateManyUserInputEnvelope
    set?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    disconnect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    delete?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    connect?: WorkspaceUserWhereUniqueInput | WorkspaceUserWhereUniqueInput[]
    update?: WorkspaceUserUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserUpdateManyWithWhereWithoutUserInput | WorkspaceUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
  }

  export type WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCreatedByInput, WorkspaceUncheckedCreateWithoutCreatedByInput> | WorkspaceCreateWithoutCreatedByInput[] | WorkspaceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCreatedByInput | WorkspaceCreateOrConnectWithoutCreatedByInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutCreatedByInput | WorkspaceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WorkspaceCreateManyCreatedByInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutCreatedByInput | WorkspaceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutCreatedByInput | WorkspaceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WorkspaceInvitationCreateWithoutCreatorInput, WorkspaceInvitationUncheckedCreateWithoutCreatorInput> | WorkspaceInvitationCreateWithoutCreatorInput[] | WorkspaceInvitationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkspaceInvitationCreateOrConnectWithoutCreatorInput | WorkspaceInvitationCreateOrConnectWithoutCreatorInput[]
    upsert?: WorkspaceInvitationUpsertWithWhereUniqueWithoutCreatorInput | WorkspaceInvitationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WorkspaceInvitationCreateManyCreatorInputEnvelope
    set?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    disconnect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    delete?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    connect?: WorkspaceInvitationWhereUniqueInput | WorkspaceInvitationWhereUniqueInput[]
    update?: WorkspaceInvitationUpdateWithWhereUniqueWithoutCreatorInput | WorkspaceInvitationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WorkspaceInvitationUpdateManyWithWhereWithoutCreatorInput | WorkspaceInvitationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput> | TaskAssigneeCreateWithoutUserInput[] | TaskAssigneeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutUserInput | TaskAssigneeCreateOrConnectWithoutUserInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutUserInput | TaskAssigneeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskAssigneeCreateManyUserInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutUserInput | TaskAssigneeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutUserInput | TaskAssigneeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput> | SubtaskCreateWithoutAssigneeInput[] | SubtaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssigneeInput | SubtaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutAssigneeInput | SubtaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: SubtaskCreateManyAssigneeInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutAssigneeInput | SubtaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutAssigneeInput | SubtaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RememberTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RememberTokenCreateWithoutUserInput, RememberTokenUncheckedCreateWithoutUserInput> | RememberTokenCreateWithoutUserInput[] | RememberTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RememberTokenCreateOrConnectWithoutUserInput | RememberTokenCreateOrConnectWithoutUserInput[]
    upsert?: RememberTokenUpsertWithWhereUniqueWithoutUserInput | RememberTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RememberTokenCreateManyUserInputEnvelope
    set?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    disconnect?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    delete?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    connect?: RememberTokenWhereUniqueInput | RememberTokenWhereUniqueInput[]
    update?: RememberTokenUpdateWithWhereUniqueWithoutUserInput | RememberTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RememberTokenUpdateManyWithWhereWithoutUserInput | RememberTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RememberTokenScalarWhereInput | RememberTokenScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type LastLoginUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LastLoginCreateWithoutUserInput, LastLoginUncheckedCreateWithoutUserInput> | LastLoginCreateWithoutUserInput[] | LastLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LastLoginCreateOrConnectWithoutUserInput | LastLoginCreateOrConnectWithoutUserInput[]
    upsert?: LastLoginUpsertWithWhereUniqueWithoutUserInput | LastLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LastLoginCreateManyUserInputEnvelope
    set?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    disconnect?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    delete?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    connect?: LastLoginWhereUniqueInput | LastLoginWhereUniqueInput[]
    update?: LastLoginUpdateWithWhereUniqueWithoutUserInput | LastLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LastLoginUpdateManyWithWhereWithoutUserInput | LastLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LastLoginScalarWhereInput | LastLoginScalarWhereInput[]
  }

  export type UserMetadataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMetadataCreateWithoutUserInput, UserMetadataUncheckedCreateWithoutUserInput> | UserMetadataCreateWithoutUserInput[] | UserMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetadataCreateOrConnectWithoutUserInput | UserMetadataCreateOrConnectWithoutUserInput[]
    upsert?: UserMetadataUpsertWithWhereUniqueWithoutUserInput | UserMetadataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMetadataCreateManyUserInputEnvelope
    set?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    disconnect?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    delete?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    connect?: UserMetadataWhereUniqueInput | UserMetadataWhereUniqueInput[]
    update?: UserMetadataUpdateWithWhereUniqueWithoutUserInput | UserMetadataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMetadataUpdateManyWithWhereWithoutUserInput | UserMetadataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMetadataScalarWhereInput | UserMetadataScalarWhereInput[]
  }

  export type UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNotificationSettingCreateWithoutUserInput, UserNotificationSettingUncheckedCreateWithoutUserInput> | UserNotificationSettingCreateWithoutUserInput[] | UserNotificationSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationSettingCreateOrConnectWithoutUserInput | UserNotificationSettingCreateOrConnectWithoutUserInput[]
    upsert?: UserNotificationSettingUpsertWithWhereUniqueWithoutUserInput | UserNotificationSettingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNotificationSettingCreateManyUserInputEnvelope
    set?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    disconnect?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    delete?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    connect?: UserNotificationSettingWhereUniqueInput | UserNotificationSettingWhereUniqueInput[]
    update?: UserNotificationSettingUpdateWithWhereUniqueWithoutUserInput | UserNotificationSettingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNotificationSettingUpdateManyWithWhereWithoutUserInput | UserNotificationSettingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNotificationSettingScalarWhereInput | UserNotificationSettingScalarWhereInput[]
  }

  export type UserAvatarUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAvatarCreateWithoutUserInput, UserAvatarUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAvatarCreateOrConnectWithoutUserInput
    upsert?: UserAvatarUpsertWithoutUserInput
    disconnect?: UserAvatarWhereInput | boolean
    delete?: UserAvatarWhereInput | boolean
    connect?: UserAvatarWhereUniqueInput
    update?: XOR<XOR<UserAvatarUpdateToOneWithWhereWithoutUserInput, UserAvatarUpdateWithoutUserInput>, UserAvatarUncheckedUpdateWithoutUserInput>
  }

  export type InviteUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<InviteCreateWithoutInvitedByInput, InviteUncheckedCreateWithoutInvitedByInput> | InviteCreateWithoutInvitedByInput[] | InviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInvitedByInput | InviteCreateOrConnectWithoutInvitedByInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutInvitedByInput | InviteUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: InviteCreateManyInvitedByInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutInvitedByInput | InviteUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutInvitedByInput | InviteUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<GroupMemberCreateWithoutAddedByInput, GroupMemberUncheckedCreateWithoutAddedByInput> | GroupMemberCreateWithoutAddedByInput[] | GroupMemberUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutAddedByInput | GroupMemberCreateOrConnectWithoutAddedByInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutAddedByInput | GroupMemberUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: GroupMemberCreateManyAddedByInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutAddedByInput | GroupMemberUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutAddedByInput | GroupMemberUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutRememberTokensInput = {
    create?: XOR<UserCreateWithoutRememberTokensInput, UserUncheckedCreateWithoutRememberTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRememberTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRememberTokensNestedInput = {
    create?: XOR<UserCreateWithoutRememberTokensInput, UserUncheckedCreateWithoutRememberTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRememberTokensInput
    upsert?: UserUpsertWithoutRememberTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRememberTokensInput, UserUpdateWithoutRememberTokensInput>, UserUncheckedUpdateWithoutRememberTokensInput>
  }

  export type UserCreateNestedOneWithoutInvitesSentInput = {
    create?: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInvitesSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesSentInput
    upsert?: UserUpsertWithoutInvitesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitesSentInput, UserUpdateWithoutInvitesSentInput>, UserUncheckedUpdateWithoutInvitesSentInput>
  }

  export type WorkspaceCreateNestedOneWithoutProjectsInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ColumnCreateNestedManyWithoutProjectInput = {
    create?: XOR<ColumnCreateWithoutProjectInput, ColumnUncheckedCreateWithoutProjectInput> | ColumnCreateWithoutProjectInput[] | ColumnUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutProjectInput | ColumnCreateOrConnectWithoutProjectInput[]
    createMany?: ColumnCreateManyProjectInputEnvelope
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
  }

  export type SwimlaneCreateNestedManyWithoutProjectInput = {
    create?: XOR<SwimlaneCreateWithoutProjectInput, SwimlaneUncheckedCreateWithoutProjectInput> | SwimlaneCreateWithoutProjectInput[] | SwimlaneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SwimlaneCreateOrConnectWithoutProjectInput | SwimlaneCreateOrConnectWithoutProjectInput[]
    createMany?: SwimlaneCreateManyProjectInputEnvelope
    connect?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutProjectInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutProjectInput = {
    create?: XOR<CategoryCreateWithoutProjectInput, CategoryUncheckedCreateWithoutProjectInput> | CategoryCreateWithoutProjectInput[] | CategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectInput | CategoryCreateOrConnectWithoutProjectInput[]
    createMany?: CategoryCreateManyProjectInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CustomFieldCreateNestedManyWithoutProjectInput = {
    create?: XOR<CustomFieldCreateWithoutProjectInput, CustomFieldUncheckedCreateWithoutProjectInput> | CustomFieldCreateWithoutProjectInput[] | CustomFieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutProjectInput | CustomFieldCreateOrConnectWithoutProjectInput[]
    createMany?: CustomFieldCreateManyProjectInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModuleCreateWithoutProjectInput, ModuleUncheckedCreateWithoutProjectInput> | ModuleCreateWithoutProjectInput[] | ModuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProjectInput | ModuleCreateOrConnectWithoutProjectInput[]
    createMany?: ModuleCreateManyProjectInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type SprintCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutProjectInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput> | BudgetCreateWithoutProjectInput[] | BudgetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput | BudgetCreateOrConnectWithoutProjectInput[]
    createMany?: BudgetCreateManyProjectInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type WikiPageCreateNestedManyWithoutProjectInput = {
    create?: XOR<WikiPageCreateWithoutProjectInput, WikiPageUncheckedCreateWithoutProjectInput> | WikiPageCreateWithoutProjectInput[] | WikiPageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutProjectInput | WikiPageCreateOrConnectWithoutProjectInput[]
    createMany?: WikiPageCreateManyProjectInputEnvelope
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProjectGroupMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectInput, ProjectGroupMemberUncheckedCreateWithoutProjectInput> | ProjectGroupMemberCreateWithoutProjectInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectInput | ProjectGroupMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectGroupMemberCreateManyProjectInputEnvelope
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutProjectInput = {
    create?: XOR<WebhookCreateWithoutProjectInput, WebhookUncheckedCreateWithoutProjectInput> | WebhookCreateWithoutProjectInput[] | WebhookUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutProjectInput | WebhookCreateOrConnectWithoutProjectInput[]
    createMany?: WebhookCreateManyProjectInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutProjectInput = {
    create?: XOR<GroupCreateWithoutProjectInput, GroupUncheckedCreateWithoutProjectInput> | GroupCreateWithoutProjectInput[] | GroupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutProjectInput | GroupCreateOrConnectWithoutProjectInput[]
    createMany?: GroupCreateManyProjectInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type RoleAssignmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoleAssignmentCreateWithoutProjectInput, RoleAssignmentUncheckedCreateWithoutProjectInput> | RoleAssignmentCreateWithoutProjectInput[] | RoleAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutProjectInput | RoleAssignmentCreateOrConnectWithoutProjectInput[]
    createMany?: RoleAssignmentCreateManyProjectInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ColumnUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ColumnCreateWithoutProjectInput, ColumnUncheckedCreateWithoutProjectInput> | ColumnCreateWithoutProjectInput[] | ColumnUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutProjectInput | ColumnCreateOrConnectWithoutProjectInput[]
    createMany?: ColumnCreateManyProjectInputEnvelope
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
  }

  export type SwimlaneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SwimlaneCreateWithoutProjectInput, SwimlaneUncheckedCreateWithoutProjectInput> | SwimlaneCreateWithoutProjectInput[] | SwimlaneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SwimlaneCreateOrConnectWithoutProjectInput | SwimlaneCreateOrConnectWithoutProjectInput[]
    createMany?: SwimlaneCreateManyProjectInputEnvelope
    connect?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CategoryCreateWithoutProjectInput, CategoryUncheckedCreateWithoutProjectInput> | CategoryCreateWithoutProjectInput[] | CategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectInput | CategoryCreateOrConnectWithoutProjectInput[]
    createMany?: CategoryCreateManyProjectInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CustomFieldUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CustomFieldCreateWithoutProjectInput, CustomFieldUncheckedCreateWithoutProjectInput> | CustomFieldCreateWithoutProjectInput[] | CustomFieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutProjectInput | CustomFieldCreateOrConnectWithoutProjectInput[]
    createMany?: CustomFieldCreateManyProjectInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ModuleCreateWithoutProjectInput, ModuleUncheckedCreateWithoutProjectInput> | ModuleCreateWithoutProjectInput[] | ModuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProjectInput | ModuleCreateOrConnectWithoutProjectInput[]
    createMany?: ModuleCreateManyProjectInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type SprintUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput> | BudgetCreateWithoutProjectInput[] | BudgetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput | BudgetCreateOrConnectWithoutProjectInput[]
    createMany?: BudgetCreateManyProjectInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type WikiPageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WikiPageCreateWithoutProjectInput, WikiPageUncheckedCreateWithoutProjectInput> | WikiPageCreateWithoutProjectInput[] | WikiPageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutProjectInput | WikiPageCreateOrConnectWithoutProjectInput[]
    createMany?: WikiPageCreateManyProjectInputEnvelope
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectInput, ProjectGroupMemberUncheckedCreateWithoutProjectInput> | ProjectGroupMemberCreateWithoutProjectInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectInput | ProjectGroupMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectGroupMemberCreateManyProjectInputEnvelope
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WebhookCreateWithoutProjectInput, WebhookUncheckedCreateWithoutProjectInput> | WebhookCreateWithoutProjectInput[] | WebhookUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutProjectInput | WebhookCreateOrConnectWithoutProjectInput[]
    createMany?: WebhookCreateManyProjectInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<GroupCreateWithoutProjectInput, GroupUncheckedCreateWithoutProjectInput> | GroupCreateWithoutProjectInput[] | GroupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutProjectInput | GroupCreateOrConnectWithoutProjectInput[]
    createMany?: GroupCreateManyProjectInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoleAssignmentCreateWithoutProjectInput, RoleAssignmentUncheckedCreateWithoutProjectInput> | RoleAssignmentCreateWithoutProjectInput[] | RoleAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutProjectInput | RoleAssignmentCreateOrConnectWithoutProjectInput[]
    createMany?: RoleAssignmentCreateManyProjectInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    upsert?: WorkspaceUpsertWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutProjectsInput, WorkspaceUpdateWithoutProjectsInput>, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ColumnUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ColumnCreateWithoutProjectInput, ColumnUncheckedCreateWithoutProjectInput> | ColumnCreateWithoutProjectInput[] | ColumnUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutProjectInput | ColumnCreateOrConnectWithoutProjectInput[]
    upsert?: ColumnUpsertWithWhereUniqueWithoutProjectInput | ColumnUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ColumnCreateManyProjectInputEnvelope
    set?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    disconnect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    delete?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    update?: ColumnUpdateWithWhereUniqueWithoutProjectInput | ColumnUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ColumnUpdateManyWithWhereWithoutProjectInput | ColumnUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
  }

  export type SwimlaneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SwimlaneCreateWithoutProjectInput, SwimlaneUncheckedCreateWithoutProjectInput> | SwimlaneCreateWithoutProjectInput[] | SwimlaneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SwimlaneCreateOrConnectWithoutProjectInput | SwimlaneCreateOrConnectWithoutProjectInput[]
    upsert?: SwimlaneUpsertWithWhereUniqueWithoutProjectInput | SwimlaneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SwimlaneCreateManyProjectInputEnvelope
    set?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    disconnect?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    delete?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    connect?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    update?: SwimlaneUpdateWithWhereUniqueWithoutProjectInput | SwimlaneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SwimlaneUpdateManyWithWhereWithoutProjectInput | SwimlaneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SwimlaneScalarWhereInput | SwimlaneScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TagUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutProjectInput | TagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutProjectInput | TagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TagUpdateManyWithWhereWithoutProjectInput | TagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CategoryCreateWithoutProjectInput, CategoryUncheckedCreateWithoutProjectInput> | CategoryCreateWithoutProjectInput[] | CategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectInput | CategoryCreateOrConnectWithoutProjectInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProjectInput | CategoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CategoryCreateManyProjectInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProjectInput | CategoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProjectInput | CategoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CustomFieldUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CustomFieldCreateWithoutProjectInput, CustomFieldUncheckedCreateWithoutProjectInput> | CustomFieldCreateWithoutProjectInput[] | CustomFieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutProjectInput | CustomFieldCreateOrConnectWithoutProjectInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutProjectInput | CustomFieldUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CustomFieldCreateManyProjectInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutProjectInput | CustomFieldUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutProjectInput | CustomFieldUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModuleCreateWithoutProjectInput, ModuleUncheckedCreateWithoutProjectInput> | ModuleCreateWithoutProjectInput[] | ModuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProjectInput | ModuleCreateOrConnectWithoutProjectInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutProjectInput | ModuleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModuleCreateManyProjectInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutProjectInput | ModuleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutProjectInput | ModuleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type SprintUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput> | BudgetCreateWithoutProjectInput[] | BudgetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput | BudgetCreateOrConnectWithoutProjectInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutProjectInput | BudgetUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BudgetCreateManyProjectInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutProjectInput | BudgetUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutProjectInput | BudgetUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type WikiPageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WikiPageCreateWithoutProjectInput, WikiPageUncheckedCreateWithoutProjectInput> | WikiPageCreateWithoutProjectInput[] | WikiPageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutProjectInput | WikiPageCreateOrConnectWithoutProjectInput[]
    upsert?: WikiPageUpsertWithWhereUniqueWithoutProjectInput | WikiPageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WikiPageCreateManyProjectInputEnvelope
    set?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    disconnect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    delete?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    update?: WikiPageUpdateWithWhereUniqueWithoutProjectInput | WikiPageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WikiPageUpdateManyWithWhereWithoutProjectInput | WikiPageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProjectInput | ActivityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProjectInput | ActivityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProjectInput | ActivityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProjectGroupMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectInput, ProjectGroupMemberUncheckedCreateWithoutProjectInput> | ProjectGroupMemberCreateWithoutProjectInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectInput | ProjectGroupMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectGroupMemberCreateManyProjectInputEnvelope
    set?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    disconnect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    delete?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    update?: ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectGroupMemberUpdateManyWithWhereWithoutProjectInput | ProjectGroupMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectGroupMemberScalarWhereInput | ProjectGroupMemberScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WebhookCreateWithoutProjectInput, WebhookUncheckedCreateWithoutProjectInput> | WebhookCreateWithoutProjectInput[] | WebhookUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutProjectInput | WebhookCreateOrConnectWithoutProjectInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutProjectInput | WebhookUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WebhookCreateManyProjectInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutProjectInput | WebhookUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutProjectInput | WebhookUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutProjectNestedInput = {
    create?: XOR<GroupCreateWithoutProjectInput, GroupUncheckedCreateWithoutProjectInput> | GroupCreateWithoutProjectInput[] | GroupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutProjectInput | GroupCreateOrConnectWithoutProjectInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutProjectInput | GroupUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: GroupCreateManyProjectInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutProjectInput | GroupUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutProjectInput | GroupUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type RoleAssignmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutProjectInput, RoleAssignmentUncheckedCreateWithoutProjectInput> | RoleAssignmentCreateWithoutProjectInput[] | RoleAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutProjectInput | RoleAssignmentCreateOrConnectWithoutProjectInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutProjectInput | RoleAssignmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoleAssignmentCreateManyProjectInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutProjectInput | RoleAssignmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutProjectInput | RoleAssignmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ColumnUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ColumnCreateWithoutProjectInput, ColumnUncheckedCreateWithoutProjectInput> | ColumnCreateWithoutProjectInput[] | ColumnUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ColumnCreateOrConnectWithoutProjectInput | ColumnCreateOrConnectWithoutProjectInput[]
    upsert?: ColumnUpsertWithWhereUniqueWithoutProjectInput | ColumnUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ColumnCreateManyProjectInputEnvelope
    set?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    disconnect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    delete?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    connect?: ColumnWhereUniqueInput | ColumnWhereUniqueInput[]
    update?: ColumnUpdateWithWhereUniqueWithoutProjectInput | ColumnUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ColumnUpdateManyWithWhereWithoutProjectInput | ColumnUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
  }

  export type SwimlaneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SwimlaneCreateWithoutProjectInput, SwimlaneUncheckedCreateWithoutProjectInput> | SwimlaneCreateWithoutProjectInput[] | SwimlaneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SwimlaneCreateOrConnectWithoutProjectInput | SwimlaneCreateOrConnectWithoutProjectInput[]
    upsert?: SwimlaneUpsertWithWhereUniqueWithoutProjectInput | SwimlaneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SwimlaneCreateManyProjectInputEnvelope
    set?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    disconnect?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    delete?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    connect?: SwimlaneWhereUniqueInput | SwimlaneWhereUniqueInput[]
    update?: SwimlaneUpdateWithWhereUniqueWithoutProjectInput | SwimlaneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SwimlaneUpdateManyWithWhereWithoutProjectInput | SwimlaneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SwimlaneScalarWhereInput | SwimlaneScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput> | TagCreateWithoutProjectInput[] | TagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TagCreateOrConnectWithoutProjectInput | TagCreateOrConnectWithoutProjectInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutProjectInput | TagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TagCreateManyProjectInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutProjectInput | TagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TagUpdateManyWithWhereWithoutProjectInput | TagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CategoryCreateWithoutProjectInput, CategoryUncheckedCreateWithoutProjectInput> | CategoryCreateWithoutProjectInput[] | CategoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectInput | CategoryCreateOrConnectWithoutProjectInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutProjectInput | CategoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CategoryCreateManyProjectInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutProjectInput | CategoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutProjectInput | CategoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CustomFieldUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CustomFieldCreateWithoutProjectInput, CustomFieldUncheckedCreateWithoutProjectInput> | CustomFieldCreateWithoutProjectInput[] | CustomFieldUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutProjectInput | CustomFieldCreateOrConnectWithoutProjectInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutProjectInput | CustomFieldUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CustomFieldCreateManyProjectInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutProjectInput | CustomFieldUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutProjectInput | CustomFieldUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ModuleCreateWithoutProjectInput, ModuleUncheckedCreateWithoutProjectInput> | ModuleCreateWithoutProjectInput[] | ModuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProjectInput | ModuleCreateOrConnectWithoutProjectInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutProjectInput | ModuleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ModuleCreateManyProjectInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutProjectInput | ModuleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutProjectInput | ModuleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type SprintUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput> | BudgetCreateWithoutProjectInput[] | BudgetUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput | BudgetCreateOrConnectWithoutProjectInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutProjectInput | BudgetUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BudgetCreateManyProjectInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutProjectInput | BudgetUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutProjectInput | BudgetUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type WikiPageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WikiPageCreateWithoutProjectInput, WikiPageUncheckedCreateWithoutProjectInput> | WikiPageCreateWithoutProjectInput[] | WikiPageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WikiPageCreateOrConnectWithoutProjectInput | WikiPageCreateOrConnectWithoutProjectInput[]
    upsert?: WikiPageUpsertWithWhereUniqueWithoutProjectInput | WikiPageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WikiPageCreateManyProjectInputEnvelope
    set?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    disconnect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    delete?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    connect?: WikiPageWhereUniqueInput | WikiPageWhereUniqueInput[]
    update?: WikiPageUpdateWithWhereUniqueWithoutProjectInput | WikiPageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WikiPageUpdateManyWithWhereWithoutProjectInput | WikiPageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProjectInput | ActivityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProjectInput | ActivityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProjectInput | ActivityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectInput, ProjectGroupMemberUncheckedCreateWithoutProjectInput> | ProjectGroupMemberCreateWithoutProjectInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectInput | ProjectGroupMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectGroupMemberCreateManyProjectInputEnvelope
    set?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    disconnect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    delete?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    update?: ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectGroupMemberUpdateManyWithWhereWithoutProjectInput | ProjectGroupMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectGroupMemberScalarWhereInput | ProjectGroupMemberScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WebhookCreateWithoutProjectInput, WebhookUncheckedCreateWithoutProjectInput> | WebhookCreateWithoutProjectInput[] | WebhookUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutProjectInput | WebhookCreateOrConnectWithoutProjectInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutProjectInput | WebhookUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WebhookCreateManyProjectInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutProjectInput | WebhookUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutProjectInput | WebhookUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<GroupCreateWithoutProjectInput, GroupUncheckedCreateWithoutProjectInput> | GroupCreateWithoutProjectInput[] | GroupUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutProjectInput | GroupCreateOrConnectWithoutProjectInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutProjectInput | GroupUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: GroupCreateManyProjectInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutProjectInput | GroupUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutProjectInput | GroupUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutProjectInput, RoleAssignmentUncheckedCreateWithoutProjectInput> | RoleAssignmentCreateWithoutProjectInput[] | RoleAssignmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutProjectInput | RoleAssignmentCreateOrConnectWithoutProjectInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutProjectInput | RoleAssignmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoleAssignmentCreateManyProjectInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutProjectInput | RoleAssignmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutProjectInput | RoleAssignmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectRole
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    upsert?: UserUpsertWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembersInput, UserUpdateWithoutProjectMembersInput>, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectCreateNestedOneWithoutColumnsInput = {
    create?: XOR<ProjectCreateWithoutColumnsInput, ProjectUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutColumnsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutColumnInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutColumnInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutColumnsNestedInput = {
    create?: XOR<ProjectCreateWithoutColumnsInput, ProjectUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutColumnsInput
    upsert?: ProjectUpsertWithoutColumnsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutColumnsInput, ProjectUpdateWithoutColumnsInput>, ProjectUncheckedUpdateWithoutColumnsInput>
  }

  export type TaskUpdateManyWithoutColumnNestedInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutColumnInput | TaskUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutColumnInput | TaskUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutColumnInput | TaskUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutColumnNestedInput = {
    create?: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput> | TaskCreateWithoutColumnInput[] | TaskUncheckedCreateWithoutColumnInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutColumnInput | TaskCreateOrConnectWithoutColumnInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutColumnInput | TaskUpsertWithWhereUniqueWithoutColumnInput[]
    createMany?: TaskCreateManyColumnInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutColumnInput | TaskUpdateWithWhereUniqueWithoutColumnInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutColumnInput | TaskUpdateManyWithWhereWithoutColumnInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutSwimlanesInput = {
    create?: XOR<ProjectCreateWithoutSwimlanesInput, ProjectUncheckedCreateWithoutSwimlanesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSwimlanesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutSwimlaneInput = {
    create?: XOR<TaskCreateWithoutSwimlaneInput, TaskUncheckedCreateWithoutSwimlaneInput> | TaskCreateWithoutSwimlaneInput[] | TaskUncheckedCreateWithoutSwimlaneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSwimlaneInput | TaskCreateOrConnectWithoutSwimlaneInput[]
    createMany?: TaskCreateManySwimlaneInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutSwimlaneInput = {
    create?: XOR<TaskCreateWithoutSwimlaneInput, TaskUncheckedCreateWithoutSwimlaneInput> | TaskCreateWithoutSwimlaneInput[] | TaskUncheckedCreateWithoutSwimlaneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSwimlaneInput | TaskCreateOrConnectWithoutSwimlaneInput[]
    createMany?: TaskCreateManySwimlaneInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSwimlanesNestedInput = {
    create?: XOR<ProjectCreateWithoutSwimlanesInput, ProjectUncheckedCreateWithoutSwimlanesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSwimlanesInput
    upsert?: ProjectUpsertWithoutSwimlanesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSwimlanesInput, ProjectUpdateWithoutSwimlanesInput>, ProjectUncheckedUpdateWithoutSwimlanesInput>
  }

  export type TaskUpdateManyWithoutSwimlaneNestedInput = {
    create?: XOR<TaskCreateWithoutSwimlaneInput, TaskUncheckedCreateWithoutSwimlaneInput> | TaskCreateWithoutSwimlaneInput[] | TaskUncheckedCreateWithoutSwimlaneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSwimlaneInput | TaskCreateOrConnectWithoutSwimlaneInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSwimlaneInput | TaskUpsertWithWhereUniqueWithoutSwimlaneInput[]
    createMany?: TaskCreateManySwimlaneInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSwimlaneInput | TaskUpdateWithWhereUniqueWithoutSwimlaneInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSwimlaneInput | TaskUpdateManyWithWhereWithoutSwimlaneInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutSwimlaneNestedInput = {
    create?: XOR<TaskCreateWithoutSwimlaneInput, TaskUncheckedCreateWithoutSwimlaneInput> | TaskCreateWithoutSwimlaneInput[] | TaskUncheckedCreateWithoutSwimlaneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSwimlaneInput | TaskCreateOrConnectWithoutSwimlaneInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSwimlaneInput | TaskUpsertWithWhereUniqueWithoutSwimlaneInput[]
    createMany?: TaskCreateManySwimlaneInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSwimlaneInput | TaskUpdateWithWhereUniqueWithoutSwimlaneInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSwimlaneInput | TaskUpdateManyWithWhereWithoutSwimlaneInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type ColumnCreateNestedOneWithoutTasksInput = {
    create?: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutTasksInput
    connect?: ColumnWhereUniqueInput
  }

  export type SwimlaneCreateNestedOneWithoutTasksInput = {
    create?: XOR<SwimlaneCreateWithoutTasksInput, SwimlaneUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SwimlaneCreateOrConnectWithoutTasksInput
    connect?: SwimlaneWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type MilestoneCreateNestedOneWithoutTasksInput = {
    create?: XOR<MilestoneCreateWithoutTasksInput, MilestoneUncheckedCreateWithoutTasksInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutTasksInput
    connect?: MilestoneWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutTasksInput = {
    create?: XOR<ModuleCreateWithoutTasksInput, ModuleUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTasksInput
    connect?: ModuleWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutTasksInput = {
    create?: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTasksInput
    connect?: SprintWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTasksInput = {
    create?: XOR<CategoryCreateWithoutTasksInput, CategoryUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTasksInput
    connect?: CategoryWhereUniqueInput
  }

  export type TaskAssigneeCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TaskTagCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type TaskCustomValueCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type TaskLinkCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLinkCreateWithoutTaskInput, TaskLinkUncheckedCreateWithoutTaskInput> | TaskLinkCreateWithoutTaskInput[] | TaskLinkUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutTaskInput | TaskLinkCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLinkCreateManyTaskInputEnvelope
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
  }

  export type TaskLinkCreateNestedManyWithoutOppositeTaskInput = {
    create?: XOR<TaskLinkCreateWithoutOppositeTaskInput, TaskLinkUncheckedCreateWithoutOppositeTaskInput> | TaskLinkCreateWithoutOppositeTaskInput[] | TaskLinkUncheckedCreateWithoutOppositeTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutOppositeTaskInput | TaskLinkCreateOrConnectWithoutOppositeTaskInput[]
    createMany?: TaskLinkCreateManyOppositeTaskInputEnvelope
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
  }

  export type TaskSessionCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskSessionCreateWithoutTaskInput, TaskSessionUncheckedCreateWithoutTaskInput> | TaskSessionCreateWithoutTaskInput[] | TaskSessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskSessionCreateOrConnectWithoutTaskInput | TaskSessionCreateOrConnectWithoutTaskInput[]
    createMany?: TaskSessionCreateManyTaskInputEnvelope
    connect?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TaskTagUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type TaskLinkUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLinkCreateWithoutTaskInput, TaskLinkUncheckedCreateWithoutTaskInput> | TaskLinkCreateWithoutTaskInput[] | TaskLinkUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutTaskInput | TaskLinkCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLinkCreateManyTaskInputEnvelope
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
  }

  export type TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput = {
    create?: XOR<TaskLinkCreateWithoutOppositeTaskInput, TaskLinkUncheckedCreateWithoutOppositeTaskInput> | TaskLinkCreateWithoutOppositeTaskInput[] | TaskLinkUncheckedCreateWithoutOppositeTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutOppositeTaskInput | TaskLinkCreateOrConnectWithoutOppositeTaskInput[]
    createMany?: TaskLinkCreateManyOppositeTaskInputEnvelope
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
  }

  export type TaskSessionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskSessionCreateWithoutTaskInput, TaskSessionUncheckedCreateWithoutTaskInput> | TaskSessionCreateWithoutTaskInput[] | TaskSessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskSessionCreateOrConnectWithoutTaskInput | TaskSessionCreateOrConnectWithoutTaskInput[]
    createMany?: TaskSessionCreateManyTaskInputEnvelope
    connect?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ColumnUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ColumnCreateOrConnectWithoutTasksInput
    upsert?: ColumnUpsertWithoutTasksInput
    connect?: ColumnWhereUniqueInput
    update?: XOR<XOR<ColumnUpdateToOneWithWhereWithoutTasksInput, ColumnUpdateWithoutTasksInput>, ColumnUncheckedUpdateWithoutTasksInput>
  }

  export type SwimlaneUpdateOneWithoutTasksNestedInput = {
    create?: XOR<SwimlaneCreateWithoutTasksInput, SwimlaneUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SwimlaneCreateOrConnectWithoutTasksInput
    upsert?: SwimlaneUpsertWithoutTasksInput
    disconnect?: SwimlaneWhereInput | boolean
    delete?: SwimlaneWhereInput | boolean
    connect?: SwimlaneWhereUniqueInput
    update?: XOR<XOR<SwimlaneUpdateToOneWithWhereWithoutTasksInput, SwimlaneUpdateWithoutTasksInput>, SwimlaneUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneRequiredWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type MilestoneUpdateOneWithoutTasksNestedInput = {
    create?: XOR<MilestoneCreateWithoutTasksInput, MilestoneUncheckedCreateWithoutTasksInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutTasksInput
    upsert?: MilestoneUpsertWithoutTasksInput
    disconnect?: MilestoneWhereInput | boolean
    delete?: MilestoneWhereInput | boolean
    connect?: MilestoneWhereUniqueInput
    update?: XOR<XOR<MilestoneUpdateToOneWithWhereWithoutTasksInput, MilestoneUpdateWithoutTasksInput>, MilestoneUncheckedUpdateWithoutTasksInput>
  }

  export type ModuleUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ModuleCreateWithoutTasksInput, ModuleUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTasksInput
    upsert?: ModuleUpsertWithoutTasksInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutTasksInput, ModuleUpdateWithoutTasksInput>, ModuleUncheckedUpdateWithoutTasksInput>
  }

  export type SprintUpdateOneWithoutTasksNestedInput = {
    create?: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTasksInput
    upsert?: SprintUpsertWithoutTasksInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutTasksInput, SprintUpdateWithoutTasksInput>, SprintUncheckedUpdateWithoutTasksInput>
  }

  export type CategoryUpdateOneWithoutTasksNestedInput = {
    create?: XOR<CategoryCreateWithoutTasksInput, CategoryUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTasksInput
    upsert?: CategoryUpsertWithoutTasksInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTasksInput, CategoryUpdateWithoutTasksInput>, CategoryUncheckedUpdateWithoutTasksInput>
  }

  export type TaskAssigneeUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutTaskInput | SubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutTaskInput | SubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutTaskInput | SubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTaskInput | AttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTaskInput | AttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTaskInput | AttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TaskTagUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTaskInput | TaskTagUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTaskInput | TaskTagUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTaskInput | TaskTagUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskCustomValueUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput | TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput | TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutTaskInput | TaskCustomValueUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type TaskLinkUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLinkCreateWithoutTaskInput, TaskLinkUncheckedCreateWithoutTaskInput> | TaskLinkCreateWithoutTaskInput[] | TaskLinkUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutTaskInput | TaskLinkCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLinkUpsertWithWhereUniqueWithoutTaskInput | TaskLinkUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLinkCreateManyTaskInputEnvelope
    set?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    disconnect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    delete?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    update?: TaskLinkUpdateWithWhereUniqueWithoutTaskInput | TaskLinkUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLinkUpdateManyWithWhereWithoutTaskInput | TaskLinkUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLinkScalarWhereInput | TaskLinkScalarWhereInput[]
  }

  export type TaskLinkUpdateManyWithoutOppositeTaskNestedInput = {
    create?: XOR<TaskLinkCreateWithoutOppositeTaskInput, TaskLinkUncheckedCreateWithoutOppositeTaskInput> | TaskLinkCreateWithoutOppositeTaskInput[] | TaskLinkUncheckedCreateWithoutOppositeTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutOppositeTaskInput | TaskLinkCreateOrConnectWithoutOppositeTaskInput[]
    upsert?: TaskLinkUpsertWithWhereUniqueWithoutOppositeTaskInput | TaskLinkUpsertWithWhereUniqueWithoutOppositeTaskInput[]
    createMany?: TaskLinkCreateManyOppositeTaskInputEnvelope
    set?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    disconnect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    delete?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    update?: TaskLinkUpdateWithWhereUniqueWithoutOppositeTaskInput | TaskLinkUpdateWithWhereUniqueWithoutOppositeTaskInput[]
    updateMany?: TaskLinkUpdateManyWithWhereWithoutOppositeTaskInput | TaskLinkUpdateManyWithWhereWithoutOppositeTaskInput[]
    deleteMany?: TaskLinkScalarWhereInput | TaskLinkScalarWhereInput[]
  }

  export type TaskSessionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskSessionCreateWithoutTaskInput, TaskSessionUncheckedCreateWithoutTaskInput> | TaskSessionCreateWithoutTaskInput[] | TaskSessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskSessionCreateOrConnectWithoutTaskInput | TaskSessionCreateOrConnectWithoutTaskInput[]
    upsert?: TaskSessionUpsertWithWhereUniqueWithoutTaskInput | TaskSessionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskSessionCreateManyTaskInputEnvelope
    set?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    disconnect?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    delete?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    connect?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    update?: TaskSessionUpdateWithWhereUniqueWithoutTaskInput | TaskSessionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskSessionUpdateManyWithWhereWithoutTaskInput | TaskSessionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskSessionScalarWhereInput | TaskSessionScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput> | SubtaskCreateWithoutTaskInput[] | SubtaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTaskInput | SubtaskCreateOrConnectWithoutTaskInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutTaskInput | SubtaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: SubtaskCreateManyTaskInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutTaskInput | SubtaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutTaskInput | SubtaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTaskInput | AttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTaskInput | AttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTaskInput | AttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TaskTagUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput> | TaskTagCreateWithoutTaskInput[] | TaskTagUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTaskInput | TaskTagCreateOrConnectWithoutTaskInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTaskInput | TaskTagUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskTagCreateManyTaskInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTaskInput | TaskTagUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTaskInput | TaskTagUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput | TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput | TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutTaskInput | TaskCustomValueUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type TaskLinkUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLinkCreateWithoutTaskInput, TaskLinkUncheckedCreateWithoutTaskInput> | TaskLinkCreateWithoutTaskInput[] | TaskLinkUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutTaskInput | TaskLinkCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLinkUpsertWithWhereUniqueWithoutTaskInput | TaskLinkUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLinkCreateManyTaskInputEnvelope
    set?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    disconnect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    delete?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    update?: TaskLinkUpdateWithWhereUniqueWithoutTaskInput | TaskLinkUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLinkUpdateManyWithWhereWithoutTaskInput | TaskLinkUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLinkScalarWhereInput | TaskLinkScalarWhereInput[]
  }

  export type TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput = {
    create?: XOR<TaskLinkCreateWithoutOppositeTaskInput, TaskLinkUncheckedCreateWithoutOppositeTaskInput> | TaskLinkCreateWithoutOppositeTaskInput[] | TaskLinkUncheckedCreateWithoutOppositeTaskInput[]
    connectOrCreate?: TaskLinkCreateOrConnectWithoutOppositeTaskInput | TaskLinkCreateOrConnectWithoutOppositeTaskInput[]
    upsert?: TaskLinkUpsertWithWhereUniqueWithoutOppositeTaskInput | TaskLinkUpsertWithWhereUniqueWithoutOppositeTaskInput[]
    createMany?: TaskLinkCreateManyOppositeTaskInputEnvelope
    set?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    disconnect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    delete?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    connect?: TaskLinkWhereUniqueInput | TaskLinkWhereUniqueInput[]
    update?: TaskLinkUpdateWithWhereUniqueWithoutOppositeTaskInput | TaskLinkUpdateWithWhereUniqueWithoutOppositeTaskInput[]
    updateMany?: TaskLinkUpdateManyWithWhereWithoutOppositeTaskInput | TaskLinkUpdateManyWithWhereWithoutOppositeTaskInput[]
    deleteMany?: TaskLinkScalarWhereInput | TaskLinkScalarWhereInput[]
  }

  export type TaskSessionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskSessionCreateWithoutTaskInput, TaskSessionUncheckedCreateWithoutTaskInput> | TaskSessionCreateWithoutTaskInput[] | TaskSessionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskSessionCreateOrConnectWithoutTaskInput | TaskSessionCreateOrConnectWithoutTaskInput[]
    upsert?: TaskSessionUpsertWithWhereUniqueWithoutTaskInput | TaskSessionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskSessionCreateManyTaskInputEnvelope
    set?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    disconnect?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    delete?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    connect?: TaskSessionWhereUniqueInput | TaskSessionWhereUniqueInput[]
    update?: TaskSessionUpdateWithWhereUniqueWithoutTaskInput | TaskSessionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskSessionUpdateManyWithWhereWithoutTaskInput | TaskSessionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskSessionScalarWhereInput | TaskSessionScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutAssigneesInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksAssignedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput
    upsert?: TaskUpsertWithoutAssigneesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAssigneesInput, TaskUpdateWithoutAssigneesInput>, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type UserUpdateOneRequiredWithoutTasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    upsert?: UserUpsertWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksAssignedInput, UserUpdateWithoutTasksAssignedInput>, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type TaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubtasksAssignedInput = {
    create?: XOR<UserCreateWithoutSubtasksAssignedInput, UserUncheckedCreateWithoutSubtasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubtasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubtaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubtaskStatus
  }

  export type TaskUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    upsert?: TaskUpsertWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSubtasksInput, TaskUpdateWithoutSubtasksInput>, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type UserUpdateOneWithoutSubtasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutSubtasksAssignedInput, UserUncheckedCreateWithoutSubtasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubtasksAssignedInput
    upsert?: UserUpsertWithoutSubtasksAssignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubtasksAssignedInput, UserUpdateWithoutSubtasksAssignedInput>, UserUncheckedUpdateWithoutSubtasksAssignedInput>
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type ProjectCreateNestedOneWithoutTagsInput = {
    create?: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskTagCreateNestedManyWithoutTagInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type TaskTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTagsInput
    upsert?: ProjectUpsertWithoutTagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTagsInput, ProjectUpdateWithoutTagsInput>, ProjectUncheckedUpdateWithoutTagsInput>
  }

  export type TaskTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTagInput | TaskTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTagInput | TaskTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTagInput | TaskTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput> | TaskTagCreateWithoutTagInput[] | TaskTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TaskTagCreateOrConnectWithoutTagInput | TaskTagCreateOrConnectWithoutTagInput[]
    upsert?: TaskTagUpsertWithWhereUniqueWithoutTagInput | TaskTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TaskTagCreateManyTagInputEnvelope
    set?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    disconnect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    delete?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    connect?: TaskTagWhereUniqueInput | TaskTagWhereUniqueInput[]
    update?: TaskTagUpdateWithWhereUniqueWithoutTagInput | TaskTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TaskTagUpdateManyWithWhereWithoutTagInput | TaskTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutTagsInput = {
    create?: XOR<TaskCreateWithoutTagsInput, TaskUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTagsInput
    connect?: TaskWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTasksInput = {
    create?: XOR<TagCreateWithoutTasksInput, TagUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TagCreateOrConnectWithoutTasksInput
    connect?: TagWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<TaskCreateWithoutTagsInput, TaskUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTagsInput
    upsert?: TaskUpsertWithoutTagsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTagsInput, TaskUpdateWithoutTagsInput>, TaskUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<TagCreateWithoutTasksInput, TagUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TagCreateOrConnectWithoutTasksInput
    upsert?: TagUpsertWithoutTasksInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTasksInput, TagUpdateWithoutTasksInput>, TagUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TaskCreateWithoutCategoryInput, TaskUncheckedCreateWithoutCategoryInput> | TaskCreateWithoutCategoryInput[] | TaskUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCategoryInput | TaskCreateOrConnectWithoutCategoryInput[]
    createMany?: TaskCreateManyCategoryInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TaskCreateWithoutCategoryInput, TaskUncheckedCreateWithoutCategoryInput> | TaskCreateWithoutCategoryInput[] | TaskUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCategoryInput | TaskCreateOrConnectWithoutCategoryInput[]
    createMany?: TaskCreateManyCategoryInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoriesInput
    upsert?: ProjectUpsertWithoutCategoriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCategoriesInput, ProjectUpdateWithoutCategoriesInput>, ProjectUncheckedUpdateWithoutCategoriesInput>
  }

  export type TaskUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TaskCreateWithoutCategoryInput, TaskUncheckedCreateWithoutCategoryInput> | TaskCreateWithoutCategoryInput[] | TaskUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCategoryInput | TaskCreateOrConnectWithoutCategoryInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCategoryInput | TaskUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TaskCreateManyCategoryInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCategoryInput | TaskUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCategoryInput | TaskUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TaskCreateWithoutCategoryInput, TaskUncheckedCreateWithoutCategoryInput> | TaskCreateWithoutCategoryInput[] | TaskUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCategoryInput | TaskCreateOrConnectWithoutCategoryInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCategoryInput | TaskUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TaskCreateManyCategoryInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCategoryInput | TaskUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCategoryInput | TaskUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskUpsertWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAttachmentsInput, TaskUpdateWithoutAttachmentsInput>, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentsInput
    upsert?: UserUpsertWithoutAttachmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttachmentsInput, UserUpdateWithoutAttachmentsInput>, UserUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskCreateNestedOneWithoutLinksFromInput = {
    create?: XOR<TaskCreateWithoutLinksFromInput, TaskUncheckedCreateWithoutLinksFromInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLinksFromInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutLinksToInput = {
    create?: XOR<TaskCreateWithoutLinksToInput, TaskUncheckedCreateWithoutLinksToInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLinksToInput
    connect?: TaskWhereUniqueInput
  }

  export type EnumTaskLinkTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskLinkType
  }

  export type TaskUpdateOneRequiredWithoutLinksFromNestedInput = {
    create?: XOR<TaskCreateWithoutLinksFromInput, TaskUncheckedCreateWithoutLinksFromInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLinksFromInput
    upsert?: TaskUpsertWithoutLinksFromInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutLinksFromInput, TaskUpdateWithoutLinksFromInput>, TaskUncheckedUpdateWithoutLinksFromInput>
  }

  export type TaskUpdateOneRequiredWithoutLinksToNestedInput = {
    create?: XOR<TaskCreateWithoutLinksToInput, TaskUncheckedCreateWithoutLinksToInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLinksToInput
    upsert?: TaskUpsertWithoutLinksToInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutLinksToInput, TaskUpdateWithoutLinksToInput>, TaskUncheckedUpdateWithoutLinksToInput>
  }

  export type ProjectCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<ProjectCreateWithoutCustomFieldsInput, ProjectUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomFieldsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCustomValueCreateNestedManyWithoutCustomFieldInput = {
    create?: XOR<TaskCustomValueCreateWithoutCustomFieldInput, TaskCustomValueUncheckedCreateWithoutCustomFieldInput> | TaskCustomValueCreateWithoutCustomFieldInput[] | TaskCustomValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutCustomFieldInput | TaskCustomValueCreateOrConnectWithoutCustomFieldInput[]
    createMany?: TaskCustomValueCreateManyCustomFieldInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type TaskCustomValueUncheckedCreateNestedManyWithoutCustomFieldInput = {
    create?: XOR<TaskCustomValueCreateWithoutCustomFieldInput, TaskCustomValueUncheckedCreateWithoutCustomFieldInput> | TaskCustomValueCreateWithoutCustomFieldInput[] | TaskCustomValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutCustomFieldInput | TaskCustomValueCreateOrConnectWithoutCustomFieldInput[]
    createMany?: TaskCustomValueCreateManyCustomFieldInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type EnumCustomFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomFieldType
  }

  export type ProjectUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomFieldsInput, ProjectUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomFieldsInput
    upsert?: ProjectUpsertWithoutCustomFieldsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCustomFieldsInput, ProjectUpdateWithoutCustomFieldsInput>, ProjectUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type TaskCustomValueUpdateManyWithoutCustomFieldNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutCustomFieldInput, TaskCustomValueUncheckedCreateWithoutCustomFieldInput> | TaskCustomValueCreateWithoutCustomFieldInput[] | TaskCustomValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutCustomFieldInput | TaskCustomValueCreateOrConnectWithoutCustomFieldInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutCustomFieldInput | TaskCustomValueUpsertWithWhereUniqueWithoutCustomFieldInput[]
    createMany?: TaskCustomValueCreateManyCustomFieldInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutCustomFieldInput | TaskCustomValueUpdateWithWhereUniqueWithoutCustomFieldInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutCustomFieldInput | TaskCustomValueUpdateManyWithWhereWithoutCustomFieldInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutCustomFieldNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutCustomFieldInput, TaskCustomValueUncheckedCreateWithoutCustomFieldInput> | TaskCustomValueCreateWithoutCustomFieldInput[] | TaskCustomValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutCustomFieldInput | TaskCustomValueCreateOrConnectWithoutCustomFieldInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutCustomFieldInput | TaskCustomValueUpsertWithWhereUniqueWithoutCustomFieldInput[]
    createMany?: TaskCustomValueCreateManyCustomFieldInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutCustomFieldInput | TaskCustomValueUpdateWithWhereUniqueWithoutCustomFieldInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutCustomFieldInput | TaskCustomValueUpdateManyWithWhereWithoutCustomFieldInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutCustomValuesInput = {
    create?: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCustomValuesInput
    connect?: TaskWhereUniqueInput
  }

  export type CustomFieldCreateNestedOneWithoutValuesInput = {
    create?: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutValuesInput
    connect?: CustomFieldWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCustomValuesNestedInput = {
    create?: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCustomValuesInput
    upsert?: TaskUpsertWithoutCustomValuesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCustomValuesInput, TaskUpdateWithoutCustomValuesInput>, TaskUncheckedUpdateWithoutCustomValuesInput>
  }

  export type CustomFieldUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutValuesInput
    upsert?: CustomFieldUpsertWithoutValuesInput
    connect?: CustomFieldWhereUniqueInput
    update?: XOR<XOR<CustomFieldUpdateToOneWithWhereWithoutValuesInput, CustomFieldUpdateWithoutValuesInput>, CustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type ProjectCreateNestedOneWithoutSprintsInput = {
    create?: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutSprintInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumSprintStatusFieldUpdateOperationsInput = {
    set?: $Enums.SprintStatus
  }

  export type ProjectUpdateOneRequiredWithoutSprintsNestedInput = {
    create?: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintsInput
    upsert?: ProjectUpsertWithoutSprintsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSprintsInput, ProjectUpdateWithoutSprintsInput>, ProjectUncheckedUpdateWithoutSprintsInput>
  }

  export type TaskUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSprintInput | TaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSprintInput | TaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSprintInput | TaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSprintInput | TaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSprintInput | TaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSprintInput | TaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutModulesInput = {
    create?: XOR<ProjectCreateWithoutModulesInput, ProjectUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModulesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutModuleInput = {
    create?: XOR<TaskCreateWithoutModuleInput, TaskUncheckedCreateWithoutModuleInput> | TaskCreateWithoutModuleInput[] | TaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutModuleInput | TaskCreateOrConnectWithoutModuleInput[]
    createMany?: TaskCreateManyModuleInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<TaskCreateWithoutModuleInput, TaskUncheckedCreateWithoutModuleInput> | TaskCreateWithoutModuleInput[] | TaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutModuleInput | TaskCreateOrConnectWithoutModuleInput[]
    createMany?: TaskCreateManyModuleInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ProjectCreateWithoutModulesInput, ProjectUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutModulesInput
    upsert?: ProjectUpsertWithoutModulesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutModulesInput, ProjectUpdateWithoutModulesInput>, ProjectUncheckedUpdateWithoutModulesInput>
  }

  export type TaskUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TaskCreateWithoutModuleInput, TaskUncheckedCreateWithoutModuleInput> | TaskCreateWithoutModuleInput[] | TaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutModuleInput | TaskCreateOrConnectWithoutModuleInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutModuleInput | TaskUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TaskCreateManyModuleInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutModuleInput | TaskUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutModuleInput | TaskUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TaskCreateWithoutModuleInput, TaskUncheckedCreateWithoutModuleInput> | TaskCreateWithoutModuleInput[] | TaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutModuleInput | TaskCreateOrConnectWithoutModuleInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutModuleInput | TaskUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TaskCreateManyModuleInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutModuleInput | TaskUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutModuleInput | TaskUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<TaskCreateWithoutMilestoneInput, TaskUncheckedCreateWithoutMilestoneInput> | TaskCreateWithoutMilestoneInput[] | TaskUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMilestoneInput | TaskCreateOrConnectWithoutMilestoneInput[]
    createMany?: TaskCreateManyMilestoneInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<TaskCreateWithoutMilestoneInput, TaskUncheckedCreateWithoutMilestoneInput> | TaskCreateWithoutMilestoneInput[] | TaskUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMilestoneInput | TaskCreateOrConnectWithoutMilestoneInput[]
    createMany?: TaskCreateManyMilestoneInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    upsert?: ProjectUpsertWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMilestonesInput, ProjectUpdateWithoutMilestonesInput>, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type TaskUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<TaskCreateWithoutMilestoneInput, TaskUncheckedCreateWithoutMilestoneInput> | TaskCreateWithoutMilestoneInput[] | TaskUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMilestoneInput | TaskCreateOrConnectWithoutMilestoneInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutMilestoneInput | TaskUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: TaskCreateManyMilestoneInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutMilestoneInput | TaskUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutMilestoneInput | TaskUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<TaskCreateWithoutMilestoneInput, TaskUncheckedCreateWithoutMilestoneInput> | TaskCreateWithoutMilestoneInput[] | TaskUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutMilestoneInput | TaskCreateOrConnectWithoutMilestoneInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutMilestoneInput | TaskUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: TaskCreateManyMilestoneInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutMilestoneInput | TaskUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutMilestoneInput | TaskUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type StickyNoteLinkCreateNestedManyWithoutStickyNoteInput = {
    create?: XOR<StickyNoteLinkCreateWithoutStickyNoteInput, StickyNoteLinkUncheckedCreateWithoutStickyNoteInput> | StickyNoteLinkCreateWithoutStickyNoteInput[] | StickyNoteLinkUncheckedCreateWithoutStickyNoteInput[]
    connectOrCreate?: StickyNoteLinkCreateOrConnectWithoutStickyNoteInput | StickyNoteLinkCreateOrConnectWithoutStickyNoteInput[]
    createMany?: StickyNoteLinkCreateManyStickyNoteInputEnvelope
    connect?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
  }

  export type StickyNoteLinkUncheckedCreateNestedManyWithoutStickyNoteInput = {
    create?: XOR<StickyNoteLinkCreateWithoutStickyNoteInput, StickyNoteLinkUncheckedCreateWithoutStickyNoteInput> | StickyNoteLinkCreateWithoutStickyNoteInput[] | StickyNoteLinkUncheckedCreateWithoutStickyNoteInput[]
    connectOrCreate?: StickyNoteLinkCreateOrConnectWithoutStickyNoteInput | StickyNoteLinkCreateOrConnectWithoutStickyNoteInput[]
    createMany?: StickyNoteLinkCreateManyStickyNoteInputEnvelope
    connect?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
  }

  export type EnumStickyNoteColorFieldUpdateOperationsInput = {
    set?: $Enums.StickyNoteColor
  }

  export type EnumStickyVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.StickyVisibility
  }

  export type StickyNoteLinkUpdateManyWithoutStickyNoteNestedInput = {
    create?: XOR<StickyNoteLinkCreateWithoutStickyNoteInput, StickyNoteLinkUncheckedCreateWithoutStickyNoteInput> | StickyNoteLinkCreateWithoutStickyNoteInput[] | StickyNoteLinkUncheckedCreateWithoutStickyNoteInput[]
    connectOrCreate?: StickyNoteLinkCreateOrConnectWithoutStickyNoteInput | StickyNoteLinkCreateOrConnectWithoutStickyNoteInput[]
    upsert?: StickyNoteLinkUpsertWithWhereUniqueWithoutStickyNoteInput | StickyNoteLinkUpsertWithWhereUniqueWithoutStickyNoteInput[]
    createMany?: StickyNoteLinkCreateManyStickyNoteInputEnvelope
    set?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    disconnect?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    delete?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    connect?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    update?: StickyNoteLinkUpdateWithWhereUniqueWithoutStickyNoteInput | StickyNoteLinkUpdateWithWhereUniqueWithoutStickyNoteInput[]
    updateMany?: StickyNoteLinkUpdateManyWithWhereWithoutStickyNoteInput | StickyNoteLinkUpdateManyWithWhereWithoutStickyNoteInput[]
    deleteMany?: StickyNoteLinkScalarWhereInput | StickyNoteLinkScalarWhereInput[]
  }

  export type StickyNoteLinkUncheckedUpdateManyWithoutStickyNoteNestedInput = {
    create?: XOR<StickyNoteLinkCreateWithoutStickyNoteInput, StickyNoteLinkUncheckedCreateWithoutStickyNoteInput> | StickyNoteLinkCreateWithoutStickyNoteInput[] | StickyNoteLinkUncheckedCreateWithoutStickyNoteInput[]
    connectOrCreate?: StickyNoteLinkCreateOrConnectWithoutStickyNoteInput | StickyNoteLinkCreateOrConnectWithoutStickyNoteInput[]
    upsert?: StickyNoteLinkUpsertWithWhereUniqueWithoutStickyNoteInput | StickyNoteLinkUpsertWithWhereUniqueWithoutStickyNoteInput[]
    createMany?: StickyNoteLinkCreateManyStickyNoteInputEnvelope
    set?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    disconnect?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    delete?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    connect?: StickyNoteLinkWhereUniqueInput | StickyNoteLinkWhereUniqueInput[]
    update?: StickyNoteLinkUpdateWithWhereUniqueWithoutStickyNoteInput | StickyNoteLinkUpdateWithWhereUniqueWithoutStickyNoteInput[]
    updateMany?: StickyNoteLinkUpdateManyWithWhereWithoutStickyNoteInput | StickyNoteLinkUpdateManyWithWhereWithoutStickyNoteInput[]
    deleteMany?: StickyNoteLinkScalarWhereInput | StickyNoteLinkScalarWhereInput[]
  }

  export type StickyNoteCreateNestedOneWithoutLinksInput = {
    create?: XOR<StickyNoteCreateWithoutLinksInput, StickyNoteUncheckedCreateWithoutLinksInput>
    connectOrCreate?: StickyNoteCreateOrConnectWithoutLinksInput
    connect?: StickyNoteWhereUniqueInput
  }

  export type EnumStickyLinkTypeFieldUpdateOperationsInput = {
    set?: $Enums.StickyLinkType
  }

  export type StickyNoteUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<StickyNoteCreateWithoutLinksInput, StickyNoteUncheckedCreateWithoutLinksInput>
    connectOrCreate?: StickyNoteCreateOrConnectWithoutLinksInput
    upsert?: StickyNoteUpsertWithoutLinksInput
    connect?: StickyNoteWhereUniqueInput
    update?: XOR<XOR<StickyNoteUpdateToOneWithWhereWithoutLinksInput, StickyNoteUpdateWithoutLinksInput>, StickyNoteUncheckedUpdateWithoutLinksInput>
  }

  export type WorkspaceCreateNestedOneWithoutProjectGroupsInput = {
    create?: XOR<WorkspaceCreateWithoutProjectGroupsInput, WorkspaceUncheckedCreateWithoutProjectGroupsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectGroupsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectGroupMemberCreateNestedManyWithoutProjectGroupInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectGroupInput, ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput> | ProjectGroupMemberCreateWithoutProjectGroupInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput | ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput[]
    createMany?: ProjectGroupMemberCreateManyProjectGroupInputEnvelope
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
  }

  export type ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectGroupInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectGroupInput, ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput> | ProjectGroupMemberCreateWithoutProjectGroupInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput | ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput[]
    createMany?: ProjectGroupMemberCreateManyProjectGroupInputEnvelope
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
  }

  export type EnumProjectGroupStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectGroupStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutProjectGroupsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutProjectGroupsInput, WorkspaceUncheckedCreateWithoutProjectGroupsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectGroupsInput
    upsert?: WorkspaceUpsertWithoutProjectGroupsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutProjectGroupsInput, WorkspaceUpdateWithoutProjectGroupsInput>, WorkspaceUncheckedUpdateWithoutProjectGroupsInput>
  }

  export type ProjectGroupMemberUpdateManyWithoutProjectGroupNestedInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectGroupInput, ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput> | ProjectGroupMemberCreateWithoutProjectGroupInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput | ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput[]
    upsert?: ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectGroupInput | ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectGroupInput[]
    createMany?: ProjectGroupMemberCreateManyProjectGroupInputEnvelope
    set?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    disconnect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    delete?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    update?: ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectGroupInput | ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectGroupInput[]
    updateMany?: ProjectGroupMemberUpdateManyWithWhereWithoutProjectGroupInput | ProjectGroupMemberUpdateManyWithWhereWithoutProjectGroupInput[]
    deleteMany?: ProjectGroupMemberScalarWhereInput | ProjectGroupMemberScalarWhereInput[]
  }

  export type ProjectGroupMemberUncheckedUpdateManyWithoutProjectGroupNestedInput = {
    create?: XOR<ProjectGroupMemberCreateWithoutProjectGroupInput, ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput> | ProjectGroupMemberCreateWithoutProjectGroupInput[] | ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput[]
    connectOrCreate?: ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput | ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput[]
    upsert?: ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectGroupInput | ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectGroupInput[]
    createMany?: ProjectGroupMemberCreateManyProjectGroupInputEnvelope
    set?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    disconnect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    delete?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    connect?: ProjectGroupMemberWhereUniqueInput | ProjectGroupMemberWhereUniqueInput[]
    update?: ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectGroupInput | ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectGroupInput[]
    updateMany?: ProjectGroupMemberUpdateManyWithWhereWithoutProjectGroupInput | ProjectGroupMemberUpdateManyWithWhereWithoutProjectGroupInput[]
    deleteMany?: ProjectGroupMemberScalarWhereInput | ProjectGroupMemberScalarWhereInput[]
  }

  export type ProjectGroupCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProjectGroupCreateWithoutProjectsInput, ProjectGroupUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectGroupCreateOrConnectWithoutProjectsInput
    connect?: ProjectGroupWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProjectGroupsInput = {
    create?: XOR<ProjectCreateWithoutProjectGroupsInput, ProjectUncheckedCreateWithoutProjectGroupsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectGroupsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectGroupUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ProjectGroupCreateWithoutProjectsInput, ProjectGroupUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectGroupCreateOrConnectWithoutProjectsInput
    upsert?: ProjectGroupUpsertWithoutProjectsInput
    connect?: ProjectGroupWhereUniqueInput
    update?: XOR<XOR<ProjectGroupUpdateToOneWithWhereWithoutProjectsInput, ProjectGroupUpdateWithoutProjectsInput>, ProjectGroupUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectUpdateOneRequiredWithoutProjectGroupsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectGroupsInput, ProjectUncheckedCreateWithoutProjectGroupsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectGroupsInput
    upsert?: ProjectUpsertWithoutProjectGroupsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectGroupsInput, ProjectUpdateWithoutProjectGroupsInput>, ProjectUncheckedUpdateWithoutProjectGroupsInput>
  }

  export type TaskCreateNestedOneWithoutGenxSessionsInput = {
    create?: XOR<TaskCreateWithoutGenxSessionsInput, TaskUncheckedCreateWithoutGenxSessionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutGenxSessionsInput
    connect?: TaskWhereUniqueInput
  }

  export type EnumTaskSessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskSessionType
  }

  export type TaskUpdateOneRequiredWithoutGenxSessionsNestedInput = {
    create?: XOR<TaskCreateWithoutGenxSessionsInput, TaskUncheckedCreateWithoutGenxSessionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutGenxSessionsInput
    upsert?: TaskUpsertWithoutGenxSessionsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutGenxSessionsInput, TaskUpdateWithoutGenxSessionsInput>, TaskUncheckedUpdateWithoutGenxSessionsInput>
  }

  export type ProjectCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<ProjectCreateWithoutBudgetsInput, ProjectUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBudgetsInput
    connect?: ProjectWhereUniqueInput
  }

  export type BudgetLineCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetLineCreateWithoutBudgetInput, BudgetLineUncheckedCreateWithoutBudgetInput> | BudgetLineCreateWithoutBudgetInput[] | BudgetLineUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutBudgetInput | BudgetLineCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetLineCreateManyBudgetInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type BudgetLineUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetLineCreateWithoutBudgetInput, BudgetLineUncheckedCreateWithoutBudgetInput> | BudgetLineCreateWithoutBudgetInput[] | BudgetLineUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutBudgetInput | BudgetLineCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetLineCreateManyBudgetInputEnvelope
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProjectUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<ProjectCreateWithoutBudgetsInput, ProjectUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBudgetsInput
    upsert?: ProjectUpsertWithoutBudgetsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBudgetsInput, ProjectUpdateWithoutBudgetsInput>, ProjectUncheckedUpdateWithoutBudgetsInput>
  }

  export type BudgetLineUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetLineCreateWithoutBudgetInput, BudgetLineUncheckedCreateWithoutBudgetInput> | BudgetLineCreateWithoutBudgetInput[] | BudgetLineUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutBudgetInput | BudgetLineCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutBudgetInput | BudgetLineUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetLineCreateManyBudgetInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutBudgetInput | BudgetLineUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutBudgetInput | BudgetLineUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type BudgetLineUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetLineCreateWithoutBudgetInput, BudgetLineUncheckedCreateWithoutBudgetInput> | BudgetLineCreateWithoutBudgetInput[] | BudgetLineUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineCreateOrConnectWithoutBudgetInput | BudgetLineCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetLineUpsertWithWhereUniqueWithoutBudgetInput | BudgetLineUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetLineCreateManyBudgetInputEnvelope
    set?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    disconnect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    delete?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    connect?: BudgetLineWhereUniqueInput | BudgetLineWhereUniqueInput[]
    update?: BudgetLineUpdateWithWhereUniqueWithoutBudgetInput | BudgetLineUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetLineUpdateManyWithWhereWithoutBudgetInput | BudgetLineUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutLinesInput = {
    create?: XOR<BudgetCreateWithoutLinesInput, BudgetUncheckedCreateWithoutLinesInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutLinesInput
    connect?: BudgetWhereUniqueInput
  }

  export type EnumBudgetLineTypeFieldUpdateOperationsInput = {
    set?: $Enums.BudgetLineType
  }

  export type BudgetUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<BudgetCreateWithoutLinesInput, BudgetUncheckedCreateWithoutLinesInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutLinesInput
    upsert?: BudgetUpsertWithoutLinesInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutLinesInput, BudgetUpdateWithoutLinesInput>, BudgetUncheckedUpdateWithoutLinesInput>
  }

  export type ProjectCreateNestedOneWithoutWikiPagesInput = {
    create?: XOR<ProjectCreateWithoutWikiPagesInput, ProjectUncheckedCreateWithoutWikiPagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWikiPagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutWikiPagesNestedInput = {
    create?: XOR<ProjectCreateWithoutWikiPagesInput, ProjectUncheckedCreateWithoutWikiPagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWikiPagesInput
    upsert?: ProjectUpsertWithoutWikiPagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWikiPagesInput, ProjectUpdateWithoutWikiPagesInput>, ProjectUncheckedUpdateWithoutWikiPagesInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type ProjectCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<ProjectCreateWithoutWebhooksInput, ProjectUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebhooksInput
    connect?: ProjectWhereUniqueInput
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<ProjectCreateWithoutWebhooksInput, ProjectUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebhooksInput
    upsert?: ProjectUpsertWithoutWebhooksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWebhooksInput, ProjectUpdateWithoutWebhooksInput>, ProjectUncheckedUpdateWithoutWebhooksInput>
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
  }

  export type WebhookUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookUpsertWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutDeliveriesInput, WebhookUpdateWithoutDeliveriesInput>, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProjectCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput
    upsert?: ProjectUpsertWithoutActivitiesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutActivitiesInput, ProjectUpdateWithoutActivitiesInput>, ProjectUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserCreateNestedOneWithoutLastLoginsInput = {
    create?: XOR<UserCreateWithoutLastLoginsInput, UserUncheckedCreateWithoutLastLoginsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLastLoginsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLastLoginsNestedInput = {
    create?: XOR<UserCreateWithoutLastLoginsInput, UserUncheckedCreateWithoutLastLoginsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLastLoginsInput
    upsert?: UserUpsertWithoutLastLoginsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLastLoginsInput, UserUpdateWithoutLastLoginsInput>, UserUncheckedUpdateWithoutLastLoginsInput>
  }

  export type UserCreateNestedOneWithoutMetadataInput = {
    create?: XOR<UserCreateWithoutMetadataInput, UserUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: UserCreateOrConnectWithoutMetadataInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMetadataNestedInput = {
    create?: XOR<UserCreateWithoutMetadataInput, UserUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: UserCreateOrConnectWithoutMetadataInput
    upsert?: UserUpsertWithoutMetadataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMetadataInput, UserUpdateWithoutMetadataInput>, UserUncheckedUpdateWithoutMetadataInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutAvatarInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAvatarNestedInput = {
    create?: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvatarInput
    upsert?: UserUpsertWithoutAvatarInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvatarInput, UserUpdateWithoutAvatarInput>, UserUncheckedUpdateWithoutAvatarInput>
  }

  export type GroupCreateNestedOneWithoutChildGroupsInput = {
    create?: XOR<GroupCreateWithoutChildGroupsInput, GroupUncheckedCreateWithoutChildGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutChildGroupsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupCreateNestedManyWithoutParentGroupInput = {
    create?: XOR<GroupCreateWithoutParentGroupInput, GroupUncheckedCreateWithoutParentGroupInput> | GroupCreateWithoutParentGroupInput[] | GroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutParentGroupInput | GroupCreateOrConnectWithoutParentGroupInput[]
    createMany?: GroupCreateManyParentGroupInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedOneWithoutGroupsInput = {
    create?: XOR<WorkspaceCreateWithoutGroupsInput, WorkspaceUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutGroupsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutGroupsInput = {
    create?: XOR<ProjectCreateWithoutGroupsInput, ProjectUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGroupsInput
    connect?: ProjectWhereUniqueInput
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupPermissionCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupPermissionCreateWithoutGroupInput, GroupPermissionUncheckedCreateWithoutGroupInput> | GroupPermissionCreateWithoutGroupInput[] | GroupPermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutGroupInput | GroupPermissionCreateOrConnectWithoutGroupInput[]
    createMany?: GroupPermissionCreateManyGroupInputEnvelope
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
  }

  export type RoleAssignmentCreateNestedManyWithoutGroupInput = {
    create?: XOR<RoleAssignmentCreateWithoutGroupInput, RoleAssignmentUncheckedCreateWithoutGroupInput> | RoleAssignmentCreateWithoutGroupInput[] | RoleAssignmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutGroupInput | RoleAssignmentCreateOrConnectWithoutGroupInput[]
    createMany?: RoleAssignmentCreateManyGroupInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutParentGroupInput = {
    create?: XOR<GroupCreateWithoutParentGroupInput, GroupUncheckedCreateWithoutParentGroupInput> | GroupCreateWithoutParentGroupInput[] | GroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutParentGroupInput | GroupCreateOrConnectWithoutParentGroupInput[]
    createMany?: GroupCreateManyParentGroupInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type GroupPermissionUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupPermissionCreateWithoutGroupInput, GroupPermissionUncheckedCreateWithoutGroupInput> | GroupPermissionCreateWithoutGroupInput[] | GroupPermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutGroupInput | GroupPermissionCreateOrConnectWithoutGroupInput[]
    createMany?: GroupPermissionCreateManyGroupInputEnvelope
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
  }

  export type RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<RoleAssignmentCreateWithoutGroupInput, RoleAssignmentUncheckedCreateWithoutGroupInput> | RoleAssignmentCreateWithoutGroupInput[] | RoleAssignmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutGroupInput | RoleAssignmentCreateOrConnectWithoutGroupInput[]
    createMany?: RoleAssignmentCreateManyGroupInputEnvelope
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
  }

  export type EnumGroupTypeFieldUpdateOperationsInput = {
    set?: $Enums.GroupType
  }

  export type EnumGroupScopeFieldUpdateOperationsInput = {
    set?: $Enums.GroupScope
  }

  export type EnumGroupSourceFieldUpdateOperationsInput = {
    set?: $Enums.GroupSource
  }

  export type GroupUpdateOneWithoutChildGroupsNestedInput = {
    create?: XOR<GroupCreateWithoutChildGroupsInput, GroupUncheckedCreateWithoutChildGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutChildGroupsInput
    upsert?: GroupUpsertWithoutChildGroupsInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutChildGroupsInput, GroupUpdateWithoutChildGroupsInput>, GroupUncheckedUpdateWithoutChildGroupsInput>
  }

  export type GroupUpdateManyWithoutParentGroupNestedInput = {
    create?: XOR<GroupCreateWithoutParentGroupInput, GroupUncheckedCreateWithoutParentGroupInput> | GroupCreateWithoutParentGroupInput[] | GroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutParentGroupInput | GroupCreateOrConnectWithoutParentGroupInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutParentGroupInput | GroupUpsertWithWhereUniqueWithoutParentGroupInput[]
    createMany?: GroupCreateManyParentGroupInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutParentGroupInput | GroupUpdateWithWhereUniqueWithoutParentGroupInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutParentGroupInput | GroupUpdateManyWithWhereWithoutParentGroupInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type WorkspaceUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutGroupsInput, WorkspaceUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutGroupsInput
    upsert?: WorkspaceUpsertWithoutGroupsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutGroupsInput, WorkspaceUpdateWithoutGroupsInput>, WorkspaceUncheckedUpdateWithoutGroupsInput>
  }

  export type ProjectUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<ProjectCreateWithoutGroupsInput, ProjectUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGroupsInput
    upsert?: ProjectUpsertWithoutGroupsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutGroupsInput, ProjectUpdateWithoutGroupsInput>, ProjectUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupPermissionUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupPermissionCreateWithoutGroupInput, GroupPermissionUncheckedCreateWithoutGroupInput> | GroupPermissionCreateWithoutGroupInput[] | GroupPermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutGroupInput | GroupPermissionCreateOrConnectWithoutGroupInput[]
    upsert?: GroupPermissionUpsertWithWhereUniqueWithoutGroupInput | GroupPermissionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupPermissionCreateManyGroupInputEnvelope
    set?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    disconnect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    delete?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    update?: GroupPermissionUpdateWithWhereUniqueWithoutGroupInput | GroupPermissionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupPermissionUpdateManyWithWhereWithoutGroupInput | GroupPermissionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupPermissionScalarWhereInput | GroupPermissionScalarWhereInput[]
  }

  export type RoleAssignmentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutGroupInput, RoleAssignmentUncheckedCreateWithoutGroupInput> | RoleAssignmentCreateWithoutGroupInput[] | RoleAssignmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutGroupInput | RoleAssignmentCreateOrConnectWithoutGroupInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutGroupInput | RoleAssignmentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RoleAssignmentCreateManyGroupInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutGroupInput | RoleAssignmentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutGroupInput | RoleAssignmentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutParentGroupNestedInput = {
    create?: XOR<GroupCreateWithoutParentGroupInput, GroupUncheckedCreateWithoutParentGroupInput> | GroupCreateWithoutParentGroupInput[] | GroupUncheckedCreateWithoutParentGroupInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutParentGroupInput | GroupCreateOrConnectWithoutParentGroupInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutParentGroupInput | GroupUpsertWithWhereUniqueWithoutParentGroupInput[]
    createMany?: GroupCreateManyParentGroupInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutParentGroupInput | GroupUpdateWithWhereUniqueWithoutParentGroupInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutParentGroupInput | GroupUpdateManyWithWhereWithoutParentGroupInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupPermissionCreateWithoutGroupInput, GroupPermissionUncheckedCreateWithoutGroupInput> | GroupPermissionCreateWithoutGroupInput[] | GroupPermissionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutGroupInput | GroupPermissionCreateOrConnectWithoutGroupInput[]
    upsert?: GroupPermissionUpsertWithWhereUniqueWithoutGroupInput | GroupPermissionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupPermissionCreateManyGroupInputEnvelope
    set?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    disconnect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    delete?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    update?: GroupPermissionUpdateWithWhereUniqueWithoutGroupInput | GroupPermissionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupPermissionUpdateManyWithWhereWithoutGroupInput | GroupPermissionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupPermissionScalarWhereInput | GroupPermissionScalarWhereInput[]
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RoleAssignmentCreateWithoutGroupInput, RoleAssignmentUncheckedCreateWithoutGroupInput> | RoleAssignmentCreateWithoutGroupInput[] | RoleAssignmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RoleAssignmentCreateOrConnectWithoutGroupInput | RoleAssignmentCreateOrConnectWithoutGroupInput[]
    upsert?: RoleAssignmentUpsertWithWhereUniqueWithoutGroupInput | RoleAssignmentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RoleAssignmentCreateManyGroupInputEnvelope
    set?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    disconnect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    delete?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    connect?: RoleAssignmentWhereUniqueInput | RoleAssignmentWhereUniqueInput[]
    update?: RoleAssignmentUpdateWithWhereUniqueWithoutGroupInput | RoleAssignmentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RoleAssignmentUpdateManyWithWhereWithoutGroupInput | RoleAssignmentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembersAddedInput = {
    create?: XOR<UserCreateWithoutGroupMembersAddedInput, UserUncheckedCreateWithoutGroupMembersAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembersAddedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMemberTypeFieldUpdateOperationsInput = {
    set?: $Enums.MemberType
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateOneWithoutGroupMembersAddedNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembersAddedInput, UserUncheckedCreateWithoutGroupMembersAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembersAddedInput
    upsert?: UserUpsertWithoutGroupMembersAddedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembersAddedInput, UserUpdateWithoutGroupMembersAddedInput>, UserUncheckedUpdateWithoutGroupMembersAddedInput>
  }

  export type PermissionCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PermissionCreateWithoutChildrenInput, PermissionUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutChildrenInput
    connect?: PermissionWhereUniqueInput
  }

  export type PermissionCreateNestedManyWithoutParentInput = {
    create?: XOR<PermissionCreateWithoutParentInput, PermissionUncheckedCreateWithoutParentInput> | PermissionCreateWithoutParentInput[] | PermissionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutParentInput | PermissionCreateOrConnectWithoutParentInput[]
    createMany?: PermissionCreateManyParentInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type GroupPermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<GroupPermissionCreateWithoutPermissionInput, GroupPermissionUncheckedCreateWithoutPermissionInput> | GroupPermissionCreateWithoutPermissionInput[] | GroupPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutPermissionInput | GroupPermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: GroupPermissionCreateManyPermissionInputEnvelope
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PermissionCreateWithoutParentInput, PermissionUncheckedCreateWithoutParentInput> | PermissionCreateWithoutParentInput[] | PermissionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutParentInput | PermissionCreateOrConnectWithoutParentInput[]
    createMany?: PermissionCreateManyParentInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type GroupPermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<GroupPermissionCreateWithoutPermissionInput, GroupPermissionUncheckedCreateWithoutPermissionInput> | GroupPermissionCreateWithoutPermissionInput[] | GroupPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutPermissionInput | GroupPermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: GroupPermissionCreateManyPermissionInputEnvelope
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
  }

  export type PermissionUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PermissionCreateWithoutChildrenInput, PermissionUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutChildrenInput
    upsert?: PermissionUpsertWithoutChildrenInput
    disconnect?: PermissionWhereInput | boolean
    delete?: PermissionWhereInput | boolean
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutChildrenInput, PermissionUpdateWithoutChildrenInput>, PermissionUncheckedUpdateWithoutChildrenInput>
  }

  export type PermissionUpdateManyWithoutParentNestedInput = {
    create?: XOR<PermissionCreateWithoutParentInput, PermissionUncheckedCreateWithoutParentInput> | PermissionCreateWithoutParentInput[] | PermissionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutParentInput | PermissionCreateOrConnectWithoutParentInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutParentInput | PermissionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PermissionCreateManyParentInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutParentInput | PermissionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutParentInput | PermissionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type GroupPermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<GroupPermissionCreateWithoutPermissionInput, GroupPermissionUncheckedCreateWithoutPermissionInput> | GroupPermissionCreateWithoutPermissionInput[] | GroupPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutPermissionInput | GroupPermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: GroupPermissionUpsertWithWhereUniqueWithoutPermissionInput | GroupPermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: GroupPermissionCreateManyPermissionInputEnvelope
    set?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    disconnect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    delete?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    update?: GroupPermissionUpdateWithWhereUniqueWithoutPermissionInput | GroupPermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: GroupPermissionUpdateManyWithWhereWithoutPermissionInput | GroupPermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: GroupPermissionScalarWhereInput | GroupPermissionScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PermissionCreateWithoutParentInput, PermissionUncheckedCreateWithoutParentInput> | PermissionCreateWithoutParentInput[] | PermissionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutParentInput | PermissionCreateOrConnectWithoutParentInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutParentInput | PermissionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PermissionCreateManyParentInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutParentInput | PermissionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutParentInput | PermissionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type GroupPermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<GroupPermissionCreateWithoutPermissionInput, GroupPermissionUncheckedCreateWithoutPermissionInput> | GroupPermissionCreateWithoutPermissionInput[] | GroupPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: GroupPermissionCreateOrConnectWithoutPermissionInput | GroupPermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: GroupPermissionUpsertWithWhereUniqueWithoutPermissionInput | GroupPermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: GroupPermissionCreateManyPermissionInputEnvelope
    set?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    disconnect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    delete?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    connect?: GroupPermissionWhereUniqueInput | GroupPermissionWhereUniqueInput[]
    update?: GroupPermissionUpdateWithWhereUniqueWithoutPermissionInput | GroupPermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: GroupPermissionUpdateManyWithWhereWithoutPermissionInput | GroupPermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: GroupPermissionScalarWhereInput | GroupPermissionScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutPermissionsInput
    connect?: GroupWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutGroupPermissionsInput = {
    create?: XOR<PermissionCreateWithoutGroupPermissionsInput, PermissionUncheckedCreateWithoutGroupPermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutGroupPermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type EnumAccessTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccessType
  }

  export type GroupUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutPermissionsInput
    upsert?: GroupUpsertWithoutPermissionsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutPermissionsInput, GroupUpdateWithoutPermissionsInput>, GroupUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutGroupPermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutGroupPermissionsInput, PermissionUncheckedCreateWithoutGroupPermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutGroupPermissionsInput
    upsert?: PermissionUpsertWithoutGroupPermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutGroupPermissionsInput, PermissionUpdateWithoutGroupPermissionsInput>, PermissionUncheckedUpdateWithoutGroupPermissionsInput>
  }

  export type GroupCreateNestedOneWithoutRoleAssignmentsInput = {
    create?: XOR<GroupCreateWithoutRoleAssignmentsInput, GroupUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutRoleAssignmentsInput
    connect?: GroupWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutRoleAssignmentsInput = {
    create?: XOR<WorkspaceCreateWithoutRoleAssignmentsInput, WorkspaceUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutRoleAssignmentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutRoleAssignmentsInput = {
    create?: XOR<ProjectCreateWithoutRoleAssignmentsInput, ProjectUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoleAssignmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumAssignmentRoleFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentRole
  }

  export type GroupUpdateOneRequiredWithoutRoleAssignmentsNestedInput = {
    create?: XOR<GroupCreateWithoutRoleAssignmentsInput, GroupUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutRoleAssignmentsInput
    upsert?: GroupUpsertWithoutRoleAssignmentsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutRoleAssignmentsInput, GroupUpdateWithoutRoleAssignmentsInput>, GroupUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type WorkspaceUpdateOneWithoutRoleAssignmentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutRoleAssignmentsInput, WorkspaceUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutRoleAssignmentsInput
    upsert?: WorkspaceUpsertWithoutRoleAssignmentsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutRoleAssignmentsInput, WorkspaceUpdateWithoutRoleAssignmentsInput>, WorkspaceUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type ProjectUpdateOneWithoutRoleAssignmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutRoleAssignmentsInput, ProjectUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoleAssignmentsInput
    upsert?: ProjectUpsertWithoutRoleAssignmentsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRoleAssignmentsInput, ProjectUpdateWithoutRoleAssignmentsInput>, ProjectUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleFilter<$PrismaModel> | $Enums.WorkspaceRole
  }

  export type NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceRole | EnumWorkspaceRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceRole[] | ListEnumWorkspaceRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceRoleFilter<$PrismaModel>
  }

  export type NestedEnumAppRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleFilter<$PrismaModel> | $Enums.AppRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumAppRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppRole[] | ListEnumAppRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAppRoleWithAggregatesFilter<$PrismaModel> | $Enums.AppRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppRoleFilter<$PrismaModel>
    _max?: NestedEnumAppRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubtaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusFilter<$PrismaModel> | $Enums.SubtaskStatus
  }

  export type NestedEnumSubtaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubtaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubtaskStatusFilter<$PrismaModel>
    _max?: NestedEnumSubtaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskLinkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLinkType | EnumTaskLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskLinkTypeFilter<$PrismaModel> | $Enums.TaskLinkType
  }

  export type NestedEnumTaskLinkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskLinkType | EnumTaskLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskLinkType[] | ListEnumTaskLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskLinkTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskLinkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskLinkTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskLinkTypeFilter<$PrismaModel>
  }

  export type NestedEnumCustomFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomFieldType | EnumCustomFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomFieldTypeFilter<$PrismaModel> | $Enums.CustomFieldType
  }

  export type NestedEnumCustomFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomFieldType | EnumCustomFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomFieldType[] | ListEnumCustomFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomFieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomFieldTypeFilter<$PrismaModel>
  }

  export type NestedEnumSprintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SprintStatus | EnumSprintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSprintStatusFilter<$PrismaModel> | $Enums.SprintStatus
  }

  export type NestedEnumSprintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SprintStatus | EnumSprintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SprintStatus[] | ListEnumSprintStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSprintStatusWithAggregatesFilter<$PrismaModel> | $Enums.SprintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSprintStatusFilter<$PrismaModel>
    _max?: NestedEnumSprintStatusFilter<$PrismaModel>
  }

  export type NestedEnumStickyNoteColorFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyNoteColor | EnumStickyNoteColorFieldRefInput<$PrismaModel>
    in?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyNoteColorFilter<$PrismaModel> | $Enums.StickyNoteColor
  }

  export type NestedEnumStickyVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyVisibility | EnumStickyVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyVisibilityFilter<$PrismaModel> | $Enums.StickyVisibility
  }

  export type NestedEnumStickyNoteColorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyNoteColor | EnumStickyNoteColorFieldRefInput<$PrismaModel>
    in?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyNoteColor[] | ListEnumStickyNoteColorFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyNoteColorWithAggregatesFilter<$PrismaModel> | $Enums.StickyNoteColor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickyNoteColorFilter<$PrismaModel>
    _max?: NestedEnumStickyNoteColorFilter<$PrismaModel>
  }

  export type NestedEnumStickyVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyVisibility | EnumStickyVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyVisibility[] | ListEnumStickyVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.StickyVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickyVisibilityFilter<$PrismaModel>
    _max?: NestedEnumStickyVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumStickyLinkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyLinkType | EnumStickyLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyLinkTypeFilter<$PrismaModel> | $Enums.StickyLinkType
  }

  export type NestedEnumStickyLinkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StickyLinkType | EnumStickyLinkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StickyLinkType[] | ListEnumStickyLinkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStickyLinkTypeWithAggregatesFilter<$PrismaModel> | $Enums.StickyLinkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStickyLinkTypeFilter<$PrismaModel>
    _max?: NestedEnumStickyLinkTypeFilter<$PrismaModel>
  }

  export type NestedEnumProjectGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectGroupStatus | EnumProjectGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectGroupStatusFilter<$PrismaModel> | $Enums.ProjectGroupStatus
  }

  export type NestedEnumProjectGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectGroupStatus | EnumProjectGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectGroupStatus[] | ListEnumProjectGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectGroupStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectGroupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectGroupStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectGroupStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskSessionType | EnumTaskSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskSessionTypeFilter<$PrismaModel> | $Enums.TaskSessionType
  }

  export type NestedEnumTaskSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskSessionType | EnumTaskSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskSessionType[] | ListEnumTaskSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskSessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskSessionTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBudgetLineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetLineType | EnumBudgetLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetLineTypeFilter<$PrismaModel> | $Enums.BudgetLineType
  }

  export type NestedEnumBudgetLineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetLineType | EnumBudgetLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetLineType[] | ListEnumBudgetLineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetLineTypeWithAggregatesFilter<$PrismaModel> | $Enums.BudgetLineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetLineTypeFilter<$PrismaModel>
    _max?: NestedEnumBudgetLineTypeFilter<$PrismaModel>
  }

  export type NestedEnumGroupTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupType | EnumGroupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypeFilter<$PrismaModel> | $Enums.GroupType
  }

  export type NestedEnumGroupScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupScope | EnumGroupScopeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupScopeFilter<$PrismaModel> | $Enums.GroupScope
  }

  export type NestedEnumGroupSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupSource | EnumGroupSourceFieldRefInput<$PrismaModel>
    in?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupSourceFilter<$PrismaModel> | $Enums.GroupSource
  }

  export type NestedEnumGroupTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupType | EnumGroupTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupType[] | ListEnumGroupTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupTypeWithAggregatesFilter<$PrismaModel> | $Enums.GroupType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupTypeFilter<$PrismaModel>
    _max?: NestedEnumGroupTypeFilter<$PrismaModel>
  }

  export type NestedEnumGroupScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupScope | EnumGroupScopeFieldRefInput<$PrismaModel>
    in?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupScope[] | ListEnumGroupScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupScopeWithAggregatesFilter<$PrismaModel> | $Enums.GroupScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupScopeFilter<$PrismaModel>
    _max?: NestedEnumGroupScopeFilter<$PrismaModel>
  }

  export type NestedEnumGroupSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupSource | EnumGroupSourceFieldRefInput<$PrismaModel>
    in?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupSource[] | ListEnumGroupSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupSourceWithAggregatesFilter<$PrismaModel> | $Enums.GroupSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupSourceFilter<$PrismaModel>
    _max?: NestedEnumGroupSourceFilter<$PrismaModel>
  }

  export type NestedEnumMemberTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberType | EnumMemberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberTypeFilter<$PrismaModel> | $Enums.MemberType
  }

  export type NestedEnumMemberTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberType | EnumMemberTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberType[] | ListEnumMemberTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberTypeWithAggregatesFilter<$PrismaModel> | $Enums.MemberType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberTypeFilter<$PrismaModel>
    _max?: NestedEnumMemberTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeFilter<$PrismaModel> | $Enums.AccessType
  }

  export type NestedEnumAccessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessTypeFilter<$PrismaModel>
    _max?: NestedEnumAccessTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleFilter<$PrismaModel> | $Enums.AssignmentRole
  }

  export type NestedEnumAssignmentRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentRoleFilter<$PrismaModel>
    _max?: NestedEnumAssignmentRoleFilter<$PrismaModel>
  }

  export type UserCreateWithoutWorkspacesCreatedInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutWorkspacesCreatedInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutWorkspacesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesCreatedInput, UserUncheckedCreateWithoutWorkspacesCreatedInput>
  }

  export type WorkspaceUserCreateWithoutWorkspaceInput = {
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceUserUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    userId: number
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
  }

  export type WorkspaceUserCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserCreateManyWorkspaceInput | WorkspaceUserCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutWorkspaceInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectCreateManyWorkspaceInputEnvelope = {
    data: ProjectCreateManyWorkspaceInput | ProjectCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectGroupCreateWithoutWorkspaceInput = {
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectGroupMemberCreateNestedManyWithoutProjectGroupInput
  }

  export type ProjectGroupUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectGroupInput
  }

  export type ProjectGroupCreateOrConnectWithoutWorkspaceInput = {
    where: ProjectGroupWhereUniqueInput
    create: XOR<ProjectGroupCreateWithoutWorkspaceInput, ProjectGroupUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectGroupCreateManyWorkspaceInputEnvelope = {
    data: ProjectGroupCreateManyWorkspaceInput | ProjectGroupCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutWorkspaceInput = {
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutInvitationsCreatedInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    createdBy: number
  }

  export type WorkspaceInvitationCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceInvitationCreateManyWorkspaceInput | WorkspaceInvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceLogoCreateWithoutWorkspaceInput = {
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceLogoUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceLogoCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceLogoWhereUniqueInput
    create: XOR<WorkspaceLogoCreateWithoutWorkspaceInput, WorkspaceLogoUncheckedCreateWithoutWorkspaceInput>
  }

  export type GroupCreateWithoutWorkspaceInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutWorkspaceInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutWorkspaceInput, GroupUncheckedCreateWithoutWorkspaceInput>
  }

  export type GroupCreateManyWorkspaceInputEnvelope = {
    data: GroupCreateManyWorkspaceInput | GroupCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssignmentCreateWithoutWorkspaceInput = {
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
    group: GroupCreateNestedOneWithoutRoleAssignmentsInput
    project?: ProjectCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type RoleAssignmentUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    groupId: number
    projectId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type RoleAssignmentCreateOrConnectWithoutWorkspaceInput = {
    where: RoleAssignmentWhereUniqueInput
    create: XOR<RoleAssignmentCreateWithoutWorkspaceInput, RoleAssignmentUncheckedCreateWithoutWorkspaceInput>
  }

  export type RoleAssignmentCreateManyWorkspaceInputEnvelope = {
    data: RoleAssignmentCreateManyWorkspaceInput | RoleAssignmentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkspacesCreatedInput = {
    update: XOR<UserUpdateWithoutWorkspacesCreatedInput, UserUncheckedUpdateWithoutWorkspacesCreatedInput>
    create: XOR<UserCreateWithoutWorkspacesCreatedInput, UserUncheckedCreateWithoutWorkspacesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesCreatedInput, UserUncheckedUpdateWithoutWorkspacesCreatedInput>
  }

  export type UserUpdateWithoutWorkspacesCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserCreateWithoutWorkspaceInput, WorkspaceUserUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutWorkspaceInput, WorkspaceUserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceUserScalarWhereInput = {
    AND?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    OR?: WorkspaceUserScalarWhereInput[]
    NOT?: WorkspaceUserScalarWhereInput | WorkspaceUserScalarWhereInput[]
    id?: IntFilter<"WorkspaceUser"> | number
    workspaceId?: IntFilter<"WorkspaceUser"> | number
    userId?: IntFilter<"WorkspaceUser"> | number
    role?: EnumWorkspaceRoleFilter<"WorkspaceUser"> | $Enums.WorkspaceRole
    joinedAt?: DateTimeFilter<"WorkspaceUser"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProjectUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    workspaceId?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    identifier?: StringNullableFilter<"Project"> | string | null
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    isActive?: BoolFilter<"Project"> | boolean
    isPublic?: BoolFilter<"Project"> | boolean
    settings?: JsonFilter<"Project">
    lastActivityAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectGroupUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectGroupWhereUniqueInput
    update: XOR<ProjectGroupUpdateWithoutWorkspaceInput, ProjectGroupUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProjectGroupCreateWithoutWorkspaceInput, ProjectGroupUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectGroupUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectGroupWhereUniqueInput
    data: XOR<ProjectGroupUpdateWithoutWorkspaceInput, ProjectGroupUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProjectGroupUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProjectGroupScalarWhereInput
    data: XOR<ProjectGroupUpdateManyMutationInput, ProjectGroupUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ProjectGroupScalarWhereInput = {
    AND?: ProjectGroupScalarWhereInput | ProjectGroupScalarWhereInput[]
    OR?: ProjectGroupScalarWhereInput[]
    NOT?: ProjectGroupScalarWhereInput | ProjectGroupScalarWhereInput[]
    id?: IntFilter<"ProjectGroup"> | number
    workspaceId?: IntFilter<"ProjectGroup"> | number
    name?: StringFilter<"ProjectGroup"> | string
    description?: StringNullableFilter<"ProjectGroup"> | string | null
    color?: StringFilter<"ProjectGroup"> | string
    status?: EnumProjectGroupStatusFilter<"ProjectGroup"> | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFilter<"ProjectGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectGroup"> | Date | string
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceInvitationCreateWithoutWorkspaceInput, WorkspaceInvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutWorkspaceInput, WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceInvitationScalarWhereInput = {
    AND?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    OR?: WorkspaceInvitationScalarWhereInput[]
    NOT?: WorkspaceInvitationScalarWhereInput | WorkspaceInvitationScalarWhereInput[]
    id?: IntFilter<"WorkspaceInvitation"> | number
    workspaceId?: IntFilter<"WorkspaceInvitation"> | number
    email?: StringFilter<"WorkspaceInvitation"> | string
    role?: EnumWorkspaceRoleFilter<"WorkspaceInvitation"> | $Enums.WorkspaceRole
    token?: StringFilter<"WorkspaceInvitation"> | string
    expiresAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdAt?: DateTimeFilter<"WorkspaceInvitation"> | Date | string
    createdBy?: IntFilter<"WorkspaceInvitation"> | number
  }

  export type WorkspaceLogoUpsertWithoutWorkspaceInput = {
    update: XOR<WorkspaceLogoUpdateWithoutWorkspaceInput, WorkspaceLogoUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceLogoCreateWithoutWorkspaceInput, WorkspaceLogoUncheckedCreateWithoutWorkspaceInput>
    where?: WorkspaceLogoWhereInput
  }

  export type WorkspaceLogoUpdateToOneWithWhereWithoutWorkspaceInput = {
    where?: WorkspaceLogoWhereInput
    data: XOR<WorkspaceLogoUpdateWithoutWorkspaceInput, WorkspaceLogoUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceLogoUpdateWithoutWorkspaceInput = {
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceLogoUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutWorkspaceInput, GroupUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<GroupCreateWithoutWorkspaceInput, GroupUncheckedCreateWithoutWorkspaceInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutWorkspaceInput, GroupUncheckedUpdateWithoutWorkspaceInput>
  }

  export type GroupUpdateManyWithWhereWithoutWorkspaceInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: IntFilter<"Group"> | number
    objectGuid?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    displayName?: StringFilter<"Group"> | string
    distinguishedName?: StringNullableFilter<"Group"> | string | null
    description?: StringNullableFilter<"Group"> | string | null
    type?: EnumGroupTypeFilter<"Group"> | $Enums.GroupType
    scope?: EnumGroupScopeFilter<"Group"> | $Enums.GroupScope
    workspaceId?: IntNullableFilter<"Group"> | number | null
    projectId?: IntNullableFilter<"Group"> | number | null
    parentGroupId?: IntNullableFilter<"Group"> | number | null
    externalId?: StringNullableFilter<"Group"> | string | null
    source?: EnumGroupSourceFilter<"Group"> | $Enums.GroupSource
    isSystem?: BoolFilter<"Group"> | boolean
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    isSecurityGroup?: BoolFilter<"Group"> | boolean
  }

  export type RoleAssignmentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: RoleAssignmentWhereUniqueInput
    update: XOR<RoleAssignmentUpdateWithoutWorkspaceInput, RoleAssignmentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<RoleAssignmentCreateWithoutWorkspaceInput, RoleAssignmentUncheckedCreateWithoutWorkspaceInput>
  }

  export type RoleAssignmentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: RoleAssignmentWhereUniqueInput
    data: XOR<RoleAssignmentUpdateWithoutWorkspaceInput, RoleAssignmentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type RoleAssignmentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: RoleAssignmentScalarWhereInput
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type RoleAssignmentScalarWhereInput = {
    AND?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
    OR?: RoleAssignmentScalarWhereInput[]
    NOT?: RoleAssignmentScalarWhereInput | RoleAssignmentScalarWhereInput[]
    id?: IntFilter<"RoleAssignment"> | number
    groupId?: IntFilter<"RoleAssignment"> | number
    workspaceId?: IntNullableFilter<"RoleAssignment"> | number | null
    projectId?: IntNullableFilter<"RoleAssignment"> | number | null
    role?: EnumAssignmentRoleFilter<"RoleAssignment"> | $Enums.AssignmentRole
    inheritToChildren?: BoolFilter<"RoleAssignment"> | boolean
    createdAt?: DateTimeFilter<"RoleAssignment"> | Date | string
    createdById?: IntNullableFilter<"RoleAssignment"> | number | null
  }

  export type WorkspaceCreateWithoutLogoInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLogoInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLogoInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLogoInput, WorkspaceUncheckedCreateWithoutLogoInput>
  }

  export type WorkspaceUpsertWithoutLogoInput = {
    update: XOR<WorkspaceUpdateWithoutLogoInput, WorkspaceUncheckedUpdateWithoutLogoInput>
    create: XOR<WorkspaceCreateWithoutLogoInput, WorkspaceUncheckedCreateWithoutLogoInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLogoInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLogoInput, WorkspaceUncheckedUpdateWithoutLogoInput>
  }

  export type WorkspaceUpdateWithoutLogoInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLogoInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutUsersInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutUsersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutWorkspacesInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceUpsertWithoutUsersInput = {
    update: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutUsersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type WorkspaceUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type WorkspaceCreateWithoutInvitationsInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutInvitationsCreatedInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutInvitationsCreatedInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutInvitationsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsCreatedInput, UserUncheckedCreateWithoutInvitationsCreatedInput>
  }

  export type WorkspaceUpsertWithoutInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type WorkspaceUpdateWithoutInvitationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutInvitationsCreatedInput = {
    update: XOR<UserUpdateWithoutInvitationsCreatedInput, UserUncheckedUpdateWithoutInvitationsCreatedInput>
    create: XOR<UserCreateWithoutInvitationsCreatedInput, UserUncheckedCreateWithoutInvitationsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsCreatedInput, UserUncheckedUpdateWithoutInvitationsCreatedInput>
  }

  export type UserUpdateWithoutInvitationsCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type WorkspaceUserCreateWithoutUserInput = {
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
  }

  export type WorkspaceUserUncheckedCreateWithoutUserInput = {
    id?: number
    workspaceId: number
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
  }

  export type WorkspaceUserCreateOrConnectWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserCreateManyUserInputEnvelope = {
    data: WorkspaceUserCreateManyUserInput | WorkspaceUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutCreatedByInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCreatedByInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCreatedByInput, WorkspaceUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkspaceCreateManyCreatedByInputEnvelope = {
    data: WorkspaceCreateManyCreatedByInput | WorkspaceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceInvitationCreateWithoutCreatorInput = {
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
  }

  export type WorkspaceInvitationUncheckedCreateWithoutCreatorInput = {
    id?: number
    workspaceId: number
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type WorkspaceInvitationCreateOrConnectWithoutCreatorInput = {
    where: WorkspaceInvitationWhereUniqueInput
    create: XOR<WorkspaceInvitationCreateWithoutCreatorInput, WorkspaceInvitationUncheckedCreateWithoutCreatorInput>
  }

  export type WorkspaceInvitationCreateManyCreatorInputEnvelope = {
    data: WorkspaceInvitationCreateManyCreatorInput | WorkspaceInvitationCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCreatorInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskCreateManyCreatorInputEnvelope = {
    data: TaskCreateManyCreatorInput | TaskCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssigneeCreateWithoutUserInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAssigneesInput
  }

  export type TaskAssigneeUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    createdAt?: Date | string
  }

  export type TaskAssigneeCreateOrConnectWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
  }

  export type TaskAssigneeCreateManyUserInputEnvelope = {
    data: TaskAssigneeCreateManyUserInput | TaskAssigneeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskCreateWithoutAssigneeInput = {
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutSubtasksInput
  }

  export type SubtaskUncheckedCreateWithoutAssigneeInput = {
    id?: number
    taskId: number
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskCreateOrConnectWithoutAssigneeInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput>
  }

  export type SubtaskCreateManyAssigneeInputEnvelope = {
    data: SubtaskCreateManyAssigneeInput | SubtaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutUserInput = {
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutUserInput = {
    id?: number
    taskId: number
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentCreateManyUserInputEnvelope = {
    data: AttachmentCreateManyUserInput | AttachmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RememberTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RememberTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RememberTokenCreateOrConnectWithoutUserInput = {
    where: RememberTokenWhereUniqueInput
    create: XOR<RememberTokenCreateWithoutUserInput, RememberTokenUncheckedCreateWithoutUserInput>
  }

  export type RememberTokenCreateManyUserInputEnvelope = {
    data: RememberTokenCreateManyUserInput | RememberTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: string
    title: string
    content?: string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutUserInput = {
    name: string
    keyPrefix: string
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    keyPrefix: string
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    ip: string
    userAgent: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    ip: string
    userAgent: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateManyUserInputEnvelope = {
    data: PasswordResetCreateManyUserInput | PasswordResetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LastLoginCreateWithoutUserInput = {
    authType: string
    ip: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LastLoginUncheckedCreateWithoutUserInput = {
    id?: number
    authType: string
    ip: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LastLoginCreateOrConnectWithoutUserInput = {
    where: LastLoginWhereUniqueInput
    create: XOR<LastLoginCreateWithoutUserInput, LastLoginUncheckedCreateWithoutUserInput>
  }

  export type LastLoginCreateManyUserInputEnvelope = {
    data: LastLoginCreateManyUserInput | LastLoginCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserMetadataCreateWithoutUserInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMetadataUncheckedCreateWithoutUserInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserMetadataCreateOrConnectWithoutUserInput = {
    where: UserMetadataWhereUniqueInput
    create: XOR<UserMetadataCreateWithoutUserInput, UserMetadataUncheckedCreateWithoutUserInput>
  }

  export type UserMetadataCreateManyUserInputEnvelope = {
    data: UserMetadataCreateManyUserInput | UserMetadataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserNotificationSettingCreateWithoutUserInput = {
    notificationType: string
    isEnabled?: boolean
  }

  export type UserNotificationSettingUncheckedCreateWithoutUserInput = {
    id?: number
    notificationType: string
    isEnabled?: boolean
  }

  export type UserNotificationSettingCreateOrConnectWithoutUserInput = {
    where: UserNotificationSettingWhereUniqueInput
    create: XOR<UserNotificationSettingCreateWithoutUserInput, UserNotificationSettingUncheckedCreateWithoutUserInput>
  }

  export type UserNotificationSettingCreateManyUserInputEnvelope = {
    data: UserNotificationSettingCreateManyUserInput | UserNotificationSettingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAvatarCreateWithoutUserInput = {
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAvatarUncheckedCreateWithoutUserInput = {
    id?: number
    data: Bytes
    mimeType: string
    size: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAvatarCreateOrConnectWithoutUserInput = {
    where: UserAvatarWhereUniqueInput
    create: XOR<UserAvatarCreateWithoutUserInput, UserAvatarUncheckedCreateWithoutUserInput>
  }

  export type InviteCreateWithoutInvitedByInput = {
    email: string
    token: string
    role?: $Enums.AppRole
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InviteUncheckedCreateWithoutInvitedByInput = {
    id?: number
    email: string
    token: string
    role?: $Enums.AppRole
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InviteCreateOrConnectWithoutInvitedByInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutInvitedByInput, InviteUncheckedCreateWithoutInvitedByInput>
  }

  export type InviteCreateManyInvitedByInputEnvelope = {
    data: InviteCreateManyInvitedByInput | InviteCreateManyInvitedByInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutUserInput = {
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    externalSync?: boolean
    group: GroupCreateNestedOneWithoutMembersInput
    addedBy?: UserCreateNestedOneWithoutGroupMembersAddedInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: number
    groupId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    addedById?: number | null
    externalSync?: boolean
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutAddedByInput = {
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    externalSync?: boolean
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateWithoutAddedByInput = {
    id?: number
    groupId: number
    userId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    externalSync?: boolean
  }

  export type GroupMemberCreateOrConnectWithoutAddedByInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutAddedByInput, GroupMemberUncheckedCreateWithoutAddedByInput>
  }

  export type GroupMemberCreateManyAddedByInputEnvelope = {
    data: GroupMemberCreateManyAddedByInput | GroupMemberCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    update: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceUserCreateWithoutUserInput, WorkspaceUserUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserWhereUniqueInput
    data: XOR<WorkspaceUserUpdateWithoutUserInput, WorkspaceUserUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceUserScalarWhereInput
    data: XOR<WorkspaceUserUpdateManyMutationInput, WorkspaceUserUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WorkspaceWhereUniqueInput
    update: XOR<WorkspaceUpdateWithoutCreatedByInput, WorkspaceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WorkspaceCreateWithoutCreatedByInput, WorkspaceUncheckedCreateWithoutCreatedByInput>
  }

  export type WorkspaceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WorkspaceWhereUniqueInput
    data: XOR<WorkspaceUpdateWithoutCreatedByInput, WorkspaceUncheckedUpdateWithoutCreatedByInput>
  }

  export type WorkspaceUpdateManyWithWhereWithoutCreatedByInput = {
    where: WorkspaceScalarWhereInput
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WorkspaceScalarWhereInput = {
    AND?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
    OR?: WorkspaceScalarWhereInput[]
    NOT?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
    id?: IntFilter<"Workspace"> | number
    name?: StringFilter<"Workspace"> | string
    slug?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    logoUrl?: StringNullableFilter<"Workspace"> | string | null
    settings?: JsonFilter<"Workspace">
    isActive?: BoolFilter<"Workspace"> | boolean
    createdById?: IntNullableFilter<"Workspace"> | number | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
  }

  export type WorkspaceInvitationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WorkspaceInvitationWhereUniqueInput
    update: XOR<WorkspaceInvitationUpdateWithoutCreatorInput, WorkspaceInvitationUncheckedUpdateWithoutCreatorInput>
    create: XOR<WorkspaceInvitationCreateWithoutCreatorInput, WorkspaceInvitationUncheckedCreateWithoutCreatorInput>
  }

  export type WorkspaceInvitationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WorkspaceInvitationWhereUniqueInput
    data: XOR<WorkspaceInvitationUpdateWithoutCreatorInput, WorkspaceInvitationUncheckedUpdateWithoutCreatorInput>
  }

  export type WorkspaceInvitationUpdateManyWithWhereWithoutCreatorInput = {
    where: WorkspaceInvitationScalarWhereInput
    data: XOR<WorkspaceInvitationUpdateManyMutationInput, WorkspaceInvitationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: IntFilter<"ProjectMember"> | number
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: IntFilter<"Task"> | number
    projectId?: IntFilter<"Task"> | number
    columnId?: IntFilter<"Task"> | number
    swimlaneId?: IntNullableFilter<"Task"> | number | null
    creatorId?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    reference?: StringNullableFilter<"Task"> | string | null
    priority?: IntFilter<"Task"> | number
    score?: IntFilter<"Task"> | number
    progress?: IntFilter<"Task"> | number
    position?: IntFilter<"Task"> | number
    color?: StringNullableFilter<"Task"> | string | null
    dateStarted?: DateTimeNullableFilter<"Task"> | Date | string | null
    dateDue?: DateTimeNullableFilter<"Task"> | Date | string | null
    dateCompleted?: DateTimeNullableFilter<"Task"> | Date | string | null
    reminderAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    timeEstimated?: FloatFilter<"Task"> | number
    timeSpent?: FloatFilter<"Task"> | number
    isActive?: BoolFilter<"Task"> | boolean
    isDraggable?: BoolFilter<"Task"> | boolean
    recurrenceData?: JsonNullableFilter<"Task">
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    milestoneId?: IntNullableFilter<"Task"> | number | null
    moduleId?: IntNullableFilter<"Task"> | number | null
    sprintId?: IntNullableFilter<"Task"> | number | null
    categoryId?: IntNullableFilter<"Task"> | number | null
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>
    create: XOR<TaskAssigneeCreateWithoutUserInput, TaskAssigneeUncheckedCreateWithoutUserInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutUserInput, TaskAssigneeUncheckedUpdateWithoutUserInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutUserInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskAssigneeScalarWhereInput = {
    AND?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    OR?: TaskAssigneeScalarWhereInput[]
    NOT?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    id?: IntFilter<"TaskAssignee"> | number
    taskId?: IntFilter<"TaskAssignee"> | number
    userId?: IntFilter<"TaskAssignee"> | number
    createdAt?: DateTimeFilter<"TaskAssignee"> | Date | string
  }

  export type SubtaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutAssigneeInput, SubtaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<SubtaskCreateWithoutAssigneeInput, SubtaskUncheckedCreateWithoutAssigneeInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutAssigneeInput, SubtaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type SubtaskScalarWhereInput = {
    AND?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    OR?: SubtaskScalarWhereInput[]
    NOT?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    id?: IntFilter<"Subtask"> | number
    taskId?: IntFilter<"Subtask"> | number
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusFilter<"Subtask"> | $Enums.SubtaskStatus
    position?: IntFilter<"Subtask"> | number
    assigneeId?: IntNullableFilter<"Subtask"> | number | null
    timeEstimated?: FloatFilter<"Subtask"> | number
    timeSpent?: FloatFilter<"Subtask"> | number
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    taskId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type AttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutUserInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: IntFilter<"Attachment"> | number
    taskId?: IntFilter<"Attachment"> | number
    userId?: IntFilter<"Attachment"> | number
    name?: StringFilter<"Attachment"> | string
    path?: StringFilter<"Attachment"> | string
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    size?: IntFilter<"Attachment"> | number
    isImage?: BoolFilter<"Attachment"> | boolean
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    data?: JsonFilter<"Session">
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type RememberTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RememberTokenWhereUniqueInput
    update: XOR<RememberTokenUpdateWithoutUserInput, RememberTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RememberTokenCreateWithoutUserInput, RememberTokenUncheckedCreateWithoutUserInput>
  }

  export type RememberTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RememberTokenWhereUniqueInput
    data: XOR<RememberTokenUpdateWithoutUserInput, RememberTokenUncheckedUpdateWithoutUserInput>
  }

  export type RememberTokenUpdateManyWithWhereWithoutUserInput = {
    where: RememberTokenScalarWhereInput
    data: XOR<RememberTokenUpdateManyMutationInput, RememberTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RememberTokenScalarWhereInput = {
    AND?: RememberTokenScalarWhereInput | RememberTokenScalarWhereInput[]
    OR?: RememberTokenScalarWhereInput[]
    NOT?: RememberTokenScalarWhereInput | RememberTokenScalarWhereInput[]
    id?: IntFilter<"RememberToken"> | number
    userId?: IntFilter<"RememberToken"> | number
    token?: StringFilter<"RememberToken"> | string
    expiresAt?: DateTimeFilter<"RememberToken"> | Date | string
    createdAt?: DateTimeFilter<"RememberToken"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringNullableFilter<"Notification"> | string | null
    data?: JsonFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: IntFilter<"Activity"> | number
    projectId?: IntFilter<"Activity"> | number
    userId?: IntNullableFilter<"Activity"> | number | null
    eventType?: StringFilter<"Activity"> | string
    entityType?: StringFilter<"Activity"> | string
    entityId?: IntFilter<"Activity"> | number
    changes?: JsonFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    userId?: IntFilter<"ApiKey"> | number
    name?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    permissions?: JsonFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type PasswordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetScalarWhereInput
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetScalarWhereInput = {
    AND?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    OR?: PasswordResetScalarWhereInput[]
    NOT?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    id?: IntFilter<"PasswordReset"> | number
    userId?: IntFilter<"PasswordReset"> | number
    token?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    ip?: StringFilter<"PasswordReset"> | string
    userAgent?: StringFilter<"PasswordReset"> | string
    isUsed?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
  }

  export type LastLoginUpsertWithWhereUniqueWithoutUserInput = {
    where: LastLoginWhereUniqueInput
    update: XOR<LastLoginUpdateWithoutUserInput, LastLoginUncheckedUpdateWithoutUserInput>
    create: XOR<LastLoginCreateWithoutUserInput, LastLoginUncheckedCreateWithoutUserInput>
  }

  export type LastLoginUpdateWithWhereUniqueWithoutUserInput = {
    where: LastLoginWhereUniqueInput
    data: XOR<LastLoginUpdateWithoutUserInput, LastLoginUncheckedUpdateWithoutUserInput>
  }

  export type LastLoginUpdateManyWithWhereWithoutUserInput = {
    where: LastLoginScalarWhereInput
    data: XOR<LastLoginUpdateManyMutationInput, LastLoginUncheckedUpdateManyWithoutUserInput>
  }

  export type LastLoginScalarWhereInput = {
    AND?: LastLoginScalarWhereInput | LastLoginScalarWhereInput[]
    OR?: LastLoginScalarWhereInput[]
    NOT?: LastLoginScalarWhereInput | LastLoginScalarWhereInput[]
    id?: IntFilter<"LastLogin"> | number
    userId?: IntFilter<"LastLogin"> | number
    authType?: StringFilter<"LastLogin"> | string
    ip?: StringFilter<"LastLogin"> | string
    userAgent?: StringFilter<"LastLogin"> | string
    createdAt?: DateTimeFilter<"LastLogin"> | Date | string
  }

  export type UserMetadataUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMetadataWhereUniqueInput
    update: XOR<UserMetadataUpdateWithoutUserInput, UserMetadataUncheckedUpdateWithoutUserInput>
    create: XOR<UserMetadataCreateWithoutUserInput, UserMetadataUncheckedCreateWithoutUserInput>
  }

  export type UserMetadataUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMetadataWhereUniqueInput
    data: XOR<UserMetadataUpdateWithoutUserInput, UserMetadataUncheckedUpdateWithoutUserInput>
  }

  export type UserMetadataUpdateManyWithWhereWithoutUserInput = {
    where: UserMetadataScalarWhereInput
    data: XOR<UserMetadataUpdateManyMutationInput, UserMetadataUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMetadataScalarWhereInput = {
    AND?: UserMetadataScalarWhereInput | UserMetadataScalarWhereInput[]
    OR?: UserMetadataScalarWhereInput[]
    NOT?: UserMetadataScalarWhereInput | UserMetadataScalarWhereInput[]
    id?: IntFilter<"UserMetadata"> | number
    userId?: IntFilter<"UserMetadata"> | number
    key?: StringFilter<"UserMetadata"> | string
    value?: StringFilter<"UserMetadata"> | string
    createdAt?: DateTimeFilter<"UserMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"UserMetadata"> | Date | string
  }

  export type UserNotificationSettingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNotificationSettingWhereUniqueInput
    update: XOR<UserNotificationSettingUpdateWithoutUserInput, UserNotificationSettingUncheckedUpdateWithoutUserInput>
    create: XOR<UserNotificationSettingCreateWithoutUserInput, UserNotificationSettingUncheckedCreateWithoutUserInput>
  }

  export type UserNotificationSettingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNotificationSettingWhereUniqueInput
    data: XOR<UserNotificationSettingUpdateWithoutUserInput, UserNotificationSettingUncheckedUpdateWithoutUserInput>
  }

  export type UserNotificationSettingUpdateManyWithWhereWithoutUserInput = {
    where: UserNotificationSettingScalarWhereInput
    data: XOR<UserNotificationSettingUpdateManyMutationInput, UserNotificationSettingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserNotificationSettingScalarWhereInput = {
    AND?: UserNotificationSettingScalarWhereInput | UserNotificationSettingScalarWhereInput[]
    OR?: UserNotificationSettingScalarWhereInput[]
    NOT?: UserNotificationSettingScalarWhereInput | UserNotificationSettingScalarWhereInput[]
    id?: IntFilter<"UserNotificationSetting"> | number
    userId?: IntFilter<"UserNotificationSetting"> | number
    notificationType?: StringFilter<"UserNotificationSetting"> | string
    isEnabled?: BoolFilter<"UserNotificationSetting"> | boolean
  }

  export type UserAvatarUpsertWithoutUserInput = {
    update: XOR<UserAvatarUpdateWithoutUserInput, UserAvatarUncheckedUpdateWithoutUserInput>
    create: XOR<UserAvatarCreateWithoutUserInput, UserAvatarUncheckedCreateWithoutUserInput>
    where?: UserAvatarWhereInput
  }

  export type UserAvatarUpdateToOneWithWhereWithoutUserInput = {
    where?: UserAvatarWhereInput
    data: XOR<UserAvatarUpdateWithoutUserInput, UserAvatarUncheckedUpdateWithoutUserInput>
  }

  export type UserAvatarUpdateWithoutUserInput = {
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAvatarUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: BytesFieldUpdateOperationsInput | Bytes
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutInvitedByInput, InviteUncheckedUpdateWithoutInvitedByInput>
    create: XOR<InviteCreateWithoutInvitedByInput, InviteUncheckedCreateWithoutInvitedByInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutInvitedByInput, InviteUncheckedUpdateWithoutInvitedByInput>
  }

  export type InviteUpdateManyWithWhereWithoutInvitedByInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutInvitedByInput>
  }

  export type InviteScalarWhereInput = {
    AND?: InviteScalarWhereInput | InviteScalarWhereInput[]
    OR?: InviteScalarWhereInput[]
    NOT?: InviteScalarWhereInput | InviteScalarWhereInput[]
    id?: IntFilter<"Invite"> | number
    email?: StringFilter<"Invite"> | string
    token?: StringFilter<"Invite"> | string
    role?: EnumAppRoleFilter<"Invite"> | $Enums.AppRole
    invitedById?: IntFilter<"Invite"> | number
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: IntFilter<"GroupMember"> | number
    groupId?: IntFilter<"GroupMember"> | number
    userId?: IntFilter<"GroupMember"> | number
    memberType?: EnumMemberTypeFilter<"GroupMember"> | $Enums.MemberType
    expiresAt?: DateTimeNullableFilter<"GroupMember"> | Date | string | null
    addedAt?: DateTimeFilter<"GroupMember"> | Date | string
    addedById?: IntNullableFilter<"GroupMember"> | number | null
    externalSync?: BoolFilter<"GroupMember"> | boolean
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutAddedByInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutAddedByInput, GroupMemberUncheckedUpdateWithoutAddedByInput>
    create: XOR<GroupMemberCreateWithoutAddedByInput, GroupMemberUncheckedCreateWithoutAddedByInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutAddedByInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutAddedByInput, GroupMemberUncheckedUpdateWithoutAddedByInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutAddedByInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutAddedByInput>
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutRememberTokensInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutRememberTokensInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutRememberTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRememberTokensInput, UserUncheckedCreateWithoutRememberTokensInput>
  }

  export type UserUpsertWithoutRememberTokensInput = {
    update: XOR<UserUpdateWithoutRememberTokensInput, UserUncheckedUpdateWithoutRememberTokensInput>
    create: XOR<UserCreateWithoutRememberTokensInput, UserUncheckedCreateWithoutRememberTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRememberTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRememberTokensInput, UserUncheckedUpdateWithoutRememberTokensInput>
  }

  export type UserUpdateWithoutRememberTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRememberTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutInvitesSentInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutInvitesSentInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutInvitesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
  }

  export type UserUpsertWithoutInvitesSentInput = {
    update: XOR<UserUpdateWithoutInvitesSentInput, UserUncheckedUpdateWithoutInvitesSentInput>
    create: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitesSentInput, UserUncheckedUpdateWithoutInvitesSentInput>
  }

  export type UserUpdateWithoutInvitesSentInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitesSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type WorkspaceCreateWithoutProjectsInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutProjectsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ColumnCreateWithoutProjectInput = {
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutColumnInput
  }

  export type ColumnUncheckedCreateWithoutProjectInput = {
    id?: number
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutColumnInput
  }

  export type ColumnCreateOrConnectWithoutProjectInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutProjectInput, ColumnUncheckedCreateWithoutProjectInput>
  }

  export type ColumnCreateManyProjectInputEnvelope = {
    data: ColumnCreateManyProjectInput | ColumnCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SwimlaneCreateWithoutProjectInput = {
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutSwimlaneInput
  }

  export type SwimlaneUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSwimlaneInput
  }

  export type SwimlaneCreateOrConnectWithoutProjectInput = {
    where: SwimlaneWhereUniqueInput
    create: XOR<SwimlaneCreateWithoutProjectInput, SwimlaneUncheckedCreateWithoutProjectInput>
  }

  export type SwimlaneCreateManyProjectInputEnvelope = {
    data: SwimlaneCreateManyProjectInput | SwimlaneCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutProjectInput = {
    name: string
    color?: string
    createdAt?: Date | string
    tasks?: TaskTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    color?: string
    createdAt?: Date | string
    tasks?: TaskTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutProjectInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput>
  }

  export type TagCreateManyProjectInputEnvelope = {
    data: TagCreateManyProjectInput | TagCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProjectInput = {
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProjectInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProjectInput, CategoryUncheckedCreateWithoutProjectInput>
  }

  export type CategoryCreateManyProjectInputEnvelope = {
    data: CategoryCreateManyProjectInput | CategoryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CustomFieldCreateWithoutProjectInput = {
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
    values?: TaskCustomValueCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
    values?: TaskCustomValueUncheckedCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldCreateOrConnectWithoutProjectInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutProjectInput, CustomFieldUncheckedCreateWithoutProjectInput>
  }

  export type CustomFieldCreateManyProjectInputEnvelope = {
    data: CustomFieldCreateManyProjectInput | CustomFieldCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutProjectInput = {
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutProjectInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutProjectInput, ModuleUncheckedCreateWithoutProjectInput>
  }

  export type ModuleCreateManyProjectInputEnvelope = {
    data: ModuleCreateManyProjectInput | ModuleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutProjectInput = {
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneCreateOrConnectWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneCreateManyProjectInputEnvelope = {
    data: MilestoneCreateManyProjectInput | MilestoneCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SprintCreateWithoutProjectInput = {
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutProjectInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintCreateManyProjectInputEnvelope = {
    data: SprintCreateManyProjectInput | SprintCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutProjectInput = {
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: BudgetLineCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: BudgetLineUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutProjectInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
  }

  export type BudgetCreateManyProjectInputEnvelope = {
    data: BudgetCreateManyProjectInput | BudgetCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WikiPageCreateWithoutProjectInput = {
    title: string
    content: string
    creatorId?: number | null
    modifierId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageUncheckedCreateWithoutProjectInput = {
    id?: number
    title: string
    content: string
    creatorId?: number | null
    modifierId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageCreateOrConnectWithoutProjectInput = {
    where: WikiPageWhereUniqueInput
    create: XOR<WikiPageCreateWithoutProjectInput, WikiPageUncheckedCreateWithoutProjectInput>
  }

  export type WikiPageCreateManyProjectInputEnvelope = {
    data: WikiPageCreateManyProjectInput | WikiPageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutProjectInput = {
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutProjectInput = {
    id?: number
    userId?: number | null
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
  }

  export type ActivityCreateManyProjectInputEnvelope = {
    data: ActivityCreateManyProjectInput | ActivityCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectGroupMemberCreateWithoutProjectInput = {
    position?: number
    createdAt?: Date | string
    projectGroup: ProjectGroupCreateNestedOneWithoutProjectsInput
  }

  export type ProjectGroupMemberUncheckedCreateWithoutProjectInput = {
    id?: number
    projectGroupId: number
    position?: number
    createdAt?: Date | string
  }

  export type ProjectGroupMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectGroupMemberWhereUniqueInput
    create: XOR<ProjectGroupMemberCreateWithoutProjectInput, ProjectGroupMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectGroupMemberCreateManyProjectInputEnvelope = {
    data: ProjectGroupMemberCreateManyProjectInput | ProjectGroupMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutProjectInput = {
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookCreateOrConnectWithoutProjectInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutProjectInput, WebhookUncheckedCreateWithoutProjectInput>
  }

  export type WebhookCreateManyProjectInputEnvelope = {
    data: WebhookCreateManyProjectInput | WebhookCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutProjectInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutProjectInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutProjectInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutProjectInput, GroupUncheckedCreateWithoutProjectInput>
  }

  export type GroupCreateManyProjectInputEnvelope = {
    data: GroupCreateManyProjectInput | GroupCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssignmentCreateWithoutProjectInput = {
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
    group: GroupCreateNestedOneWithoutRoleAssignmentsInput
    workspace?: WorkspaceCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type RoleAssignmentUncheckedCreateWithoutProjectInput = {
    id?: number
    groupId: number
    workspaceId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type RoleAssignmentCreateOrConnectWithoutProjectInput = {
    where: RoleAssignmentWhereUniqueInput
    create: XOR<RoleAssignmentCreateWithoutProjectInput, RoleAssignmentUncheckedCreateWithoutProjectInput>
  }

  export type RoleAssignmentCreateManyProjectInputEnvelope = {
    data: RoleAssignmentCreateManyProjectInput | RoleAssignmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutProjectsInput = {
    update: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutProjectsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type WorkspaceUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ColumnUpsertWithWhereUniqueWithoutProjectInput = {
    where: ColumnWhereUniqueInput
    update: XOR<ColumnUpdateWithoutProjectInput, ColumnUncheckedUpdateWithoutProjectInput>
    create: XOR<ColumnCreateWithoutProjectInput, ColumnUncheckedCreateWithoutProjectInput>
  }

  export type ColumnUpdateWithWhereUniqueWithoutProjectInput = {
    where: ColumnWhereUniqueInput
    data: XOR<ColumnUpdateWithoutProjectInput, ColumnUncheckedUpdateWithoutProjectInput>
  }

  export type ColumnUpdateManyWithWhereWithoutProjectInput = {
    where: ColumnScalarWhereInput
    data: XOR<ColumnUpdateManyMutationInput, ColumnUncheckedUpdateManyWithoutProjectInput>
  }

  export type ColumnScalarWhereInput = {
    AND?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
    OR?: ColumnScalarWhereInput[]
    NOT?: ColumnScalarWhereInput | ColumnScalarWhereInput[]
    id?: IntFilter<"Column"> | number
    projectId?: IntFilter<"Column"> | number
    title?: StringFilter<"Column"> | string
    description?: StringNullableFilter<"Column"> | string | null
    position?: IntFilter<"Column"> | number
    taskLimit?: IntFilter<"Column"> | number
    isCollapsed?: BoolFilter<"Column"> | boolean
    showClosed?: BoolFilter<"Column"> | boolean
    createdAt?: DateTimeFilter<"Column"> | Date | string
    updatedAt?: DateTimeFilter<"Column"> | Date | string
  }

  export type SwimlaneUpsertWithWhereUniqueWithoutProjectInput = {
    where: SwimlaneWhereUniqueInput
    update: XOR<SwimlaneUpdateWithoutProjectInput, SwimlaneUncheckedUpdateWithoutProjectInput>
    create: XOR<SwimlaneCreateWithoutProjectInput, SwimlaneUncheckedCreateWithoutProjectInput>
  }

  export type SwimlaneUpdateWithWhereUniqueWithoutProjectInput = {
    where: SwimlaneWhereUniqueInput
    data: XOR<SwimlaneUpdateWithoutProjectInput, SwimlaneUncheckedUpdateWithoutProjectInput>
  }

  export type SwimlaneUpdateManyWithWhereWithoutProjectInput = {
    where: SwimlaneScalarWhereInput
    data: XOR<SwimlaneUpdateManyMutationInput, SwimlaneUncheckedUpdateManyWithoutProjectInput>
  }

  export type SwimlaneScalarWhereInput = {
    AND?: SwimlaneScalarWhereInput | SwimlaneScalarWhereInput[]
    OR?: SwimlaneScalarWhereInput[]
    NOT?: SwimlaneScalarWhereInput | SwimlaneScalarWhereInput[]
    id?: IntFilter<"Swimlane"> | number
    projectId?: IntFilter<"Swimlane"> | number
    name?: StringFilter<"Swimlane"> | string
    description?: StringNullableFilter<"Swimlane"> | string | null
    position?: IntFilter<"Swimlane"> | number
    isActive?: BoolFilter<"Swimlane"> | boolean
    createdAt?: DateTimeFilter<"Swimlane"> | Date | string
    updatedAt?: DateTimeFilter<"Swimlane"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TagUpsertWithWhereUniqueWithoutProjectInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutProjectInput, TagUncheckedUpdateWithoutProjectInput>
    create: XOR<TagCreateWithoutProjectInput, TagUncheckedCreateWithoutProjectInput>
  }

  export type TagUpdateWithWhereUniqueWithoutProjectInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutProjectInput, TagUncheckedUpdateWithoutProjectInput>
  }

  export type TagUpdateManyWithWhereWithoutProjectInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutProjectInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    projectId?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutProjectInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProjectInput, CategoryUncheckedUpdateWithoutProjectInput>
    create: XOR<CategoryCreateWithoutProjectInput, CategoryUncheckedCreateWithoutProjectInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProjectInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProjectInput, CategoryUncheckedUpdateWithoutProjectInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProjectInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutProjectInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    projectId?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type CustomFieldUpsertWithWhereUniqueWithoutProjectInput = {
    where: CustomFieldWhereUniqueInput
    update: XOR<CustomFieldUpdateWithoutProjectInput, CustomFieldUncheckedUpdateWithoutProjectInput>
    create: XOR<CustomFieldCreateWithoutProjectInput, CustomFieldUncheckedCreateWithoutProjectInput>
  }

  export type CustomFieldUpdateWithWhereUniqueWithoutProjectInput = {
    where: CustomFieldWhereUniqueInput
    data: XOR<CustomFieldUpdateWithoutProjectInput, CustomFieldUncheckedUpdateWithoutProjectInput>
  }

  export type CustomFieldUpdateManyWithWhereWithoutProjectInput = {
    where: CustomFieldScalarWhereInput
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyWithoutProjectInput>
  }

  export type CustomFieldScalarWhereInput = {
    AND?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    OR?: CustomFieldScalarWhereInput[]
    NOT?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    id?: IntFilter<"CustomField"> | number
    projectId?: IntFilter<"CustomField"> | number
    name?: StringFilter<"CustomField"> | string
    type?: EnumCustomFieldTypeFilter<"CustomField"> | $Enums.CustomFieldType
    options?: JsonNullableFilter<"CustomField">
    isRequired?: BoolFilter<"CustomField"> | boolean
    position?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutProjectInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutProjectInput, ModuleUncheckedUpdateWithoutProjectInput>
    create: XOR<ModuleCreateWithoutProjectInput, ModuleUncheckedCreateWithoutProjectInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutProjectInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutProjectInput, ModuleUncheckedUpdateWithoutProjectInput>
  }

  export type ModuleUpdateManyWithWhereWithoutProjectInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutProjectInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: IntFilter<"Module"> | number
    projectId?: IntFilter<"Module"> | number
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    color?: StringFilter<"Module"> | string
    position?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutProjectInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: IntFilter<"Milestone"> | number
    projectId?: IntFilter<"Milestone"> | number
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    dateDue?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    isCompleted?: BoolFilter<"Milestone"> | boolean
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type SprintUpsertWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    update: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintUpdateWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    data: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
  }

  export type SprintUpdateManyWithWhereWithoutProjectInput = {
    where: SprintScalarWhereInput
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyWithoutProjectInput>
  }

  export type SprintScalarWhereInput = {
    AND?: SprintScalarWhereInput | SprintScalarWhereInput[]
    OR?: SprintScalarWhereInput[]
    NOT?: SprintScalarWhereInput | SprintScalarWhereInput[]
    id?: IntFilter<"Sprint"> | number
    projectId?: IntFilter<"Sprint"> | number
    name?: StringFilter<"Sprint"> | string
    description?: StringNullableFilter<"Sprint"> | string | null
    status?: EnumSprintStatusFilter<"Sprint"> | $Enums.SprintStatus
    dateStart?: DateTimeFilter<"Sprint"> | Date | string
    dateEnd?: DateTimeFilter<"Sprint"> | Date | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutProjectInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutProjectInput, BudgetUncheckedUpdateWithoutProjectInput>
    create: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutProjectInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutProjectInput, BudgetUncheckedUpdateWithoutProjectInput>
  }

  export type BudgetUpdateManyWithWhereWithoutProjectInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutProjectInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: IntFilter<"Budget"> | number
    projectId?: IntFilter<"Budget"> | number
    name?: StringFilter<"Budget"> | string
    amount?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type WikiPageUpsertWithWhereUniqueWithoutProjectInput = {
    where: WikiPageWhereUniqueInput
    update: XOR<WikiPageUpdateWithoutProjectInput, WikiPageUncheckedUpdateWithoutProjectInput>
    create: XOR<WikiPageCreateWithoutProjectInput, WikiPageUncheckedCreateWithoutProjectInput>
  }

  export type WikiPageUpdateWithWhereUniqueWithoutProjectInput = {
    where: WikiPageWhereUniqueInput
    data: XOR<WikiPageUpdateWithoutProjectInput, WikiPageUncheckedUpdateWithoutProjectInput>
  }

  export type WikiPageUpdateManyWithWhereWithoutProjectInput = {
    where: WikiPageScalarWhereInput
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyWithoutProjectInput>
  }

  export type WikiPageScalarWhereInput = {
    AND?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
    OR?: WikiPageScalarWhereInput[]
    NOT?: WikiPageScalarWhereInput | WikiPageScalarWhereInput[]
    id?: IntFilter<"WikiPage"> | number
    projectId?: IntFilter<"WikiPage"> | number
    title?: StringFilter<"WikiPage"> | string
    content?: StringFilter<"WikiPage"> | string
    creatorId?: IntNullableFilter<"WikiPage"> | number | null
    modifierId?: IntNullableFilter<"WikiPage"> | number | null
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>
  }

  export type ActivityUpdateManyWithWhereWithoutProjectInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectGroupMemberWhereUniqueInput
    update: XOR<ProjectGroupMemberUpdateWithoutProjectInput, ProjectGroupMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectGroupMemberCreateWithoutProjectInput, ProjectGroupMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectGroupMemberWhereUniqueInput
    data: XOR<ProjectGroupMemberUpdateWithoutProjectInput, ProjectGroupMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectGroupMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectGroupMemberScalarWhereInput
    data: XOR<ProjectGroupMemberUpdateManyMutationInput, ProjectGroupMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectGroupMemberScalarWhereInput = {
    AND?: ProjectGroupMemberScalarWhereInput | ProjectGroupMemberScalarWhereInput[]
    OR?: ProjectGroupMemberScalarWhereInput[]
    NOT?: ProjectGroupMemberScalarWhereInput | ProjectGroupMemberScalarWhereInput[]
    id?: IntFilter<"ProjectGroupMember"> | number
    projectGroupId?: IntFilter<"ProjectGroupMember"> | number
    projectId?: IntFilter<"ProjectGroupMember"> | number
    position?: IntFilter<"ProjectGroupMember"> | number
    createdAt?: DateTimeFilter<"ProjectGroupMember"> | Date | string
  }

  export type WebhookUpsertWithWhereUniqueWithoutProjectInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutProjectInput, WebhookUncheckedUpdateWithoutProjectInput>
    create: XOR<WebhookCreateWithoutProjectInput, WebhookUncheckedCreateWithoutProjectInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutProjectInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutProjectInput, WebhookUncheckedUpdateWithoutProjectInput>
  }

  export type WebhookUpdateManyWithWhereWithoutProjectInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutProjectInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: IntFilter<"Webhook"> | number
    projectId?: IntFilter<"Webhook"> | number
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: JsonFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    lastSuccess?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    failureCount?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutProjectInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutProjectInput, GroupUncheckedUpdateWithoutProjectInput>
    create: XOR<GroupCreateWithoutProjectInput, GroupUncheckedCreateWithoutProjectInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutProjectInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutProjectInput, GroupUncheckedUpdateWithoutProjectInput>
  }

  export type GroupUpdateManyWithWhereWithoutProjectInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutProjectInput>
  }

  export type RoleAssignmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: RoleAssignmentWhereUniqueInput
    update: XOR<RoleAssignmentUpdateWithoutProjectInput, RoleAssignmentUncheckedUpdateWithoutProjectInput>
    create: XOR<RoleAssignmentCreateWithoutProjectInput, RoleAssignmentUncheckedCreateWithoutProjectInput>
  }

  export type RoleAssignmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: RoleAssignmentWhereUniqueInput
    data: XOR<RoleAssignmentUpdateWithoutProjectInput, RoleAssignmentUncheckedUpdateWithoutProjectInput>
  }

  export type RoleAssignmentUpdateManyWithWhereWithoutProjectInput = {
    where: RoleAssignmentScalarWhereInput
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembersInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutProjectMembersInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutProjectMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembersInput = {
    update: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type UserUpdateWithoutProjectMembersInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProjectCreateWithoutColumnsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutColumnsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutColumnsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutColumnsInput, ProjectUncheckedCreateWithoutColumnsInput>
  }

  export type TaskCreateWithoutColumnInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutColumnInput = {
    id?: number
    projectId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutColumnInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput>
  }

  export type TaskCreateManyColumnInputEnvelope = {
    data: TaskCreateManyColumnInput | TaskCreateManyColumnInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutColumnsInput = {
    update: XOR<ProjectUpdateWithoutColumnsInput, ProjectUncheckedUpdateWithoutColumnsInput>
    create: XOR<ProjectCreateWithoutColumnsInput, ProjectUncheckedCreateWithoutColumnsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutColumnsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutColumnsInput, ProjectUncheckedUpdateWithoutColumnsInput>
  }

  export type ProjectUpdateWithoutColumnsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutColumnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutColumnInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutColumnInput, TaskUncheckedUpdateWithoutColumnInput>
    create: XOR<TaskCreateWithoutColumnInput, TaskUncheckedCreateWithoutColumnInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutColumnInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutColumnInput, TaskUncheckedUpdateWithoutColumnInput>
  }

  export type TaskUpdateManyWithWhereWithoutColumnInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutColumnInput>
  }

  export type ProjectCreateWithoutSwimlanesInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSwimlanesInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSwimlanesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSwimlanesInput, ProjectUncheckedCreateWithoutSwimlanesInput>
  }

  export type TaskCreateWithoutSwimlaneInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSwimlaneInput = {
    id?: number
    projectId: number
    columnId: number
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSwimlaneInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSwimlaneInput, TaskUncheckedCreateWithoutSwimlaneInput>
  }

  export type TaskCreateManySwimlaneInputEnvelope = {
    data: TaskCreateManySwimlaneInput | TaskCreateManySwimlaneInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSwimlanesInput = {
    update: XOR<ProjectUpdateWithoutSwimlanesInput, ProjectUncheckedUpdateWithoutSwimlanesInput>
    create: XOR<ProjectCreateWithoutSwimlanesInput, ProjectUncheckedCreateWithoutSwimlanesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSwimlanesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSwimlanesInput, ProjectUncheckedUpdateWithoutSwimlanesInput>
  }

  export type ProjectUpdateWithoutSwimlanesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSwimlanesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutSwimlaneInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutSwimlaneInput, TaskUncheckedUpdateWithoutSwimlaneInput>
    create: XOR<TaskCreateWithoutSwimlaneInput, TaskUncheckedCreateWithoutSwimlaneInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutSwimlaneInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutSwimlaneInput, TaskUncheckedUpdateWithoutSwimlaneInput>
  }

  export type TaskUpdateManyWithWhereWithoutSwimlaneInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutSwimlaneInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type ColumnCreateWithoutTasksInput = {
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutColumnsInput
  }

  export type ColumnUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColumnCreateOrConnectWithoutTasksInput = {
    where: ColumnWhereUniqueInput
    create: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
  }

  export type SwimlaneCreateWithoutTasksInput = {
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSwimlanesInput
  }

  export type SwimlaneUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwimlaneCreateOrConnectWithoutTasksInput = {
    where: SwimlaneWhereUniqueInput
    create: XOR<SwimlaneCreateWithoutTasksInput, SwimlaneUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type MilestoneCreateWithoutTasksInput = {
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutTasksInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutTasksInput, MilestoneUncheckedCreateWithoutTasksInput>
  }

  export type ModuleCreateWithoutTasksInput = {
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutModulesInput
  }

  export type ModuleUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateOrConnectWithoutTasksInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutTasksInput, ModuleUncheckedCreateWithoutTasksInput>
  }

  export type SprintCreateWithoutTasksInput = {
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
  }

  export type SprintUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintCreateOrConnectWithoutTasksInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
  }

  export type CategoryCreateWithoutTasksInput = {
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutTasksInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTasksInput, CategoryUncheckedCreateWithoutTasksInput>
  }

  export type TaskAssigneeCreateWithoutTaskInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TaskAssigneeUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type TaskAssigneeCreateOrConnectWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeCreateManyTaskInputEnvelope = {
    data: TaskAssigneeCreateManyTaskInput | TaskAssigneeCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskCreateWithoutTaskInput = {
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutSubtasksAssignedInput
  }

  export type SubtaskUncheckedCreateWithoutTaskInput = {
    id?: number
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    assigneeId?: number | null
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskCreateOrConnectWithoutTaskInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput>
  }

  export type SubtaskCreateManyTaskInputEnvelope = {
    data: SubtaskCreateManyTaskInput | SubtaskCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTaskInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTaskInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentCreateManyTaskInputEnvelope = {
    data: CommentCreateManyTaskInput | CommentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutTaskInput = {
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutTaskInput = {
    id?: number
    userId: number
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutTaskInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput>
  }

  export type AttachmentCreateManyTaskInputEnvelope = {
    data: AttachmentCreateManyTaskInput | AttachmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskTagCreateWithoutTaskInput = {
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutTasksInput
  }

  export type TaskTagUncheckedCreateWithoutTaskInput = {
    id?: number
    tagId: number
    createdAt?: Date | string
  }

  export type TaskTagCreateOrConnectWithoutTaskInput = {
    where: TaskTagWhereUniqueInput
    create: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput>
  }

  export type TaskTagCreateManyTaskInputEnvelope = {
    data: TaskTagCreateManyTaskInput | TaskTagCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCustomValueCreateWithoutTaskInput = {
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customField: CustomFieldCreateNestedOneWithoutValuesInput
  }

  export type TaskCustomValueUncheckedCreateWithoutTaskInput = {
    id?: number
    customFieldId: number
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCustomValueCreateOrConnectWithoutTaskInput = {
    where: TaskCustomValueWhereUniqueInput
    create: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput>
  }

  export type TaskCustomValueCreateManyTaskInputEnvelope = {
    data: TaskCustomValueCreateManyTaskInput | TaskCustomValueCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskLinkCreateWithoutTaskInput = {
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
    oppositeTask: TaskCreateNestedOneWithoutLinksToInput
  }

  export type TaskLinkUncheckedCreateWithoutTaskInput = {
    id?: number
    oppositeTaskId: number
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
  }

  export type TaskLinkCreateOrConnectWithoutTaskInput = {
    where: TaskLinkWhereUniqueInput
    create: XOR<TaskLinkCreateWithoutTaskInput, TaskLinkUncheckedCreateWithoutTaskInput>
  }

  export type TaskLinkCreateManyTaskInputEnvelope = {
    data: TaskLinkCreateManyTaskInput | TaskLinkCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskLinkCreateWithoutOppositeTaskInput = {
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutLinksFromInput
  }

  export type TaskLinkUncheckedCreateWithoutOppositeTaskInput = {
    id?: number
    taskId: number
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
  }

  export type TaskLinkCreateOrConnectWithoutOppositeTaskInput = {
    where: TaskLinkWhereUniqueInput
    create: XOR<TaskLinkCreateWithoutOppositeTaskInput, TaskLinkUncheckedCreateWithoutOppositeTaskInput>
  }

  export type TaskLinkCreateManyOppositeTaskInputEnvelope = {
    data: TaskLinkCreateManyOppositeTaskInput | TaskLinkCreateManyOppositeTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskSessionCreateWithoutTaskInput = {
    sessionId: string
    linkType?: $Enums.TaskSessionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type TaskSessionUncheckedCreateWithoutTaskInput = {
    id?: number
    sessionId: string
    linkType?: $Enums.TaskSessionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type TaskSessionCreateOrConnectWithoutTaskInput = {
    where: TaskSessionWhereUniqueInput
    create: XOR<TaskSessionCreateWithoutTaskInput, TaskSessionUncheckedCreateWithoutTaskInput>
  }

  export type TaskSessionCreateManyTaskInputEnvelope = {
    data: TaskSessionCreateManyTaskInput | TaskSessionCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ColumnUpsertWithoutTasksInput = {
    update: XOR<ColumnUpdateWithoutTasksInput, ColumnUncheckedUpdateWithoutTasksInput>
    create: XOR<ColumnCreateWithoutTasksInput, ColumnUncheckedCreateWithoutTasksInput>
    where?: ColumnWhereInput
  }

  export type ColumnUpdateToOneWithWhereWithoutTasksInput = {
    where?: ColumnWhereInput
    data: XOR<ColumnUpdateWithoutTasksInput, ColumnUncheckedUpdateWithoutTasksInput>
  }

  export type ColumnUpdateWithoutTasksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutColumnsNestedInput
  }

  export type ColumnUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwimlaneUpsertWithoutTasksInput = {
    update: XOR<SwimlaneUpdateWithoutTasksInput, SwimlaneUncheckedUpdateWithoutTasksInput>
    create: XOR<SwimlaneCreateWithoutTasksInput, SwimlaneUncheckedCreateWithoutTasksInput>
    where?: SwimlaneWhereInput
  }

  export type SwimlaneUpdateToOneWithWhereWithoutTasksInput = {
    where?: SwimlaneWhereInput
    data: XOR<SwimlaneUpdateWithoutTasksInput, SwimlaneUncheckedUpdateWithoutTasksInput>
  }

  export type SwimlaneUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSwimlanesNestedInput
  }

  export type SwimlaneUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type MilestoneUpsertWithoutTasksInput = {
    update: XOR<MilestoneUpdateWithoutTasksInput, MilestoneUncheckedUpdateWithoutTasksInput>
    create: XOR<MilestoneCreateWithoutTasksInput, MilestoneUncheckedCreateWithoutTasksInput>
    where?: MilestoneWhereInput
  }

  export type MilestoneUpdateToOneWithWhereWithoutTasksInput = {
    where?: MilestoneWhereInput
    data: XOR<MilestoneUpdateWithoutTasksInput, MilestoneUncheckedUpdateWithoutTasksInput>
  }

  export type MilestoneUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpsertWithoutTasksInput = {
    update: XOR<ModuleUpdateWithoutTasksInput, ModuleUncheckedUpdateWithoutTasksInput>
    create: XOR<ModuleCreateWithoutTasksInput, ModuleUncheckedCreateWithoutTasksInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutTasksInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutTasksInput, ModuleUncheckedUpdateWithoutTasksInput>
  }

  export type ModuleUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUpsertWithoutTasksInput = {
    update: XOR<SprintUpdateWithoutTasksInput, SprintUncheckedUpdateWithoutTasksInput>
    create: XOR<SprintCreateWithoutTasksInput, SprintUncheckedCreateWithoutTasksInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutTasksInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutTasksInput, SprintUncheckedUpdateWithoutTasksInput>
  }

  export type SprintUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
  }

  export type SprintUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutTasksInput = {
    update: XOR<CategoryUpdateWithoutTasksInput, CategoryUncheckedUpdateWithoutTasksInput>
    create: XOR<CategoryCreateWithoutTasksInput, CategoryUncheckedCreateWithoutTasksInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTasksInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTasksInput, CategoryUncheckedUpdateWithoutTasksInput>
  }

  export type CategoryUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutTaskInput>
  }

  export type SubtaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutTaskInput, SubtaskUncheckedUpdateWithoutTaskInput>
    create: XOR<SubtaskCreateWithoutTaskInput, SubtaskUncheckedCreateWithoutTaskInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutTaskInput, SubtaskUncheckedUpdateWithoutTaskInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutTaskInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
  }

  export type CommentUpdateManyWithWhereWithoutTaskInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutTaskInput, AttachmentUncheckedUpdateWithoutTaskInput>
    create: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutTaskInput, AttachmentUncheckedUpdateWithoutTaskInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutTaskInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskTagUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskTagWhereUniqueInput
    update: XOR<TaskTagUpdateWithoutTaskInput, TaskTagUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskTagCreateWithoutTaskInput, TaskTagUncheckedCreateWithoutTaskInput>
  }

  export type TaskTagUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskTagWhereUniqueInput
    data: XOR<TaskTagUpdateWithoutTaskInput, TaskTagUncheckedUpdateWithoutTaskInput>
  }

  export type TaskTagUpdateManyWithWhereWithoutTaskInput = {
    where: TaskTagScalarWhereInput
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskTagScalarWhereInput = {
    AND?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
    OR?: TaskTagScalarWhereInput[]
    NOT?: TaskTagScalarWhereInput | TaskTagScalarWhereInput[]
    id?: IntFilter<"TaskTag"> | number
    taskId?: IntFilter<"TaskTag"> | number
    tagId?: IntFilter<"TaskTag"> | number
    createdAt?: DateTimeFilter<"TaskTag"> | Date | string
  }

  export type TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCustomValueWhereUniqueInput
    update: XOR<TaskCustomValueUpdateWithoutTaskInput, TaskCustomValueUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput>
  }

  export type TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCustomValueWhereUniqueInput
    data: XOR<TaskCustomValueUpdateWithoutTaskInput, TaskCustomValueUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCustomValueUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCustomValueScalarWhereInput
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCustomValueScalarWhereInput = {
    AND?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
    OR?: TaskCustomValueScalarWhereInput[]
    NOT?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
    id?: IntFilter<"TaskCustomValue"> | number
    taskId?: IntFilter<"TaskCustomValue"> | number
    customFieldId?: IntFilter<"TaskCustomValue"> | number
    value?: StringFilter<"TaskCustomValue"> | string
    createdAt?: DateTimeFilter<"TaskCustomValue"> | Date | string
    updatedAt?: DateTimeFilter<"TaskCustomValue"> | Date | string
  }

  export type TaskLinkUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskLinkWhereUniqueInput
    update: XOR<TaskLinkUpdateWithoutTaskInput, TaskLinkUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskLinkCreateWithoutTaskInput, TaskLinkUncheckedCreateWithoutTaskInput>
  }

  export type TaskLinkUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskLinkWhereUniqueInput
    data: XOR<TaskLinkUpdateWithoutTaskInput, TaskLinkUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLinkUpdateManyWithWhereWithoutTaskInput = {
    where: TaskLinkScalarWhereInput
    data: XOR<TaskLinkUpdateManyMutationInput, TaskLinkUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLinkScalarWhereInput = {
    AND?: TaskLinkScalarWhereInput | TaskLinkScalarWhereInput[]
    OR?: TaskLinkScalarWhereInput[]
    NOT?: TaskLinkScalarWhereInput | TaskLinkScalarWhereInput[]
    id?: IntFilter<"TaskLink"> | number
    taskId?: IntFilter<"TaskLink"> | number
    oppositeTaskId?: IntFilter<"TaskLink"> | number
    linkType?: EnumTaskLinkTypeFilter<"TaskLink"> | $Enums.TaskLinkType
    createdAt?: DateTimeFilter<"TaskLink"> | Date | string
  }

  export type TaskLinkUpsertWithWhereUniqueWithoutOppositeTaskInput = {
    where: TaskLinkWhereUniqueInput
    update: XOR<TaskLinkUpdateWithoutOppositeTaskInput, TaskLinkUncheckedUpdateWithoutOppositeTaskInput>
    create: XOR<TaskLinkCreateWithoutOppositeTaskInput, TaskLinkUncheckedCreateWithoutOppositeTaskInput>
  }

  export type TaskLinkUpdateWithWhereUniqueWithoutOppositeTaskInput = {
    where: TaskLinkWhereUniqueInput
    data: XOR<TaskLinkUpdateWithoutOppositeTaskInput, TaskLinkUncheckedUpdateWithoutOppositeTaskInput>
  }

  export type TaskLinkUpdateManyWithWhereWithoutOppositeTaskInput = {
    where: TaskLinkScalarWhereInput
    data: XOR<TaskLinkUpdateManyMutationInput, TaskLinkUncheckedUpdateManyWithoutOppositeTaskInput>
  }

  export type TaskSessionUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskSessionWhereUniqueInput
    update: XOR<TaskSessionUpdateWithoutTaskInput, TaskSessionUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskSessionCreateWithoutTaskInput, TaskSessionUncheckedCreateWithoutTaskInput>
  }

  export type TaskSessionUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskSessionWhereUniqueInput
    data: XOR<TaskSessionUpdateWithoutTaskInput, TaskSessionUncheckedUpdateWithoutTaskInput>
  }

  export type TaskSessionUpdateManyWithWhereWithoutTaskInput = {
    where: TaskSessionScalarWhereInput
    data: XOR<TaskSessionUpdateManyMutationInput, TaskSessionUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskSessionScalarWhereInput = {
    AND?: TaskSessionScalarWhereInput | TaskSessionScalarWhereInput[]
    OR?: TaskSessionScalarWhereInput[]
    NOT?: TaskSessionScalarWhereInput | TaskSessionScalarWhereInput[]
    id?: IntFilter<"TaskSession"> | number
    taskId?: IntFilter<"TaskSession"> | number
    sessionId?: StringFilter<"TaskSession"> | string
    linkType?: EnumTaskSessionTypeFilter<"TaskSession"> | $Enums.TaskSessionType
    notes?: StringNullableFilter<"TaskSession"> | string | null
    createdAt?: DateTimeFilter<"TaskSession"> | Date | string
  }

  export type TaskCreateWithoutAssigneesInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneesInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
  }

  export type UserCreateWithoutTasksAssignedInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutTasksAssignedInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutTasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
  }

  export type TaskUpsertWithoutAssigneesInput = {
    update: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAssigneesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskUpdateWithoutAssigneesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTasksAssignedInput = {
    update: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateWithoutTasksAssignedInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksAssignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type TaskCreateWithoutSubtasksInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSubtasksInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSubtasksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
  }

  export type UserCreateWithoutSubtasksAssignedInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutSubtasksAssignedInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutSubtasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubtasksAssignedInput, UserUncheckedCreateWithoutSubtasksAssignedInput>
  }

  export type TaskUpsertWithoutSubtasksInput = {
    update: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type TaskUpdateWithoutSubtasksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSubtasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutSubtasksAssignedInput = {
    update: XOR<UserUpdateWithoutSubtasksAssignedInput, UserUncheckedUpdateWithoutSubtasksAssignedInput>
    create: XOR<UserCreateWithoutSubtasksAssignedInput, UserUncheckedCreateWithoutSubtasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubtasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubtasksAssignedInput, UserUncheckedUpdateWithoutSubtasksAssignedInput>
  }

  export type UserUpdateWithoutSubtasksAssignedInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSubtasksAssignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type TaskCreateWithoutCommentsInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProjectCreateWithoutTagsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTagsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
  }

  export type TaskTagCreateWithoutTagInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutTagsInput
  }

  export type TaskTagUncheckedCreateWithoutTagInput = {
    id?: number
    taskId: number
    createdAt?: Date | string
  }

  export type TaskTagCreateOrConnectWithoutTagInput = {
    where: TaskTagWhereUniqueInput
    create: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput>
  }

  export type TaskTagCreateManyTagInputEnvelope = {
    data: TaskTagCreateManyTagInput | TaskTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTagsInput = {
    update: XOR<ProjectUpdateWithoutTagsInput, ProjectUncheckedUpdateWithoutTagsInput>
    create: XOR<ProjectCreateWithoutTagsInput, ProjectUncheckedCreateWithoutTagsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTagsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTagsInput, ProjectUncheckedUpdateWithoutTagsInput>
  }

  export type ProjectUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TaskTagWhereUniqueInput
    update: XOR<TaskTagUpdateWithoutTagInput, TaskTagUncheckedUpdateWithoutTagInput>
    create: XOR<TaskTagCreateWithoutTagInput, TaskTagUncheckedCreateWithoutTagInput>
  }

  export type TaskTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TaskTagWhereUniqueInput
    data: XOR<TaskTagUpdateWithoutTagInput, TaskTagUncheckedUpdateWithoutTagInput>
  }

  export type TaskTagUpdateManyWithWhereWithoutTagInput = {
    where: TaskTagScalarWhereInput
    data: XOR<TaskTagUpdateManyMutationInput, TaskTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TaskCreateWithoutTagsInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTagsInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTagsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTagsInput, TaskUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutTasksInput = {
    name: string
    color?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    color?: string
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutTasksInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTasksInput, TagUncheckedCreateWithoutTasksInput>
  }

  export type TaskUpsertWithoutTagsInput = {
    update: XOR<TaskUpdateWithoutTagsInput, TaskUncheckedUpdateWithoutTagsInput>
    create: XOR<TaskCreateWithoutTagsInput, TaskUncheckedCreateWithoutTagsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTagsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTagsInput, TaskUncheckedUpdateWithoutTagsInput>
  }

  export type TaskUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TagUpsertWithoutTasksInput = {
    update: XOR<TagUpdateWithoutTasksInput, TagUncheckedUpdateWithoutTasksInput>
    create: XOR<TagCreateWithoutTasksInput, TagUncheckedCreateWithoutTasksInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTasksInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTasksInput, TagUncheckedUpdateWithoutTasksInput>
  }

  export type TagUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutCategoriesInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCategoriesInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCategoriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput>
  }

  export type TaskCreateWithoutCategoryInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCategoryInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCategoryInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCategoryInput, TaskUncheckedCreateWithoutCategoryInput>
  }

  export type TaskCreateManyCategoryInputEnvelope = {
    data: TaskCreateManyCategoryInput | TaskCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutCategoriesInput = {
    update: XOR<ProjectUpdateWithoutCategoriesInput, ProjectUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProjectCreateWithoutCategoriesInput, ProjectUncheckedCreateWithoutCategoriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCategoriesInput, ProjectUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProjectUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCategoryInput, TaskUncheckedUpdateWithoutCategoryInput>
    create: XOR<TaskCreateWithoutCategoryInput, TaskUncheckedCreateWithoutCategoryInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCategoryInput, TaskUncheckedUpdateWithoutCategoryInput>
  }

  export type TaskUpdateManyWithWhereWithoutCategoryInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TaskCreateWithoutAttachmentsInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAttachmentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutAttachmentsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
  }

  export type TaskUpsertWithoutAttachmentsInput = {
    update: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskUpdateWithoutAttachmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutAttachmentsInput = {
    update: XOR<UserUpdateWithoutAttachmentsInput, UserUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttachmentsInput, UserUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateWithoutAttachmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type TaskCreateWithoutLinksFromInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutLinksFromInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLinksFromInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLinksFromInput, TaskUncheckedCreateWithoutLinksFromInput>
  }

  export type TaskCreateWithoutLinksToInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutLinksToInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLinksToInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLinksToInput, TaskUncheckedCreateWithoutLinksToInput>
  }

  export type TaskUpsertWithoutLinksFromInput = {
    update: XOR<TaskUpdateWithoutLinksFromInput, TaskUncheckedUpdateWithoutLinksFromInput>
    create: XOR<TaskCreateWithoutLinksFromInput, TaskUncheckedCreateWithoutLinksFromInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutLinksFromInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutLinksFromInput, TaskUncheckedUpdateWithoutLinksFromInput>
  }

  export type TaskUpdateWithoutLinksFromInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutLinksFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUpsertWithoutLinksToInput = {
    update: XOR<TaskUpdateWithoutLinksToInput, TaskUncheckedUpdateWithoutLinksToInput>
    create: XOR<TaskCreateWithoutLinksToInput, TaskUncheckedCreateWithoutLinksToInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutLinksToInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutLinksToInput, TaskUncheckedUpdateWithoutLinksToInput>
  }

  export type TaskUpdateWithoutLinksToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutLinksToInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ProjectCreateWithoutCustomFieldsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCustomFieldsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCustomFieldsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCustomFieldsInput, ProjectUncheckedCreateWithoutCustomFieldsInput>
  }

  export type TaskCustomValueCreateWithoutCustomFieldInput = {
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutCustomValuesInput
  }

  export type TaskCustomValueUncheckedCreateWithoutCustomFieldInput = {
    id?: number
    taskId: number
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCustomValueCreateOrConnectWithoutCustomFieldInput = {
    where: TaskCustomValueWhereUniqueInput
    create: XOR<TaskCustomValueCreateWithoutCustomFieldInput, TaskCustomValueUncheckedCreateWithoutCustomFieldInput>
  }

  export type TaskCustomValueCreateManyCustomFieldInputEnvelope = {
    data: TaskCustomValueCreateManyCustomFieldInput | TaskCustomValueCreateManyCustomFieldInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutCustomFieldsInput = {
    update: XOR<ProjectUpdateWithoutCustomFieldsInput, ProjectUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<ProjectCreateWithoutCustomFieldsInput, ProjectUncheckedCreateWithoutCustomFieldsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCustomFieldsInput, ProjectUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type ProjectUpdateWithoutCustomFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCustomFieldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskCustomValueUpsertWithWhereUniqueWithoutCustomFieldInput = {
    where: TaskCustomValueWhereUniqueInput
    update: XOR<TaskCustomValueUpdateWithoutCustomFieldInput, TaskCustomValueUncheckedUpdateWithoutCustomFieldInput>
    create: XOR<TaskCustomValueCreateWithoutCustomFieldInput, TaskCustomValueUncheckedCreateWithoutCustomFieldInput>
  }

  export type TaskCustomValueUpdateWithWhereUniqueWithoutCustomFieldInput = {
    where: TaskCustomValueWhereUniqueInput
    data: XOR<TaskCustomValueUpdateWithoutCustomFieldInput, TaskCustomValueUncheckedUpdateWithoutCustomFieldInput>
  }

  export type TaskCustomValueUpdateManyWithWhereWithoutCustomFieldInput = {
    where: TaskCustomValueScalarWhereInput
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyWithoutCustomFieldInput>
  }

  export type TaskCreateWithoutCustomValuesInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCustomValuesInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCustomValuesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
  }

  export type CustomFieldCreateWithoutValuesInput = {
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutCustomFieldsInput
  }

  export type CustomFieldUncheckedCreateWithoutValuesInput = {
    id?: number
    projectId: number
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
  }

  export type CustomFieldCreateOrConnectWithoutValuesInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
  }

  export type TaskUpsertWithoutCustomValuesInput = {
    update: XOR<TaskUpdateWithoutCustomValuesInput, TaskUncheckedUpdateWithoutCustomValuesInput>
    create: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCustomValuesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCustomValuesInput, TaskUncheckedUpdateWithoutCustomValuesInput>
  }

  export type TaskUpdateWithoutCustomValuesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCustomValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type CustomFieldUpsertWithoutValuesInput = {
    update: XOR<CustomFieldUpdateWithoutValuesInput, CustomFieldUncheckedUpdateWithoutValuesInput>
    create: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    where?: CustomFieldWhereInput
  }

  export type CustomFieldUpdateToOneWithWhereWithoutValuesInput = {
    where?: CustomFieldWhereInput
    data: XOR<CustomFieldUpdateWithoutValuesInput, CustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type CustomFieldUpdateWithoutValuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type CustomFieldUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutSprintsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSprintsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSprintsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
  }

  export type TaskCreateWithoutSprintInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSprintInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSprintInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput>
  }

  export type TaskCreateManySprintInputEnvelope = {
    data: TaskCreateManySprintInput | TaskCreateManySprintInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSprintsInput = {
    update: XOR<ProjectUpdateWithoutSprintsInput, ProjectUncheckedUpdateWithoutSprintsInput>
    create: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSprintsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSprintsInput, ProjectUncheckedUpdateWithoutSprintsInput>
  }

  export type ProjectUpdateWithoutSprintsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSprintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutSprintInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutSprintInput, TaskUncheckedUpdateWithoutSprintInput>
    create: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutSprintInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutSprintInput, TaskUncheckedUpdateWithoutSprintInput>
  }

  export type TaskUpdateManyWithWhereWithoutSprintInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutSprintInput>
  }

  export type ProjectCreateWithoutModulesInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutModulesInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutModulesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutModulesInput, ProjectUncheckedCreateWithoutModulesInput>
  }

  export type TaskCreateWithoutModuleInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutModuleInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutModuleInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutModuleInput, TaskUncheckedCreateWithoutModuleInput>
  }

  export type TaskCreateManyModuleInputEnvelope = {
    data: TaskCreateManyModuleInput | TaskCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutModulesInput = {
    update: XOR<ProjectUpdateWithoutModulesInput, ProjectUncheckedUpdateWithoutModulesInput>
    create: XOR<ProjectCreateWithoutModulesInput, ProjectUncheckedCreateWithoutModulesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutModulesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutModulesInput, ProjectUncheckedUpdateWithoutModulesInput>
  }

  export type ProjectUpdateWithoutModulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutModuleInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutModuleInput, TaskUncheckedUpdateWithoutModuleInput>
    create: XOR<TaskCreateWithoutModuleInput, TaskUncheckedCreateWithoutModuleInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutModuleInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutModuleInput, TaskUncheckedUpdateWithoutModuleInput>
  }

  export type TaskUpdateManyWithWhereWithoutModuleInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutModuleInput>
  }

  export type ProjectCreateWithoutMilestonesInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMilestonesInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMilestonesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
  }

  export type TaskCreateWithoutMilestoneInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutMilestoneInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
    genxSessions?: TaskSessionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutMilestoneInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutMilestoneInput, TaskUncheckedCreateWithoutMilestoneInput>
  }

  export type TaskCreateManyMilestoneInputEnvelope = {
    data: TaskCreateManyMilestoneInput | TaskCreateManyMilestoneInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutMilestonesInput = {
    update: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ProjectUpdateWithoutMilestonesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMilestonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutMilestoneInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutMilestoneInput, TaskUncheckedUpdateWithoutMilestoneInput>
    create: XOR<TaskCreateWithoutMilestoneInput, TaskUncheckedCreateWithoutMilestoneInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutMilestoneInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutMilestoneInput, TaskUncheckedUpdateWithoutMilestoneInput>
  }

  export type TaskUpdateManyWithWhereWithoutMilestoneInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutMilestoneInput>
  }

  export type StickyNoteLinkCreateWithoutStickyNoteInput = {
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt?: Date | string
  }

  export type StickyNoteLinkUncheckedCreateWithoutStickyNoteInput = {
    id?: number
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt?: Date | string
  }

  export type StickyNoteLinkCreateOrConnectWithoutStickyNoteInput = {
    where: StickyNoteLinkWhereUniqueInput
    create: XOR<StickyNoteLinkCreateWithoutStickyNoteInput, StickyNoteLinkUncheckedCreateWithoutStickyNoteInput>
  }

  export type StickyNoteLinkCreateManyStickyNoteInputEnvelope = {
    data: StickyNoteLinkCreateManyStickyNoteInput | StickyNoteLinkCreateManyStickyNoteInput[]
    skipDuplicates?: boolean
  }

  export type StickyNoteLinkUpsertWithWhereUniqueWithoutStickyNoteInput = {
    where: StickyNoteLinkWhereUniqueInput
    update: XOR<StickyNoteLinkUpdateWithoutStickyNoteInput, StickyNoteLinkUncheckedUpdateWithoutStickyNoteInput>
    create: XOR<StickyNoteLinkCreateWithoutStickyNoteInput, StickyNoteLinkUncheckedCreateWithoutStickyNoteInput>
  }

  export type StickyNoteLinkUpdateWithWhereUniqueWithoutStickyNoteInput = {
    where: StickyNoteLinkWhereUniqueInput
    data: XOR<StickyNoteLinkUpdateWithoutStickyNoteInput, StickyNoteLinkUncheckedUpdateWithoutStickyNoteInput>
  }

  export type StickyNoteLinkUpdateManyWithWhereWithoutStickyNoteInput = {
    where: StickyNoteLinkScalarWhereInput
    data: XOR<StickyNoteLinkUpdateManyMutationInput, StickyNoteLinkUncheckedUpdateManyWithoutStickyNoteInput>
  }

  export type StickyNoteLinkScalarWhereInput = {
    AND?: StickyNoteLinkScalarWhereInput | StickyNoteLinkScalarWhereInput[]
    OR?: StickyNoteLinkScalarWhereInput[]
    NOT?: StickyNoteLinkScalarWhereInput | StickyNoteLinkScalarWhereInput[]
    id?: IntFilter<"StickyNoteLink"> | number
    stickyNoteId?: IntFilter<"StickyNoteLink"> | number
    entityType?: EnumStickyLinkTypeFilter<"StickyNoteLink"> | $Enums.StickyLinkType
    entityId?: IntFilter<"StickyNoteLink"> | number
    createdAt?: DateTimeFilter<"StickyNoteLink"> | Date | string
  }

  export type StickyNoteCreateWithoutLinksInput = {
    userId: number
    title?: string | null
    content: string
    color?: $Enums.StickyNoteColor
    isPinned?: boolean
    visibility?: $Enums.StickyVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StickyNoteUncheckedCreateWithoutLinksInput = {
    id?: number
    userId: number
    title?: string | null
    content: string
    color?: $Enums.StickyNoteColor
    isPinned?: boolean
    visibility?: $Enums.StickyVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StickyNoteCreateOrConnectWithoutLinksInput = {
    where: StickyNoteWhereUniqueInput
    create: XOR<StickyNoteCreateWithoutLinksInput, StickyNoteUncheckedCreateWithoutLinksInput>
  }

  export type StickyNoteUpsertWithoutLinksInput = {
    update: XOR<StickyNoteUpdateWithoutLinksInput, StickyNoteUncheckedUpdateWithoutLinksInput>
    create: XOR<StickyNoteCreateWithoutLinksInput, StickyNoteUncheckedCreateWithoutLinksInput>
    where?: StickyNoteWhereInput
  }

  export type StickyNoteUpdateToOneWithWhereWithoutLinksInput = {
    where?: StickyNoteWhereInput
    data: XOR<StickyNoteUpdateWithoutLinksInput, StickyNoteUncheckedUpdateWithoutLinksInput>
  }

  export type StickyNoteUpdateWithoutLinksInput = {
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    color?: EnumStickyNoteColorFieldUpdateOperationsInput | $Enums.StickyNoteColor
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumStickyVisibilityFieldUpdateOperationsInput | $Enums.StickyVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteUncheckedUpdateWithoutLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    color?: EnumStickyNoteColorFieldUpdateOperationsInput | $Enums.StickyNoteColor
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumStickyVisibilityFieldUpdateOperationsInput | $Enums.StickyVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateWithoutProjectGroupsInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutProjectGroupsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutProjectGroupsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutProjectGroupsInput, WorkspaceUncheckedCreateWithoutProjectGroupsInput>
  }

  export type ProjectGroupMemberCreateWithoutProjectGroupInput = {
    position?: number
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectGroupsInput
  }

  export type ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput = {
    id?: number
    projectId: number
    position?: number
    createdAt?: Date | string
  }

  export type ProjectGroupMemberCreateOrConnectWithoutProjectGroupInput = {
    where: ProjectGroupMemberWhereUniqueInput
    create: XOR<ProjectGroupMemberCreateWithoutProjectGroupInput, ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput>
  }

  export type ProjectGroupMemberCreateManyProjectGroupInputEnvelope = {
    data: ProjectGroupMemberCreateManyProjectGroupInput | ProjectGroupMemberCreateManyProjectGroupInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutProjectGroupsInput = {
    update: XOR<WorkspaceUpdateWithoutProjectGroupsInput, WorkspaceUncheckedUpdateWithoutProjectGroupsInput>
    create: XOR<WorkspaceCreateWithoutProjectGroupsInput, WorkspaceUncheckedCreateWithoutProjectGroupsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutProjectGroupsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutProjectGroupsInput, WorkspaceUncheckedUpdateWithoutProjectGroupsInput>
  }

  export type WorkspaceUpdateWithoutProjectGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutProjectGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProjectGroupMemberUpsertWithWhereUniqueWithoutProjectGroupInput = {
    where: ProjectGroupMemberWhereUniqueInput
    update: XOR<ProjectGroupMemberUpdateWithoutProjectGroupInput, ProjectGroupMemberUncheckedUpdateWithoutProjectGroupInput>
    create: XOR<ProjectGroupMemberCreateWithoutProjectGroupInput, ProjectGroupMemberUncheckedCreateWithoutProjectGroupInput>
  }

  export type ProjectGroupMemberUpdateWithWhereUniqueWithoutProjectGroupInput = {
    where: ProjectGroupMemberWhereUniqueInput
    data: XOR<ProjectGroupMemberUpdateWithoutProjectGroupInput, ProjectGroupMemberUncheckedUpdateWithoutProjectGroupInput>
  }

  export type ProjectGroupMemberUpdateManyWithWhereWithoutProjectGroupInput = {
    where: ProjectGroupMemberScalarWhereInput
    data: XOR<ProjectGroupMemberUpdateManyMutationInput, ProjectGroupMemberUncheckedUpdateManyWithoutProjectGroupInput>
  }

  export type ProjectGroupCreateWithoutProjectsInput = {
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectGroupsInput
  }

  export type ProjectGroupUncheckedCreateWithoutProjectsInput = {
    id?: number
    workspaceId: number
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectGroupCreateOrConnectWithoutProjectsInput = {
    where: ProjectGroupWhereUniqueInput
    create: XOR<ProjectGroupCreateWithoutProjectsInput, ProjectGroupUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectCreateWithoutProjectGroupsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectGroupsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectGroupsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectGroupsInput, ProjectUncheckedCreateWithoutProjectGroupsInput>
  }

  export type ProjectGroupUpsertWithoutProjectsInput = {
    update: XOR<ProjectGroupUpdateWithoutProjectsInput, ProjectGroupUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectGroupCreateWithoutProjectsInput, ProjectGroupUncheckedCreateWithoutProjectsInput>
    where?: ProjectGroupWhereInput
  }

  export type ProjectGroupUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProjectGroupWhereInput
    data: XOR<ProjectGroupUpdateWithoutProjectsInput, ProjectGroupUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectGroupUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectGroupsNestedInput
  }

  export type ProjectGroupUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithoutProjectGroupsInput = {
    update: XOR<ProjectUpdateWithoutProjectGroupsInput, ProjectUncheckedUpdateWithoutProjectGroupsInput>
    create: XOR<ProjectCreateWithoutProjectGroupsInput, ProjectUncheckedCreateWithoutProjectGroupsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectGroupsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectGroupsInput, ProjectUncheckedUpdateWithoutProjectGroupsInput>
  }

  export type ProjectUpdateWithoutProjectGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskCreateWithoutGenxSessionsInput = {
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    column: ColumnCreateNestedOneWithoutTasksInput
    swimlane?: SwimlaneCreateNestedOneWithoutTasksInput
    creator: UserCreateNestedOneWithoutTasksCreatedInput
    milestone?: MilestoneCreateNestedOneWithoutTasksInput
    module?: ModuleCreateNestedOneWithoutTasksInput
    sprint?: SprintCreateNestedOneWithoutTasksInput
    category?: CategoryCreateNestedOneWithoutTasksInput
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    tags?: TaskTagCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkCreateNestedManyWithoutOppositeTaskInput
  }

  export type TaskUncheckedCreateWithoutGenxSessionsInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    tags?: TaskTagUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    linksFrom?: TaskLinkUncheckedCreateNestedManyWithoutTaskInput
    linksTo?: TaskLinkUncheckedCreateNestedManyWithoutOppositeTaskInput
  }

  export type TaskCreateOrConnectWithoutGenxSessionsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutGenxSessionsInput, TaskUncheckedCreateWithoutGenxSessionsInput>
  }

  export type TaskUpsertWithoutGenxSessionsInput = {
    update: XOR<TaskUpdateWithoutGenxSessionsInput, TaskUncheckedUpdateWithoutGenxSessionsInput>
    create: XOR<TaskCreateWithoutGenxSessionsInput, TaskUncheckedCreateWithoutGenxSessionsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutGenxSessionsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutGenxSessionsInput, TaskUncheckedUpdateWithoutGenxSessionsInput>
  }

  export type TaskUpdateWithoutGenxSessionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutGenxSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
  }

  export type ProjectCreateWithoutBudgetsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBudgetsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBudgetsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBudgetsInput, ProjectUncheckedCreateWithoutBudgetsInput>
  }

  export type BudgetLineCreateWithoutBudgetInput = {
    description: string
    amount: Decimal | DecimalJsLike | number | string
    lineType?: $Enums.BudgetLineType
    taskId?: number | null
    createdAt?: Date | string
  }

  export type BudgetLineUncheckedCreateWithoutBudgetInput = {
    id?: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    lineType?: $Enums.BudgetLineType
    taskId?: number | null
    createdAt?: Date | string
  }

  export type BudgetLineCreateOrConnectWithoutBudgetInput = {
    where: BudgetLineWhereUniqueInput
    create: XOR<BudgetLineCreateWithoutBudgetInput, BudgetLineUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetLineCreateManyBudgetInputEnvelope = {
    data: BudgetLineCreateManyBudgetInput | BudgetLineCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutBudgetsInput = {
    update: XOR<ProjectUpdateWithoutBudgetsInput, ProjectUncheckedUpdateWithoutBudgetsInput>
    create: XOR<ProjectCreateWithoutBudgetsInput, ProjectUncheckedCreateWithoutBudgetsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBudgetsInput, ProjectUncheckedUpdateWithoutBudgetsInput>
  }

  export type ProjectUpdateWithoutBudgetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBudgetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BudgetLineUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetLineWhereUniqueInput
    update: XOR<BudgetLineUpdateWithoutBudgetInput, BudgetLineUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetLineCreateWithoutBudgetInput, BudgetLineUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetLineUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetLineWhereUniqueInput
    data: XOR<BudgetLineUpdateWithoutBudgetInput, BudgetLineUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetLineUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetLineScalarWhereInput
    data: XOR<BudgetLineUpdateManyMutationInput, BudgetLineUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetLineScalarWhereInput = {
    AND?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
    OR?: BudgetLineScalarWhereInput[]
    NOT?: BudgetLineScalarWhereInput | BudgetLineScalarWhereInput[]
    id?: IntFilter<"BudgetLine"> | number
    budgetId?: IntFilter<"BudgetLine"> | number
    description?: StringFilter<"BudgetLine"> | string
    amount?: DecimalFilter<"BudgetLine"> | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFilter<"BudgetLine"> | $Enums.BudgetLineType
    taskId?: IntNullableFilter<"BudgetLine"> | number | null
    createdAt?: DateTimeFilter<"BudgetLine"> | Date | string
  }

  export type BudgetCreateWithoutLinesInput = {
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutLinesInput = {
    id?: number
    projectId: number
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutLinesInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutLinesInput, BudgetUncheckedCreateWithoutLinesInput>
  }

  export type BudgetUpsertWithoutLinesInput = {
    update: XOR<BudgetUpdateWithoutLinesInput, BudgetUncheckedUpdateWithoutLinesInput>
    create: XOR<BudgetCreateWithoutLinesInput, BudgetUncheckedCreateWithoutLinesInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutLinesInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutLinesInput, BudgetUncheckedUpdateWithoutLinesInput>
  }

  export type BudgetUpdateWithoutLinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutWikiPagesInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWikiPagesInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWikiPagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWikiPagesInput, ProjectUncheckedCreateWithoutWikiPagesInput>
  }

  export type ProjectUpsertWithoutWikiPagesInput = {
    update: XOR<ProjectUpdateWithoutWikiPagesInput, ProjectUncheckedUpdateWithoutWikiPagesInput>
    create: XOR<ProjectCreateWithoutWikiPagesInput, ProjectUncheckedCreateWithoutWikiPagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWikiPagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWikiPagesInput, ProjectUncheckedUpdateWithoutWikiPagesInput>
  }

  export type ProjectUpdateWithoutWikiPagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWikiPagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProjectCreateWithoutWebhooksInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWebhooksInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWebhooksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWebhooksInput, ProjectUncheckedCreateWithoutWebhooksInput>
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    event: string
    payload: JsonNullValueInput | InputJsonValue
    statusCode?: number | null
    response?: string | null
    duration?: number | null
    success?: boolean
    attempts?: number
    deliveredAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    statusCode?: number | null
    response?: string | null
    duration?: number | null
    success?: boolean
    attempts?: number
    deliveredAt?: Date | string
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutWebhooksInput = {
    update: XOR<ProjectUpdateWithoutWebhooksInput, ProjectUncheckedUpdateWithoutWebhooksInput>
    create: XOR<ProjectCreateWithoutWebhooksInput, ProjectUncheckedCreateWithoutWebhooksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWebhooksInput, ProjectUncheckedUpdateWithoutWebhooksInput>
  }

  export type ProjectUpdateWithoutWebhooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWebhooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: IntFilter<"WebhookDelivery"> | number
    webhookId?: IntFilter<"WebhookDelivery"> | number
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    duration?: IntNullableFilter<"WebhookDelivery"> | number | null
    success?: BoolFilter<"WebhookDelivery"> | boolean
    attempts?: IntFilter<"WebhookDelivery"> | number
    deliveredAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookCreateWithoutDeliveriesInput = {
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    projectId: number
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookUpdateWithoutDeliveriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProjectCreateWithoutActivitiesInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutActivitiesInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutActivitiesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type ProjectUpsertWithoutActivitiesInput = {
    update: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>
  }

  export type ProjectUpdateWithoutActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutPasswordResetsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutLastLoginsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutLastLoginsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutLastLoginsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLastLoginsInput, UserUncheckedCreateWithoutLastLoginsInput>
  }

  export type UserUpsertWithoutLastLoginsInput = {
    update: XOR<UserUpdateWithoutLastLoginsInput, UserUncheckedUpdateWithoutLastLoginsInput>
    create: XOR<UserCreateWithoutLastLoginsInput, UserUncheckedCreateWithoutLastLoginsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLastLoginsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLastLoginsInput, UserUncheckedUpdateWithoutLastLoginsInput>
  }

  export type UserUpdateWithoutLastLoginsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLastLoginsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutMetadataInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutMetadataInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutMetadataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMetadataInput, UserUncheckedCreateWithoutMetadataInput>
  }

  export type UserUpsertWithoutMetadataInput = {
    update: XOR<UserUpdateWithoutMetadataInput, UserUncheckedUpdateWithoutMetadataInput>
    create: XOR<UserCreateWithoutMetadataInput, UserUncheckedCreateWithoutMetadataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMetadataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMetadataInput, UserUncheckedUpdateWithoutMetadataInput>
  }

  export type UserUpdateWithoutMetadataInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMetadataInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutAvatarInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutAvatarInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutAvatarInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
  }

  export type UserUpsertWithoutAvatarInput = {
    update: XOR<UserUpdateWithoutAvatarInput, UserUncheckedUpdateWithoutAvatarInput>
    create: XOR<UserCreateWithoutAvatarInput, UserUncheckedCreateWithoutAvatarInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvatarInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvatarInput, UserUncheckedUpdateWithoutAvatarInput>
  }

  export type UserUpdateWithoutAvatarInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAvatarInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type GroupCreateWithoutChildGroupsInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutChildGroupsInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutChildGroupsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutChildGroupsInput, GroupUncheckedCreateWithoutChildGroupsInput>
  }

  export type GroupCreateWithoutParentGroupInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutParentGroupInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutParentGroupInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutParentGroupInput, GroupUncheckedCreateWithoutParentGroupInput>
  }

  export type GroupCreateManyParentGroupInputEnvelope = {
    data: GroupCreateManyParentGroupInput | GroupCreateManyParentGroupInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutGroupsInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutGroupsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutGroupsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutGroupsInput, WorkspaceUncheckedCreateWithoutGroupsInput>
  }

  export type ProjectCreateWithoutGroupsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutGroupsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutGroupsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutGroupsInput, ProjectUncheckedCreateWithoutGroupsInput>
  }

  export type GroupMemberCreateWithoutGroupInput = {
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    externalSync?: boolean
    user: UserCreateNestedOneWithoutGroupMembershipsInput
    addedBy?: UserCreateNestedOneWithoutGroupMembersAddedInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: number
    userId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    addedById?: number | null
    externalSync?: boolean
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupPermissionCreateWithoutGroupInput = {
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
    permission: PermissionCreateNestedOneWithoutGroupPermissionsInput
  }

  export type GroupPermissionUncheckedCreateWithoutGroupInput = {
    id?: number
    permissionId: number
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type GroupPermissionCreateOrConnectWithoutGroupInput = {
    where: GroupPermissionWhereUniqueInput
    create: XOR<GroupPermissionCreateWithoutGroupInput, GroupPermissionUncheckedCreateWithoutGroupInput>
  }

  export type GroupPermissionCreateManyGroupInputEnvelope = {
    data: GroupPermissionCreateManyGroupInput | GroupPermissionCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type RoleAssignmentCreateWithoutGroupInput = {
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
    workspace?: WorkspaceCreateNestedOneWithoutRoleAssignmentsInput
    project?: ProjectCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type RoleAssignmentUncheckedCreateWithoutGroupInput = {
    id?: number
    workspaceId?: number | null
    projectId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type RoleAssignmentCreateOrConnectWithoutGroupInput = {
    where: RoleAssignmentWhereUniqueInput
    create: XOR<RoleAssignmentCreateWithoutGroupInput, RoleAssignmentUncheckedCreateWithoutGroupInput>
  }

  export type RoleAssignmentCreateManyGroupInputEnvelope = {
    data: RoleAssignmentCreateManyGroupInput | RoleAssignmentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupUpsertWithoutChildGroupsInput = {
    update: XOR<GroupUpdateWithoutChildGroupsInput, GroupUncheckedUpdateWithoutChildGroupsInput>
    create: XOR<GroupCreateWithoutChildGroupsInput, GroupUncheckedCreateWithoutChildGroupsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutChildGroupsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutChildGroupsInput, GroupUncheckedUpdateWithoutChildGroupsInput>
  }

  export type GroupUpdateWithoutChildGroupsInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutChildGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUpsertWithWhereUniqueWithoutParentGroupInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutParentGroupInput, GroupUncheckedUpdateWithoutParentGroupInput>
    create: XOR<GroupCreateWithoutParentGroupInput, GroupUncheckedCreateWithoutParentGroupInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutParentGroupInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutParentGroupInput, GroupUncheckedUpdateWithoutParentGroupInput>
  }

  export type GroupUpdateManyWithWhereWithoutParentGroupInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutParentGroupInput>
  }

  export type WorkspaceUpsertWithoutGroupsInput = {
    update: XOR<WorkspaceUpdateWithoutGroupsInput, WorkspaceUncheckedUpdateWithoutGroupsInput>
    create: XOR<WorkspaceCreateWithoutGroupsInput, WorkspaceUncheckedCreateWithoutGroupsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutGroupsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutGroupsInput, WorkspaceUncheckedUpdateWithoutGroupsInput>
  }

  export type WorkspaceUpdateWithoutGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProjectUpsertWithoutGroupsInput = {
    update: XOR<ProjectUpdateWithoutGroupsInput, ProjectUncheckedUpdateWithoutGroupsInput>
    create: XOR<ProjectCreateWithoutGroupsInput, ProjectUncheckedCreateWithoutGroupsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutGroupsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutGroupsInput, ProjectUncheckedUpdateWithoutGroupsInput>
  }

  export type ProjectUpdateWithoutGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupPermissionUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupPermissionWhereUniqueInput
    update: XOR<GroupPermissionUpdateWithoutGroupInput, GroupPermissionUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupPermissionCreateWithoutGroupInput, GroupPermissionUncheckedCreateWithoutGroupInput>
  }

  export type GroupPermissionUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupPermissionWhereUniqueInput
    data: XOR<GroupPermissionUpdateWithoutGroupInput, GroupPermissionUncheckedUpdateWithoutGroupInput>
  }

  export type GroupPermissionUpdateManyWithWhereWithoutGroupInput = {
    where: GroupPermissionScalarWhereInput
    data: XOR<GroupPermissionUpdateManyMutationInput, GroupPermissionUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupPermissionScalarWhereInput = {
    AND?: GroupPermissionScalarWhereInput | GroupPermissionScalarWhereInput[]
    OR?: GroupPermissionScalarWhereInput[]
    NOT?: GroupPermissionScalarWhereInput | GroupPermissionScalarWhereInput[]
    id?: IntFilter<"GroupPermission"> | number
    groupId?: IntFilter<"GroupPermission"> | number
    permissionId?: IntFilter<"GroupPermission"> | number
    accessType?: EnumAccessTypeFilter<"GroupPermission"> | $Enums.AccessType
    workspaceId?: IntNullableFilter<"GroupPermission"> | number | null
    projectId?: IntNullableFilter<"GroupPermission"> | number | null
    inherited?: BoolFilter<"GroupPermission"> | boolean
    createdAt?: DateTimeFilter<"GroupPermission"> | Date | string
    createdById?: IntNullableFilter<"GroupPermission"> | number | null
  }

  export type RoleAssignmentUpsertWithWhereUniqueWithoutGroupInput = {
    where: RoleAssignmentWhereUniqueInput
    update: XOR<RoleAssignmentUpdateWithoutGroupInput, RoleAssignmentUncheckedUpdateWithoutGroupInput>
    create: XOR<RoleAssignmentCreateWithoutGroupInput, RoleAssignmentUncheckedCreateWithoutGroupInput>
  }

  export type RoleAssignmentUpdateWithWhereUniqueWithoutGroupInput = {
    where: RoleAssignmentWhereUniqueInput
    data: XOR<RoleAssignmentUpdateWithoutGroupInput, RoleAssignmentUncheckedUpdateWithoutGroupInput>
  }

  export type RoleAssignmentUpdateManyWithWhereWithoutGroupInput = {
    where: RoleAssignmentScalarWhereInput
    data: XOR<RoleAssignmentUpdateManyMutationInput, RoleAssignmentUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupCreateWithoutMembersInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMembersAdded?: GroupMemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMembersAdded?: GroupMemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type UserCreateWithoutGroupMembersAddedInput = {
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginCreateNestedManyWithoutUserInput
    metadata?: UserMetadataCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingCreateNestedManyWithoutUserInput
    avatar?: UserAvatarCreateNestedOneWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMembersAddedInput = {
    id?: number
    email: string
    username: string
    name: string
    passwordHash?: string | null
    avatarUrl?: string | null
    timezone?: string
    language?: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    emailVerified?: boolean
    role?: $Enums.AppRole
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twofactorActivated?: boolean
    twofactorSecret?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    lockoutCount?: number
    googleId?: string | null
    githubId?: string | null
    gitlabId?: number | null
    theme?: string
    defaultFilter?: string | null
    publicToken?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: boolean
    notificationFilter?: number
    workspaces?: WorkspaceUserUncheckedCreateNestedManyWithoutUserInput
    workspacesCreated?: WorkspaceUncheckedCreateNestedManyWithoutCreatedByInput
    invitationsCreated?: WorkspaceInvitationUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    tasksAssigned?: TaskAssigneeUncheckedCreateNestedManyWithoutUserInput
    subtasksAssigned?: SubtaskUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rememberTokens?: RememberTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    lastLogins?: LastLoginUncheckedCreateNestedManyWithoutUserInput
    metadata?: UserMetadataUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: UserNotificationSettingUncheckedCreateNestedManyWithoutUserInput
    avatar?: UserAvatarUncheckedCreateNestedOneWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutInvitedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMembersAddedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembersAddedInput, UserUncheckedCreateWithoutGroupMembersAddedInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMembersAdded?: GroupMemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMembersAdded?: GroupMemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserUpsertWithoutGroupMembersAddedInput = {
    update: XOR<UserUpdateWithoutGroupMembersAddedInput, UserUncheckedUpdateWithoutGroupMembersAddedInput>
    create: XOR<UserCreateWithoutGroupMembersAddedInput, UserUncheckedCreateWithoutGroupMembersAddedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembersAddedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembersAddedInput, UserUncheckedUpdateWithoutGroupMembersAddedInput>
  }

  export type UserUpdateWithoutGroupMembersAddedInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembersAddedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twofactorActivated?: BoolFieldUpdateOperationsInput | boolean
    twofactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockoutCount?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    gitlabId?: NullableIntFieldUpdateOperationsInput | number | null
    theme?: StringFieldUpdateOperationsInput | string
    defaultFilter?: NullableStringFieldUpdateOperationsInput | string | null
    publicToken?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationFilter?: IntFieldUpdateOperationsInput | number
    workspaces?: WorkspaceUserUncheckedUpdateManyWithoutUserNestedInput
    workspacesCreated?: WorkspaceUncheckedUpdateManyWithoutCreatedByNestedInput
    invitationsCreated?: WorkspaceInvitationUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    tasksAssigned?: TaskAssigneeUncheckedUpdateManyWithoutUserNestedInput
    subtasksAssigned?: SubtaskUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rememberTokens?: RememberTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    lastLogins?: LastLoginUncheckedUpdateManyWithoutUserNestedInput
    metadata?: UserMetadataUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: UserNotificationSettingUncheckedUpdateManyWithoutUserNestedInput
    avatar?: UserAvatarUncheckedUpdateOneWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutInvitedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PermissionCreateWithoutChildrenInput = {
    name: string
    displayName: string
    description?: string | null
    category: string
    sortOrder?: number
    createdAt?: Date | string
    parent?: PermissionCreateNestedOneWithoutChildrenInput
    groupPermissions?: GroupPermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    displayName: string
    description?: string | null
    category: string
    parentId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    groupPermissions?: GroupPermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionCreateOrConnectWithoutChildrenInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutChildrenInput, PermissionUncheckedCreateWithoutChildrenInput>
  }

  export type PermissionCreateWithoutParentInput = {
    name: string
    displayName: string
    description?: string | null
    category: string
    sortOrder?: number
    createdAt?: Date | string
    children?: PermissionCreateNestedManyWithoutParentInput
    groupPermissions?: GroupPermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    displayName: string
    description?: string | null
    category: string
    sortOrder?: number
    createdAt?: Date | string
    children?: PermissionUncheckedCreateNestedManyWithoutParentInput
    groupPermissions?: GroupPermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionCreateOrConnectWithoutParentInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutParentInput, PermissionUncheckedCreateWithoutParentInput>
  }

  export type PermissionCreateManyParentInputEnvelope = {
    data: PermissionCreateManyParentInput | PermissionCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type GroupPermissionCreateWithoutPermissionInput = {
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
    group: GroupCreateNestedOneWithoutPermissionsInput
  }

  export type GroupPermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    groupId: number
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type GroupPermissionCreateOrConnectWithoutPermissionInput = {
    where: GroupPermissionWhereUniqueInput
    create: XOR<GroupPermissionCreateWithoutPermissionInput, GroupPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type GroupPermissionCreateManyPermissionInputEnvelope = {
    data: GroupPermissionCreateManyPermissionInput | GroupPermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type PermissionUpsertWithoutChildrenInput = {
    update: XOR<PermissionUpdateWithoutChildrenInput, PermissionUncheckedUpdateWithoutChildrenInput>
    create: XOR<PermissionCreateWithoutChildrenInput, PermissionUncheckedCreateWithoutChildrenInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutChildrenInput, PermissionUncheckedUpdateWithoutChildrenInput>
  }

  export type PermissionUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PermissionUpdateOneWithoutChildrenNestedInput
    groupPermissions?: GroupPermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupPermissions?: GroupPermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUpsertWithWhereUniqueWithoutParentInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutParentInput, PermissionUncheckedUpdateWithoutParentInput>
    create: XOR<PermissionCreateWithoutParentInput, PermissionUncheckedCreateWithoutParentInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutParentInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutParentInput, PermissionUncheckedUpdateWithoutParentInput>
  }

  export type PermissionUpdateManyWithWhereWithoutParentInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutParentInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    displayName?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    category?: StringFilter<"Permission"> | string
    parentId?: IntNullableFilter<"Permission"> | number | null
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type GroupPermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: GroupPermissionWhereUniqueInput
    update: XOR<GroupPermissionUpdateWithoutPermissionInput, GroupPermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<GroupPermissionCreateWithoutPermissionInput, GroupPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type GroupPermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: GroupPermissionWhereUniqueInput
    data: XOR<GroupPermissionUpdateWithoutPermissionInput, GroupPermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type GroupPermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: GroupPermissionScalarWhereInput
    data: XOR<GroupPermissionUpdateManyMutationInput, GroupPermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type GroupCreateWithoutPermissionsInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutPermissionsInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    roleAssignments?: RoleAssignmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutPermissionsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutGroupPermissionsInput = {
    name: string
    displayName: string
    description?: string | null
    category: string
    sortOrder?: number
    createdAt?: Date | string
    parent?: PermissionCreateNestedOneWithoutChildrenInput
    children?: PermissionCreateNestedManyWithoutParentInput
  }

  export type PermissionUncheckedCreateWithoutGroupPermissionsInput = {
    id?: number
    name: string
    displayName: string
    description?: string | null
    category: string
    parentId?: number | null
    sortOrder?: number
    createdAt?: Date | string
    children?: PermissionUncheckedCreateNestedManyWithoutParentInput
  }

  export type PermissionCreateOrConnectWithoutGroupPermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutGroupPermissionsInput, PermissionUncheckedCreateWithoutGroupPermissionsInput>
  }

  export type GroupUpsertWithoutPermissionsInput = {
    update: XOR<GroupUpdateWithoutPermissionsInput, GroupUncheckedUpdateWithoutPermissionsInput>
    create: XOR<GroupCreateWithoutPermissionsInput, GroupUncheckedCreateWithoutPermissionsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutPermissionsInput, GroupUncheckedUpdateWithoutPermissionsInput>
  }

  export type GroupUpdateWithoutPermissionsInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type PermissionUpsertWithoutGroupPermissionsInput = {
    update: XOR<PermissionUpdateWithoutGroupPermissionsInput, PermissionUncheckedUpdateWithoutGroupPermissionsInput>
    create: XOR<PermissionCreateWithoutGroupPermissionsInput, PermissionUncheckedCreateWithoutGroupPermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutGroupPermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutGroupPermissionsInput, PermissionUncheckedUpdateWithoutGroupPermissionsInput>
  }

  export type PermissionUpdateWithoutGroupPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PermissionUpdateOneWithoutChildrenNestedInput
    children?: PermissionUpdateManyWithoutParentNestedInput
  }

  export type PermissionUncheckedUpdateWithoutGroupPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PermissionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type GroupCreateWithoutRoleAssignmentsInput = {
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    parentGroup?: GroupCreateNestedOneWithoutChildGroupsInput
    childGroups?: GroupCreateNestedManyWithoutParentGroupInput
    workspace?: WorkspaceCreateNestedOneWithoutGroupsInput
    project?: ProjectCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutRoleAssignmentsInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
    childGroups?: GroupUncheckedCreateNestedManyWithoutParentGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    permissions?: GroupPermissionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutRoleAssignmentsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutRoleAssignmentsInput, GroupUncheckedCreateWithoutRoleAssignmentsInput>
  }

  export type WorkspaceCreateWithoutRoleAssignmentsInput = {
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutWorkspacesCreatedInput
    users?: WorkspaceUserCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoCreateNestedOneWithoutWorkspaceInput
    groups?: GroupCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutRoleAssignmentsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: WorkspaceUserUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectGroups?: ProjectGroupUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: WorkspaceInvitationUncheckedCreateNestedManyWithoutWorkspaceInput
    logo?: WorkspaceLogoUncheckedCreateNestedOneWithoutWorkspaceInput
    groups?: GroupUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutRoleAssignmentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutRoleAssignmentsInput, WorkspaceUncheckedCreateWithoutRoleAssignmentsInput>
  }

  export type ProjectCreateWithoutRoleAssignmentsInput = {
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    columns?: ColumnCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    tags?: TagCreateNestedManyWithoutProjectInput
    categories?: CategoryCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldCreateNestedManyWithoutProjectInput
    modules?: ModuleCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    budgets?: BudgetCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberCreateNestedManyWithoutProjectInput
    webhooks?: WebhookCreateNestedManyWithoutProjectInput
    groups?: GroupCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRoleAssignmentsInput = {
    id?: number
    workspaceId: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    columns?: ColumnUncheckedCreateNestedManyWithoutProjectInput
    swimlanes?: SwimlaneUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    tags?: TagUncheckedCreateNestedManyWithoutProjectInput
    categories?: CategoryUncheckedCreateNestedManyWithoutProjectInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutProjectInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProjectInput
    wikiPages?: WikiPageUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    projectGroups?: ProjectGroupMemberUncheckedCreateNestedManyWithoutProjectInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutProjectInput
    groups?: GroupUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRoleAssignmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRoleAssignmentsInput, ProjectUncheckedCreateWithoutRoleAssignmentsInput>
  }

  export type GroupUpsertWithoutRoleAssignmentsInput = {
    update: XOR<GroupUpdateWithoutRoleAssignmentsInput, GroupUncheckedUpdateWithoutRoleAssignmentsInput>
    create: XOR<GroupCreateWithoutRoleAssignmentsInput, GroupUncheckedCreateWithoutRoleAssignmentsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutRoleAssignmentsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutRoleAssignmentsInput, GroupUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type GroupUpdateWithoutRoleAssignmentsInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutRoleAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type WorkspaceUpsertWithoutRoleAssignmentsInput = {
    update: XOR<WorkspaceUpdateWithoutRoleAssignmentsInput, WorkspaceUncheckedUpdateWithoutRoleAssignmentsInput>
    create: XOR<WorkspaceCreateWithoutRoleAssignmentsInput, WorkspaceUncheckedCreateWithoutRoleAssignmentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutRoleAssignmentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutRoleAssignmentsInput, WorkspaceUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type WorkspaceUpdateWithoutRoleAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutWorkspacesCreatedNestedInput
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutRoleAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProjectUpsertWithoutRoleAssignmentsInput = {
    update: XOR<ProjectUpdateWithoutRoleAssignmentsInput, ProjectUncheckedUpdateWithoutRoleAssignmentsInput>
    create: XOR<ProjectCreateWithoutRoleAssignmentsInput, ProjectUncheckedCreateWithoutRoleAssignmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRoleAssignmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRoleAssignmentsInput, ProjectUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type ProjectUpdateWithoutRoleAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRoleAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type WorkspaceUserCreateManyWorkspaceInput = {
    id?: number
    userId: number
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
  }

  export type ProjectCreateManyWorkspaceInput = {
    id?: number
    name: string
    identifier?: string | null
    description?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPublic?: boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectGroupCreateManyWorkspaceInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    status?: $Enums.ProjectGroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInvitationCreateManyWorkspaceInput = {
    id?: number
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    createdBy: number
  }

  export type GroupCreateManyWorkspaceInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    projectId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
  }

  export type RoleAssignmentCreateManyWorkspaceInput = {
    id?: number
    groupId: number
    projectId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type WorkspaceUserUpdateWithoutWorkspaceInput = {
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutWorkspaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    columns?: ColumnUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    tags?: TagUpdateManyWithoutProjectNestedInput
    categories?: CategoryUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUpdateManyWithoutProjectNestedInput
    modules?: ModuleUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUpdateManyWithoutProjectNestedInput
    groups?: GroupUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    columns?: ColumnUncheckedUpdateManyWithoutProjectNestedInput
    swimlanes?: SwimlaneUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    tags?: TagUncheckedUpdateManyWithoutProjectNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutProjectNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutProjectNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProjectNestedInput
    wikiPages?: WikiPageUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    projectGroups?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutProjectNestedInput
    groups?: GroupUncheckedUpdateManyWithoutProjectNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    settings?: JsonNullValueInput | InputJsonValue
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupUpdateWithoutWorkspaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectGroupMemberUpdateManyWithoutProjectGroupNestedInput
  }

  export type ProjectGroupUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectGroupMemberUncheckedUpdateManyWithoutProjectGroupNestedInput
  }

  export type ProjectGroupUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectGroupStatusFieldUpdateOperationsInput | $Enums.ProjectGroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInvitationUpdateWithoutWorkspaceInput = {
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutInvitationsCreatedNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: IntFieldUpdateOperationsInput | number
  }

  export type GroupUpdateWithoutWorkspaceInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleAssignmentUpdateWithoutWorkspaceInput = {
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    group?: GroupUpdateOneRequiredWithoutRoleAssignmentsNestedInput
    project?: ProjectUpdateOneWithoutRoleAssignmentsNestedInput
  }

  export type RoleAssignmentUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkspaceUserCreateManyUserInput = {
    id?: number
    workspaceId: number
    role?: $Enums.WorkspaceRole
    joinedAt?: Date | string
  }

  export type WorkspaceCreateManyCreatedByInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceInvitationCreateManyCreatorInput = {
    id?: number
    workspaceId: number
    email: string
    role?: $Enums.WorkspaceRole
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: number
    projectId: number
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
  }

  export type TaskCreateManyCreatorInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TaskAssigneeCreateManyUserInput = {
    id?: number
    taskId: number
    createdAt?: Date | string
  }

  export type SubtaskCreateManyAssigneeInput = {
    id?: number
    taskId: number
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: number
    taskId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyUserInput = {
    id?: number
    taskId: number
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id: string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RememberTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: string
    title: string
    content?: string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: number
    projectId: number
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: number
    name: string
    keyPrefix: string
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    ip: string
    userAgent: string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type LastLoginCreateManyUserInput = {
    id?: number
    authType: string
    ip: string
    userAgent: string
    createdAt?: Date | string
  }

  export type UserMetadataCreateManyUserInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationSettingCreateManyUserInput = {
    id?: number
    notificationType: string
    isEnabled?: boolean
  }

  export type InviteCreateManyInvitedByInput = {
    id?: number
    email: string
    token: string
    role?: $Enums.AppRole
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: number
    groupId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    addedById?: number | null
    externalSync?: boolean
  }

  export type GroupMemberCreateManyAddedByInput = {
    id?: number
    groupId: number
    userId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    externalSync?: boolean
  }

  export type WorkspaceUserUpdateWithoutUserInput = {
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type WorkspaceUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: WorkspaceUserUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectGroups?: ProjectGroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: WorkspaceInvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
    logo?: WorkspaceLogoUncheckedUpdateOneWithoutWorkspaceNestedInput
    groups?: GroupUncheckedUpdateManyWithoutWorkspaceNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInvitationUpdateWithoutCreatorInput = {
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type WorkspaceInvitationUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceInvitationUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumWorkspaceRoleFieldUpdateOperationsInput | $Enums.WorkspaceRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskAssigneeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput
  }

  export type TaskAssigneeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUpdateWithoutAssigneeInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutAssigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RememberTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RememberTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RememberTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastLoginUpdateWithoutUserInput = {
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastLoginUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastLoginUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    authType?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetadataUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetadataUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetadataUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationSettingUpdateWithoutUserInput = {
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserNotificationSettingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserNotificationSettingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationType?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InviteUpdateWithoutInvitedByInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateWithoutInvitedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyWithoutInvitedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    role?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    addedBy?: UserUpdateOneWithoutGroupMembersAddedNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberUpdateWithoutAddedByInput = {
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutAddedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberUncheckedUpdateManyWithoutAddedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: number
    userId: number
    role?: $Enums.ProjectRole
    joinedAt?: Date | string
  }

  export type ColumnCreateManyProjectInput = {
    id?: number
    title: string
    description?: string | null
    position?: number
    taskLimit?: number
    isCollapsed?: boolean
    showClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SwimlaneCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    position?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TagCreateManyProjectInput = {
    id?: number
    name: string
    color?: string
    createdAt?: Date | string
  }

  export type CategoryCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    createdAt?: Date | string
  }

  export type CustomFieldCreateManyProjectInput = {
    id?: number
    name: string
    type?: $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    position?: number
    createdAt?: Date | string
  }

  export type ModuleCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    dateDue?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.SprintStatus
    dateStart: Date | string
    dateEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyProjectInput = {
    id?: number
    name: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WikiPageCreateManyProjectInput = {
    id?: number
    title: string
    content: string
    creatorId?: number | null
    modifierId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyProjectInput = {
    id?: number
    userId?: number | null
    eventType: string
    entityType: string
    entityId: number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProjectGroupMemberCreateManyProjectInput = {
    id?: number
    projectGroupId: number
    position?: number
    createdAt?: Date | string
  }

  export type WebhookCreateManyProjectInput = {
    id?: number
    name: string
    url: string
    secret: string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastSuccess?: Date | string | null
    lastFailure?: Date | string | null
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateManyProjectInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    parentGroupId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
  }

  export type RoleAssignmentCreateManyProjectInput = {
    id?: number
    groupId: number
    workspaceId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColumnUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutColumnNestedInput
  }

  export type ColumnUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    taskLimit?: IntFieldUpdateOperationsInput | number
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    showClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SwimlaneUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutSwimlaneNestedInput
  }

  export type SwimlaneUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSwimlaneNestedInput
  }

  export type SwimlaneUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: TaskCustomValueUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: TaskCustomValueUncheckedUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomFieldTypeFieldUpdateOperationsInput | $Enums.CustomFieldType
    options?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSprintStatusFieldUpdateOperationsInput | $Enums.SprintStatus
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: BudgetLineUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: BudgetLineUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WikiPageUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    modifierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutProjectInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    eventType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberUpdateWithoutProjectInput = {
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectGroup?: ProjectGroupUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectGroupMemberUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectGroupId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectGroupId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSuccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutProjectInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    parentGroup?: GroupUpdateOneWithoutChildGroupsNestedInput
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    parentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleAssignmentUpdateWithoutProjectInput = {
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    group?: GroupUpdateOneRequiredWithoutRoleAssignmentsNestedInput
    workspace?: WorkspaceUpdateOneWithoutRoleAssignmentsNestedInput
  }

  export type RoleAssignmentUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCreateManyColumnInput = {
    id?: number
    projectId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TaskUpdateWithoutColumnInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutColumnInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCreateManySwimlaneInput = {
    id?: number
    projectId: number
    columnId: number
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TaskUpdateWithoutSwimlaneInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSwimlaneInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutSwimlaneInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskAssigneeCreateManyTaskInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type SubtaskCreateManyTaskInput = {
    id?: number
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    position?: number
    assigneeId?: number | null
    timeEstimated?: number
    timeSpent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyTaskInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyTaskInput = {
    id?: number
    userId: number
    name: string
    path: string
    mimeType?: string | null
    size?: number
    isImage?: boolean
    createdAt?: Date | string
  }

  export type TaskTagCreateManyTaskInput = {
    id?: number
    tagId: number
    createdAt?: Date | string
  }

  export type TaskCustomValueCreateManyTaskInput = {
    id?: number
    customFieldId: number
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskLinkCreateManyTaskInput = {
    id?: number
    oppositeTaskId: number
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
  }

  export type TaskLinkCreateManyOppositeTaskInput = {
    id?: number
    taskId: number
    linkType?: $Enums.TaskLinkType
    createdAt?: Date | string
  }

  export type TaskSessionCreateManyTaskInput = {
    id?: number
    sessionId: string
    linkType?: $Enums.TaskSessionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type TaskAssigneeUpdateWithoutTaskInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
  }

  export type TaskAssigneeUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUpdateWithoutTaskInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutSubtasksAssignedNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    assigneeId?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    position?: IntFieldUpdateOperationsInput | number
    assigneeId?: NullableIntFieldUpdateOperationsInput | number | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutTaskInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutTaskInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isImage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagUpdateWithoutTaskInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskTagUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueUpdateWithoutTaskInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customField?: CustomFieldUpdateOneRequiredWithoutValuesNestedInput
  }

  export type TaskCustomValueUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    customFieldId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    customFieldId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkUpdateWithoutTaskInput = {
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oppositeTask?: TaskUpdateOneRequiredWithoutLinksToNestedInput
  }

  export type TaskLinkUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    oppositeTaskId?: IntFieldUpdateOperationsInput | number
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    oppositeTaskId?: IntFieldUpdateOperationsInput | number
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkUpdateWithoutOppositeTaskInput = {
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLinksFromNestedInput
  }

  export type TaskLinkUncheckedUpdateWithoutOppositeTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLinkUncheckedUpdateManyWithoutOppositeTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    linkType?: EnumTaskLinkTypeFieldUpdateOperationsInput | $Enums.TaskLinkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskSessionUpdateWithoutTaskInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskSessionUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskSessionUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    linkType?: EnumTaskSessionTypeFieldUpdateOperationsInput | $Enums.TaskSessionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagCreateManyTagInput = {
    id?: number
    taskId: number
    createdAt?: Date | string
  }

  export type TaskTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TaskTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskTagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyCategoryInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    sprintId?: number | null
  }

  export type TaskUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCustomValueCreateManyCustomFieldInput = {
    id?: number
    taskId: number
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCustomValueUpdateWithoutCustomFieldInput = {
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCustomValuesNestedInput
  }

  export type TaskCustomValueUncheckedUpdateWithoutCustomFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutCustomFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManySprintInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    moduleId?: number | null
    categoryId?: number | null
  }

  export type TaskUpdateWithoutSprintInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSprintInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutSprintInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCreateManyModuleInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    milestoneId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TaskUpdateWithoutModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    milestone?: MilestoneUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestoneId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TaskCreateManyMilestoneInput = {
    id?: number
    projectId: number
    columnId: number
    swimlaneId?: number | null
    creatorId: number
    title: string
    description?: string | null
    reference?: string | null
    priority?: number
    score?: number
    progress?: number
    position?: number
    color?: string | null
    dateStarted?: Date | string | null
    dateDue?: Date | string | null
    dateCompleted?: Date | string | null
    reminderAt?: Date | string | null
    timeEstimated?: number
    timeSpent?: number
    isActive?: boolean
    isDraggable?: boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    moduleId?: number | null
    sprintId?: number | null
    categoryId?: number | null
  }

  export type TaskUpdateWithoutMilestoneInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    column?: ColumnUpdateOneRequiredWithoutTasksNestedInput
    swimlane?: SwimlaneUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneRequiredWithoutTasksCreatedNestedInput
    module?: ModuleUpdateOneWithoutTasksNestedInput
    sprint?: SprintUpdateOneWithoutTasksNestedInput
    category?: CategoryUpdateOneWithoutTasksNestedInput
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutMilestoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    tags?: TaskTagUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    linksFrom?: TaskLinkUncheckedUpdateManyWithoutTaskNestedInput
    linksTo?: TaskLinkUncheckedUpdateManyWithoutOppositeTaskNestedInput
    genxSessions?: TaskSessionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutMilestoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    columnId?: IntFieldUpdateOperationsInput | number
    swimlaneId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    dateStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeEstimated?: FloatFieldUpdateOperationsInput | number
    timeSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDraggable?: BoolFieldUpdateOperationsInput | boolean
    recurrenceData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    sprintId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StickyNoteLinkCreateManyStickyNoteInput = {
    id?: number
    entityType: $Enums.StickyLinkType
    entityId: number
    createdAt?: Date | string
  }

  export type StickyNoteLinkUpdateWithoutStickyNoteInput = {
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteLinkUncheckedUpdateWithoutStickyNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StickyNoteLinkUncheckedUpdateManyWithoutStickyNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: EnumStickyLinkTypeFieldUpdateOperationsInput | $Enums.StickyLinkType
    entityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberCreateManyProjectGroupInput = {
    id?: number
    projectId: number
    position?: number
    createdAt?: Date | string
  }

  export type ProjectGroupMemberUpdateWithoutProjectGroupInput = {
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectGroupsNestedInput
  }

  export type ProjectGroupMemberUncheckedUpdateWithoutProjectGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectGroupMemberUncheckedUpdateManyWithoutProjectGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineCreateManyBudgetInput = {
    id?: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    lineType?: $Enums.BudgetLineType
    taskId?: number | null
    createdAt?: Date | string
  }

  export type BudgetLineUpdateWithoutBudgetInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineUncheckedUpdateWithoutBudgetInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetLineUncheckedUpdateManyWithoutBudgetInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineType?: EnumBudgetLineTypeFieldUpdateOperationsInput | $Enums.BudgetLineType
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: number
    event: string
    payload: JsonNullValueInput | InputJsonValue
    statusCode?: number | null
    response?: string | null
    duration?: number | null
    success?: boolean
    attempts?: number
    deliveredAt?: Date | string
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateManyParentGroupInput = {
    id?: number
    objectGuid?: string
    name: string
    displayName: string
    distinguishedName?: string | null
    description?: string | null
    type: $Enums.GroupType
    scope?: $Enums.GroupScope
    workspaceId?: number | null
    projectId?: number | null
    externalId?: string | null
    source?: $Enums.GroupSource
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isSecurityGroup?: boolean
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: number
    userId: number
    memberType?: $Enums.MemberType
    expiresAt?: Date | string | null
    addedAt?: Date | string
    addedById?: number | null
    externalSync?: boolean
  }

  export type GroupPermissionCreateManyGroupInput = {
    id?: number
    permissionId: number
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type RoleAssignmentCreateManyGroupInput = {
    id?: number
    workspaceId?: number | null
    projectId?: number | null
    role?: $Enums.AssignmentRole
    inheritToChildren?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type GroupUpdateWithoutParentGroupInput = {
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUpdateManyWithoutParentGroupNestedInput
    workspace?: WorkspaceUpdateOneWithoutGroupsNestedInput
    project?: ProjectUpdateOneWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutParentGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
    childGroups?: GroupUncheckedUpdateManyWithoutParentGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    permissions?: GroupPermissionUncheckedUpdateManyWithoutGroupNestedInput
    roleAssignments?: RoleAssignmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutParentGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    objectGuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    distinguishedName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGroupTypeFieldUpdateOperationsInput | $Enums.GroupType
    scope?: EnumGroupScopeFieldUpdateOperationsInput | $Enums.GroupScope
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumGroupSourceFieldUpdateOperationsInput | $Enums.GroupSource
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSecurityGroup?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalSync?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
    addedBy?: UserUpdateOneWithoutGroupMembersAddedNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    memberType?: EnumMemberTypeFieldUpdateOperationsInput | $Enums.MemberType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    externalSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupPermissionUpdateWithoutGroupInput = {
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    permission?: PermissionUpdateOneRequiredWithoutGroupPermissionsNestedInput
  }

  export type GroupPermissionUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GroupPermissionUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentUpdateWithoutGroupInput = {
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    workspace?: WorkspaceUpdateOneWithoutRoleAssignmentsNestedInput
    project?: ProjectUpdateOneWithoutRoleAssignmentsNestedInput
  }

  export type RoleAssignmentUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleAssignmentUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    inheritToChildren?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PermissionCreateManyParentInput = {
    id?: number
    name: string
    displayName: string
    description?: string | null
    category: string
    sortOrder?: number
    createdAt?: Date | string
  }

  export type GroupPermissionCreateManyPermissionInput = {
    id?: number
    groupId: number
    accessType?: $Enums.AccessType
    workspaceId?: number | null
    projectId?: number | null
    inherited?: boolean
    createdAt?: Date | string
    createdById?: number | null
  }

  export type PermissionUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PermissionUpdateManyWithoutParentNestedInput
    groupPermissions?: GroupPermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PermissionUncheckedUpdateManyWithoutParentNestedInput
    groupPermissions?: GroupPermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupPermissionUpdateWithoutPermissionInput = {
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    group?: GroupUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type GroupPermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GroupPermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    workspaceId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    inherited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}